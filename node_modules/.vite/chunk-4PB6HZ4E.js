import {
  require_eventemitter3
} from "./chunk-SA62SW7S.js";
import {
  ProviderRpcErrorCode,
  SofiaProRegular,
  require_joi_browser_min
} from "./chunk-QMB77UJZ.js";
import {
  AbiCoder,
  BaseContract,
  ConstructorFragment,
  Contract,
  ContractFactory,
  ErrorFragment,
  EventFragment,
  FormatTypes,
  Fragment,
  FunctionFragment,
  HDNode,
  Indexed,
  Interface,
  LogDescription,
  ParamType,
  TransactionDescription,
  Wallet,
  Wordlist,
  checkResultErrors,
  commify,
  defaultAbiCoder,
  defaultPath,
  entropyToMnemonic,
  formatEther,
  formatUnits,
  getAccountPath,
  getJsonWalletAddress,
  isValidMnemonic,
  keccak256 as keccak2562,
  mnemonicToEntropy,
  mnemonicToSeed,
  pack,
  parseEther,
  parseUnits,
  sha256 as sha2562,
  verifyMessage,
  verifyTypedData,
  wordlists
} from "./chunk-AOTIW23S.js";
import {
  AddressZero,
  Base58,
  BigNumber,
  FixedNumber,
  ForkEvent,
  HashZero,
  Provider,
  Signer,
  SigningKey,
  SupportedAlgorithm,
  TransactionTypes,
  TypedDataEncoder,
  UnicodeNormalizationForm,
  Utf8ErrorFuncs,
  Utf8ErrorReason,
  VoidSigner,
  _fetchData,
  _toEscapedUtf8String,
  accessListify,
  checkProperties,
  computeAddress,
  computeHmac,
  computePublicKey,
  deepCopy,
  defineReadOnly,
  fetchJson,
  formatBytes32String,
  getAddress,
  getContractAddress,
  getCreate2Address,
  getIcapAddress,
  getNetwork,
  getStatic,
  hashMessage,
  id,
  isAddress,
  isValidName,
  lib_exports,
  lib_exports2,
  lib_exports3,
  namehash,
  nameprep,
  parse,
  parseBytes32String,
  poll,
  randomBytes,
  recoverAddress,
  recoverPublicKey,
  require_bech32,
  resolveProperties,
  ripemd160,
  serialize,
  sha256,
  sha512,
  shallowCopy,
  shuffled,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String
} from "./chunk-NYT6S7VH.js";
import {
  ErrorCode,
  Logger,
  arrayify,
  concat,
  hexConcat,
  hexDataLength,
  hexDataSlice,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexlify,
  isBytes,
  isBytesLike,
  isHexString,
  joinSignature,
  keccak256,
  splitSignature,
  stripZeros,
  zeroPad
} from "./chunk-PDRUHE3M.js";
import {
  __commonJS,
  __export,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toModule,
  init_buffer,
  init_virtual_process_polyfill
} from "./chunk-QYANIK43.js";

// node_modules/lodash.partition/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.partition/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto2 = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var objectToString = objectProto2.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs2 = cache.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs2);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray4(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray4(object), othIsArr = isArray4(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity3;
      }
      if (typeof value == "object") {
        return isArray4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get2(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray4(value) ? value : stringToPath(value);
    }
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray4(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike2(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray4(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray4(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize2(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var partition4 = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() {
      return [[], []];
    });
    function memoize2(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache)();
      return memoized;
    }
    memoize2.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray4 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    function isFunction2(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get2(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity3(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = partition4;
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element2) {
        return cloneUnlessOtherwiseSpecified(element2, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_2) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// node_modules/lodash.merge/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto2 = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto2.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs2 = data.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs2);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray4(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray4(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray4(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction2(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity3), func + "");
    }
    var baseSetToString = !defineProperty ? identity3 : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length = buffer2.length, result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
      buffer2.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count2 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count2 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count2 = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray4 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge4 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity3(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge4;
  }
});

// node_modules/@web3-onboard/core/dist/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Observable.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subscriber.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/tslib/tslib.es6.js
init_virtual_process_polyfill();
init_buffer();
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n) {
    return function(v2) {
      return step([n, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i2 = m2.call(o), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n) {
    if (g2[n])
      i2[n] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n, v2, a2, b2]) > 1 || resume(n, v2);
        });
      };
  }
  function resume(n, v2) {
    try {
      step(g2[n](v2));
    } catch (e) {
      settle(q2[0][3], e);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n) {
    i2[n] = o[n] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isFunction.js
init_virtual_process_polyfill();
init_buffer();
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subscription.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
init_virtual_process_polyfill();
init_buffer();
function createErrorClass(createImpl) {
  var _super = function(instance2) {
    Error.call(instance2);
    instance2.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
init_virtual_process_polyfill();
init_buffer();
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a2, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return))
                _a2.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a2;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty3 = new Subscription2();
    empty3.closed = true;
    return empty3;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/config.js
init_virtual_process_polyfill();
init_buffer();
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
init_virtual_process_polyfill();
init_buffer();
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/noop.js
init_virtual_process_polyfill();
init_buffer();
function noop() {
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
init_virtual_process_polyfill();
init_buffer();
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/errorContext.js
init_virtual_process_polyfill();
init_buffer();
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a2 = context, errorThrown = _a2.errorThrown, error = _a2.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/symbol/observable.js
init_virtual_process_polyfill();
init_buffer();
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/pipe.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/identity.js
init_virtual_process_polyfill();
init_buffer();
function identity(x2) {
  return x2;
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe3) {
    if (subscribe3) {
      this._subscribe = subscribe3;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a2 = _this, operator = _a2.operator, source = _a2.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a2;
    return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe3) {
    return new Observable2(subscribe3);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a2;
  return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/refCount.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/lift.js
init_virtual_process_polyfill();
init_buffer();
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init2) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init2(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
init_virtual_process_polyfill();
init_buffer();
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a2;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
init_virtual_process_polyfill();
init_buffer();
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
init_virtual_process_polyfill();
init_buffer();
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  var schedule = animationFrameProvider.schedule;
  return new Observable(function(subscriber) {
    var subscription = new Subscription();
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var run3 = function(timestamp2) {
      var now3 = provider.now();
      subscriber.next({
        timestamp: timestampProvider ? now3 : timestamp2,
        elapsed: now3 - start
      });
      if (!subscriber.closed) {
        subscription.add(schedule(run3));
      }
    };
    subscription.add(schedule(run3));
    return subscription;
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subject.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
init_virtual_process_polyfill();
init_buffer();
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a2;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return))
              _a2.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a2;
      return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b === void 0 ? void 0 : _b.call(_a2, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b === void 0 ? void 0 : _b.call(_a2);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a2, _b;
    return (_b = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
init_virtual_process_polyfill();
init_buffer();
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, _value = _a2._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
init_virtual_process_polyfill();
init_buffer();
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a2 = this, isStopped = _a2.isStopped, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow, _timestampProvider = _a2._timestampProvider, _windowTime = _a2._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a2 = this, _infiniteTimeWindow = _a2._infiniteTimeWindow, _buffer = _a2._buffer;
    var copy = _buffer.slice();
    for (var i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i2]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a2 = this, _bufferSize = _a2._bufferSize, _timestampProvider = _a2._timestampProvider, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now3 = _timestampProvider.now();
      var last3 = 0;
      for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now3; i2 += 2) {
        last3 = i2;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
init_virtual_process_polyfill();
init_buffer();
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, _hasValue = _a2._hasValue, _value = _a2._value, thrownError = _a2.thrownError, isStopped = _a2.isStopped, _isComplete = _a2._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a2 = this, _hasValue = _a2._hasValue, _value = _a2._value, _isComplete = _a2._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
init_virtual_process_polyfill();
init_buffer();
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
init_virtual_process_polyfill();
init_buffer();
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state2;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id2;
    }
    intervalProvider.clearInterval(id2);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state2, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state2, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state2, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state2);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a2 = this, id2 = _a2.id, scheduler = _a2.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler, id2, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/Immediate.js
init_virtual_process_polyfill();
init_buffer();
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    if (!scheduler.actions.some(function(action) {
      return action.id === id2;
    })) {
      immediateProvider.clearImmediate(id2);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Scheduler.js
init_virtual_process_polyfill();
init_buffer();
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now3) {
    if (now3 === void 0) {
      now3 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now3;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state2, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now3) {
    if (now3 === void 0) {
      now3 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now3) || this;
    _this.actions = [];
    _this._active = false;
    _this._scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/async.js
init_virtual_process_polyfill();
init_buffer();
var asyncScheduler = new AsyncScheduler(AsyncAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
init_virtual_process_polyfill();
init_buffer();
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.delay = delay2;
    this.state = state2;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state2, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    return scheduler.flush(this);
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
init_virtual_process_polyfill();
init_buffer();
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
init_virtual_process_polyfill();
init_buffer();
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    if (!scheduler.actions.some(function(action) {
      return action.id === id2;
    })) {
      animationFrameProvider.cancelAnimationFrame(id2);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
init_virtual_process_polyfill();
init_buffer();
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
init_virtual_process_polyfill();
init_buffer();
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state2, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state2, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return true;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state2, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state2, delay2);
    }
  };
  VirtualAction2.sortActions = function(a2, b2) {
    if (a2.delay === b2.delay) {
      if (a2.index === b2.index) {
        return 0;
      } else if (a2.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Notification.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/empty.js
init_virtual_process_polyfill();
init_buffer();
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/of.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/args.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
init_virtual_process_polyfill();
init_buffer();
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/from.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
init_virtual_process_polyfill();
init_buffer();
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isPromise.js
init_virtual_process_polyfill();
init_buffer();
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
init_virtual_process_polyfill();
init_buffer();
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
init_virtual_process_polyfill();
init_buffer();
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
init_virtual_process_polyfill();
init_buffer();
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
init_virtual_process_polyfill();
init_buffer();
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
init_virtual_process_polyfill();
init_buffer();
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a2, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a2 = _b.sent(), value = _a2.value, done = _a2.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise2) {
  return new Observable(function(subscriber) {
    promise2.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a2;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return))
          _a2.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a2;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a2.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
init_virtual_process_polyfill();
init_buffer();
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
init_virtual_process_polyfill();
init_buffer();
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
init_virtual_process_polyfill();
init_buffer();
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
init_virtual_process_polyfill();
init_buffer();
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
init_virtual_process_polyfill();
init_buffer();
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a2;
        var value;
        var done;
        try {
          _a2 = iterator2.next(), value = _a2.value, done = _a2.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
init_virtual_process_polyfill();
init_buffer();
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
init_virtual_process_polyfill();
init_buffer();
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/throwError.js
init_virtual_process_polyfill();
init_buffer();
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init2 = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init2, 0, subscriber);
  } : init2);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a2 = this, kind = _a2.kind, value = _a2.value, error = _a2.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a2;
    return isFunction((_a2 = nextOrObserver) === null || _a2 === void 0 ? void 0 : _a2.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a2 = this, kind = _a2.kind, value = _a2.value, error = _a2.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a2, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isObservable.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
init_virtual_process_polyfill();
init_buffer();
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
init_virtual_process_polyfill();
init_buffer();
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
init_virtual_process_polyfill();
init_buffer();
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
init_virtual_process_polyfill();
init_buffer();
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
init_virtual_process_polyfill();
init_buffer();
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/timeout.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isDate.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/bindCallback.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/bindCallbackInternals.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/map.js
init_virtual_process_polyfill();
init_buffer();
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/bindNodeCallback.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
init_virtual_process_polyfill();
init_buffer();
var isArray2 = Array.isArray;
var objectProto = Object.prototype;

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/createObject.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/concat.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/connectable.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/defer.js
init_virtual_process_polyfill();
init_buffer();
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/fromEventPattern.js
init_virtual_process_polyfill();
init_buffer();
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e[_i] = arguments[_i];
      }
      return subscriber.next(e.length === 1 ? e[0] : e);
    };
    var retValue = addHandler(handler);
    return isFunction(removeHandler) ? function() {
      return removeHandler(handler, retValue);
    } : void 0;
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/generate.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/iif.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/interval.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/timer.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/merge.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/never.js
init_virtual_process_polyfill();
init_buffer();
var NEVER = new Observable(noop);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/onErrorResumeNext.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/onErrorResumeNext.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
init_virtual_process_polyfill();
init_buffer();
var isArray3 = Array.isArray;

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/pairs.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/partition.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/not.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/filter.js
init_virtual_process_polyfill();
init_buffer();
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/race.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/range.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/using.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/zip.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/types.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/audit.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/auditTime.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/buffer.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/bufferTime.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/bufferToggle.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/bufferWhen.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/catchError.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/combineAll.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/combineLatestAll.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/joinAllInternals.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/toArray.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/reduce.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/concatMapTo.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/concatWith.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/concat.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/connect.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/fromSubscribable.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/count.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/debounce.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/delay.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/take.js
init_virtual_process_polyfill();
init_buffer();
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
init_virtual_process_polyfill();
init_buffer();
function mapTo(value) {
  return map(function() {
    return value;
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/dematerialize.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/distinct.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
init_virtual_process_polyfill();
init_buffer();
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a2, b2) {
  return a2 === b2;
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js
init_virtual_process_polyfill();
init_buffer();
function distinctUntilKeyChanged(key, compare) {
  return distinctUntilChanged(function(x2, y) {
    return compare ? compare(x2[key], y[key]) : x2[key] === y[key];
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/elementAt.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/endWith.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/every.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/exhaust.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/exhaustAll.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/expand.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/finalize.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/find.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/findIndex.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/first.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/groupBy.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/isEmpty.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/last.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/takeLast.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/materialize.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/max.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/flatMap.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeMapTo.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeScan.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/merge.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/min.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/multicast.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/pairwise.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/pluck.js
init_virtual_process_polyfill();
init_buffer();
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return map(function(x2) {
    var currentProp = x2;
    for (var i2 = 0; i2 < length; i2++) {
      var p2 = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i2]];
      if (typeof p2 !== "undefined") {
        currentProp = p2;
      } else {
        return void 0;
      }
    }
    return currentProp;
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/publish.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/publishBehavior.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/publishLast.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/publishReplay.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/raceWith.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/repeat.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/repeatWhen.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/retry.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/retryWhen.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/sample.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/sampleTime.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/scan.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/sequenceEqual.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/share.js
init_virtual_process_polyfill();
init_buffer();
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.connector, connector = _a2 === void 0 ? function() {
    return new Subject();
  } : _a2, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection = null;
    var resetConnection = null;
    var subject = null;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = null;
    };
    var reset = function() {
      cancelReset();
      connection = subject = null;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        from(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return null;
  }
  if (on === false) {
    return null;
  }
  return on.apply(void 0, __spreadArray([], __read(args))).pipe(take(1)).subscribe(function() {
    return reset();
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
init_virtual_process_polyfill();
init_buffer();
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a2, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a2 = configOrBufferSize.bufferSize, bufferSize = _a2 === void 0 ? Infinity : _a2, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/single.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/skip.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/skipLast.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/skipUntil.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/skipWhile.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/startWith.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/switchAll.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
init_virtual_process_polyfill();
init_buffer();
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/switchMapTo.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/switchScan.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
init_virtual_process_polyfill();
init_buffer();
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/tap.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/throttle.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js
init_virtual_process_polyfill();
init_buffer();
var TimeInterval = function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/timeoutWith.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/timestamp.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/window.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/windowCount.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/windowTime.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/windowToggle.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/windowWhen.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
init_virtual_process_polyfill();
init_buffer();
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project = popResultSelector(inputs);
  return operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i3) {
      innerFrom(inputs[i3]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        otherValues[i3] = value;
        if (!ready && !hasValue[i3]) {
          hasValue[i3] = true;
          (ready = hasValue.every(identity)) && (hasValue = null);
        }
      }, noop));
    };
    for (var i2 = 0; i2 < len; i2++) {
      _loop_1(i2);
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray([value], __read(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
      }
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/zipAll.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/zipWith.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/zip.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/operators/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/partition.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/race.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/bowser/src/bowser.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/bowser/src/parser.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/bowser/src/parser-browsers.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/bowser/src/utils.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/bowser/src/constants.js
init_virtual_process_polyfill();
init_buffer();
var BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
var OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};

// node_modules/bowser/src/utils.js
var Utils = class {
  static getFirstMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  static getSecondMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  static matchAndReturnConst(regexp, ua, _const) {
    if (regexp.test(ua)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version3) {
    switch (version3) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  static getMacOSVersionName(version3) {
    const v2 = version3.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v2.push(0);
    if (v2[0] !== 10)
      return void 0;
    switch (v2[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  static getAndroidVersionName(version3) {
    const v2 = version3.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v2.push(0);
    if (v2[0] === 1 && v2[1] < 5)
      return void 0;
    if (v2[0] === 1 && v2[1] < 6)
      return "Cupcake";
    if (v2[0] === 1 && v2[1] >= 6)
      return "Donut";
    if (v2[0] === 2 && v2[1] < 2)
      return "Eclair";
    if (v2[0] === 2 && v2[1] === 2)
      return "Froyo";
    if (v2[0] === 2 && v2[1] > 2)
      return "Gingerbread";
    if (v2[0] === 3)
      return "Honeycomb";
    if (v2[0] === 4 && v2[1] < 1)
      return "Ice Cream Sandwich";
    if (v2[0] === 4 && v2[1] < 4)
      return "Jelly Bean";
    if (v2[0] === 4 && v2[1] >= 4)
      return "KitKat";
    if (v2[0] === 5)
      return "Lollipop";
    if (v2[0] === 6)
      return "Marshmallow";
    if (v2[0] === 7)
      return "Nougat";
    if (v2[0] === 8)
      return "Oreo";
    if (v2[0] === 9)
      return "Pie";
    return void 0;
  }
  static getVersionPrecision(version3) {
    return version3.split(".").length;
  }
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = Utils.getVersionPrecision(versionA);
    const versionBPrecision = Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = Utils.map([versionA, versionB], (version3) => {
      const delta = precision - Utils.getVersionPrecision(version3);
      const _version = version3 + new Array(delta + 1).join(".0");
      return Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  static map(arr, iterator2) {
    const result = [];
    let i2;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator2);
    }
    for (i2 = 0; i2 < arr.length; i2 += 1) {
      result.push(iterator2(arr[i2]));
    }
    return result;
  }
  static find(arr, predicate) {
    let i2;
    let l2;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i2 = 0, l2 = arr.length; i2 < l2; i2 += 1) {
      const value = arr[i2];
      if (predicate(value, i2)) {
        return value;
      }
    }
    return void 0;
  }
  static assign(obj, ...assigners) {
    const result = obj;
    let i2;
    let l2;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i2 = 0, l2 = assigners.length; i2 < l2; i2 += 1) {
      const assigner = assigners[i2];
      if (typeof assigner === "object" && assigner !== null) {
        const keys = Object.keys(assigner);
        keys.forEach((key) => {
          result[key] = assigner[key];
        });
      }
    }
    return obj;
  }
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
};

// node_modules/bowser/src/parser-browsers.js
var commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
var browsersList = [
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser = {
        name: "Googlebot"
      };
      const version3 = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/opera/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version3 = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser = {
        name: "Samsung Internet for Android"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser = {
        name: "NAVER Whale Browser"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser = {
        name: "MZ Browser"
      };
      const version3 = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser = {
        name: "Focus"
      };
      const version3 = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser = {
        name: "Swing"
      };
      const version3 = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser = {
        name: "Opera Coast"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser = {
        name: "Opera Touch"
      };
      const version3 = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser = {
        name: "Yandex Browser"
      };
      const version3 = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser = {
        name: "UC Browser"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser = {
        name: "Maxthon"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser = {
        name: "Epiphany"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser = {
        name: "Puffin"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser = {
        name: "Sleipnir"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser = {
        name: "K-Meleon"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser = {
        name: "WeChat"
      };
      const version3 = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version3 = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser = {
        name: "Internet Explorer"
      };
      const version3 = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version3 = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version3 = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser = {
        name: "Vivaldi"
      };
      const version3 = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser = {
        name: "SeaMonkey"
      };
      const version3 = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser = {
        name: "Sailfish"
      };
      const version3 = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser = {
        name: "Amazon Silk"
      };
      const version3 = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser = {
        name: "PhantomJS"
      };
      const version3 = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser = {
        name: "SlimerJS"
      };
      const version3 = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser = {
        name: "BlackBerry"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser = {
        name: "WebOS Browser"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser = {
        name: "Bada"
      };
      const version3 = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser = {
        name: "Tizen"
      };
      const version3 = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser = {
        name: "QupZilla"
      };
      const version3 = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser = {
        name: "Firefox"
      };
      const version3 = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser = {
        name: "Electron"
      };
      const version3 = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser = {
        name: "Miui"
      };
      const version3 = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser = {
        name: "Chromium"
      };
      const version3 = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser = {
        name: "Chrome"
      };
      const version3 = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser = {
        name: "Google Search"
      };
      const version3 = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser = {
        name: "Android Browser"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser = {
        name: "PlayStation 4"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser = {
        name: "Safari"
      };
      const version3 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version3) {
        browser.version = version3;
      }
      return browser;
    }
  },
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua),
        version: Utils.getSecondMatch(regexp, ua)
      };
    }
  }
];
var parser_browsers_default = browsersList;

// node_modules/bowser/src/parser-os.js
init_virtual_process_polyfill();
init_buffer();
var parser_os_default = [
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version3 = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version: version3
      };
    }
  },
  {
    test: [/windows phone/i],
    describe(ua) {
      const version3 = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version: version3
      };
    }
  },
  {
    test: [/windows /i],
    describe(ua) {
      const version3 = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
      const versionName = Utils.getWindowsVersionName(version3);
      return {
        name: OS_MAP.Windows,
        version: version3,
        versionName
      };
    }
  },
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result = {
        name: OS_MAP.iOS
      };
      const version3 = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      if (version3) {
        result.version = version3;
      }
      return result;
    }
  },
  {
    test: [/macintosh/i],
    describe(ua) {
      const version3 = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version3);
      const os = {
        name: OS_MAP.MacOS,
        version: version3
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version3 = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version: version3
      };
    }
  },
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version3 = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
      const versionName = Utils.getAndroidVersionName(version3);
      const os = {
        name: OS_MAP.Android,
        version: version3
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version3 = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
      const os = {
        name: OS_MAP.WebOS
      };
      if (version3 && version3.length) {
        os.version = version3;
      }
      return os;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version3 = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version: version3
      };
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const version3 = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version: version3
      };
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const version3 = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version: version3
      };
    }
  },
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version3 = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version: version3
      };
    }
  }
];

// node_modules/bowser/src/parser-platforms.js
init_virtual_process_polyfill();
init_buffer();
var parser_platforms_default = [
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova";
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i);
      const likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser) {
      return parser.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  {
    test(parser) {
      return parser.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];

// node_modules/bowser/src/parser-engines.js
init_virtual_process_polyfill();
init_buffer();
var parser_engines_default = [
  {
    test(parser) {
      return parser.getBrowserName(true) === "microsoft edge";
    },
    describe(ua) {
      const isBlinkBased = /\sedg\//i.test(ua);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version3 = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version: version3
      };
    }
  },
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version3 = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        engine.version = version3;
      }
      return engine;
    }
  },
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version3 = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        engine.version = version3;
      }
      return engine;
    }
  },
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i);
      const likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version3 = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        engine.version = version3;
      }
      return engine;
    }
  },
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version3 = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      if (version3) {
        engine.version = version3;
      }
      return engine;
    }
  }
];

// node_modules/bowser/src/parser.js
var Parser = class {
  constructor(UA, skipParsing = false) {
    if (UA === void 0 || UA === null || UA === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  getUA() {
    return this._ua;
  }
  test(regex) {
    return regex.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(parser_browsers_default, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (_browser.test instanceof Array) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils.find(parser_os_default, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (_os.test instanceof Array) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os) {
      this.parsedResult.os = os.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  getOSName(toLowerCase) {
    const { name: name2 } = this.getOS();
    if (toLowerCase) {
      return String(name2).toLowerCase() || "";
    }
    return name2 || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform = Utils.find(parser_platforms_default, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (_platform.test instanceof Array) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform) {
      this.parsedResult.platform = platform.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(parser_engines_default, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (_engine.test instanceof Array) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key) => {
      const currentDefinition = checkTree[key];
      if (typeof currentDefinition === "string") {
        browsers[key] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name2) => this.isOS(name2));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(platformsAndOSNames, (name2) => this.isPlatform(name2));
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name2) => this.isBrowser(name2, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version3) {
    let expectedResults = [0];
    let comparableVersion = version3;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version3[0] === ">" || version3[0] === "<") {
      comparableVersion = version3.substr(1);
      if (version3[1] === "=") {
        isLoose = true;
        comparableVersion = version3.substr(2);
      } else {
        expectedResults = [];
      }
      if (version3[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version3[0] === "=") {
      comparableVersion = version3.substr(1);
    } else if (version3[0] === "~") {
      isLoose = true;
      comparableVersion = version3.substr(1);
    }
    return expectedResults.indexOf(Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)) > -1;
  }
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
};
var parser_default = Parser;

// node_modules/bowser/src/bowser.js
var Bowser = class {
  static getParser(UA, skipParsing = false) {
    if (typeof UA !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new parser_default(UA, skipParsing);
  }
  static parse(UA) {
    return new parser_default(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
};
var bowser_default = Bowser;

// node_modules/@web3-onboard/core/dist/index.js
var import_joi = __toModule(require_joi_browser_min());
var import_lodash = __toModule(require_lodash());

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports2,
  errors: () => ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger15,
  providers: () => lib_exports4,
  utils: () => utils_exports,
  version: () => version2,
  wordlists: () => wordlists
});
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => Provider,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/base-provider.js
init_virtual_process_polyfill();
init_buffer();
var import_bech32 = __toModule(require_bech32());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/_version.js
init_virtual_process_polyfill();
init_buffer();
var version = "providers/5.5.2";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/formatter.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var logger = new Logger(version);
var Formatter = class {
  constructor() {
    logger.checkNew(new.target, Formatter);
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash2 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v2) => {
      return this.data(v2, true);
    };
    formats.transaction = {
      hash: hash2,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash2, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash2,
      address,
      topics: Formatter.arrayOf(hash2),
      data,
      logIndex: number,
      blockHash: hash2
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash2,
      transactionHash: hash2,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: hash2,
      parentHash: hash2,
      number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: address,
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash2)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash2, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash2),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash2),
      transactionHash: hash2,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  bigNumber(value) {
    return BigNumber.from(value);
  }
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    if (blockTag === "latest" || blockTag === "pending") {
      return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v2 = BigNumber.from(value);
    try {
      return v2.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId2 = transaction.chainId;
      if (isHexString(chainId2)) {
        chainId2 = BigNumber.from(chainId2).toNumber();
      }
      result.chainId = chainId2;
    } else {
      let chainId2 = transaction.networkId;
      if (chainId2 == null && result.v == null) {
        chainId2 = transaction.chainId;
      }
      if (isHexString(chainId2)) {
        chainId2 = BigNumber.from(chainId2).toNumber();
      }
      if (typeof chainId2 !== "number" && result.v != null) {
        chainId2 = (result.v - 35) / 2;
        if (chainId2 < 0) {
          chainId2 = 0;
        }
        chainId2 = parseInt(chainId2);
      }
      if (typeof chainId2 !== "number") {
        chainId2 = 0;
      }
      result.chainId = chainId2;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v2) => this.topics(v2));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key in format) {
      try {
        const value = format[key](object[key]);
        if (value !== void 0) {
          result[key] = value;
        }
      } catch (error) {
        error.checkKey = key;
        error.checkValue = object[key];
        throw error;
      }
    }
    return result;
  }
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
};
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
var throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/base-provider.js
"use strict";
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger2 = new Logger(version);
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger2.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger2.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return new Date().getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
var PollableEvents = ["block", "network", "pending", "poll"];
var Event = class {
  constructor(tag, listener, once) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once);
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
var coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result) {
  try {
    return toUtf8String(_parseBytes(result));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
}
function getIpfsLink(link) {
  return `https://gateway.ipfs.io/ipfs/${link.substring(7)}`;
}
var Resolver = class {
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name2);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  _fetchBytes(selector, parameters) {
    return __awaiter2(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      try {
        return _parseBytes(yield this.provider.call(tx));
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        return null;
      }
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger2.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes[1];
      let version3 = bytes[0];
      if (version3 === 0) {
        if (length !== 20 && length !== 32) {
          version3 = -1;
        }
      } else {
        version3 = -1;
      }
      if (version3 >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
        const words = import_bech32.default.toWords(bytes.slice(2));
        words.unshift(version3);
        return import_bech32.default.encode(coinInfo.prefix, words);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const transaction = {
            to: this.address,
            data: "0x3b3b57de" + namehash(this.name).substring(2)
          };
          const hexBytes2 = yield this.provider.call(transaction);
          if (hexBytes2 === "0x" || hexBytes2 === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(hexBytes2);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger2.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter2(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i2 = 0; i2 < matchers.length; i2++) {
          const match = avatar.match(matchers[i2]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance2 = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance2.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance2.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx));
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter2(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      return logger2.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key) {
    return __awaiter2(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key);
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
};
var defaultFormatter = null;
var nextPollId = 1;
var BaseProvider = class extends Provider {
  constructor(network) {
    logger2.checkNew(new.target, Provider);
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger2.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter2(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger2.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  _getInternalBlockNumber(maxAge) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter2(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger2.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger2.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i2 = this._emitted.block + 1; i2 <= blockNumber; i2++) {
          this.emit("block", i2);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key) => {
          if (key === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash2 = event.hash;
            let runner = this.getTransactionReceipt(hash2).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash2] = receipt.blockNumber;
              this.emit(hash2, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            const filter2 = event.filter;
            filter2.fromBlock = this._lastBlockNumber + 1;
            filter2.toBlock = blockNumber;
            const runner = this.getLogs(filter2).then((logs) => {
              if (logs.length === 0) {
                return;
              }
              logs.forEach((log) => {
                this._emitted["b:" + log.blockHash] = log.blockNumber;
                this._emitted["t:" + log.transactionHash] = log.blockNumber;
                this.emit(filter2, log);
              });
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter2(this, void 0, void 0, function* () {
      return logger2.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter2(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger2.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now3 = getTime();
    if (now3 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now3;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout2) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout2 || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout2, replaceable) {
    return __awaiter2(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter2(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter2(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger2.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout2 === "number" && timeout2 > 0) {
          const timer3 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger2.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout: timeout2 }));
          }, timeout2);
          if (timer3.unref) {
            timer3.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer3);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter2(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p2) => hexValue(p2))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  _wrapTransaction(tx, hash2, startBlock) {
    if (hash2 != null && hexDataLength(hash2) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash2 != null && tx.hash !== hash2) {
      logger2.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash2 });
    }
    result.wait = (confirms, timeout2) => __awaiter2(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout2 == null) {
        timeout2 = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout2, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger2.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash2 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash2, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter2(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v2) => v2 ? this._getAddress(v2) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v2) => v2 ? BigNumber.from(v2) : null);
      });
      ["type"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v2) => v2 != null ? v2 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v2) => v2 ? hexlify(v2) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter2(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key) => {
        if (filter2[key] == null) {
          return;
        }
        result[key] = filter2[key];
      });
      ["fromBlock", "toBlock"].forEach((key) => {
        if (filter2[key] == null) {
          return;
        }
        result[key] = this._getBlockTag(filter2[key]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  call(transaction, blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("call", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params,
          result,
          error
        });
      }
    });
  }
  estimateGas(transaction) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter2(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger2.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger2.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger2.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter2(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i2 = 0; i2 < block.transactions.length; i2++) {
            const tx = block.transactions[i2];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter2(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter2(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter2(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger2.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter2(this, void 0, void 0, function* () {
      try {
        const address = yield this._getResolver(name2);
        if (address == null) {
          return null;
        }
        return new Resolver(this, address, name2);
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _getResolver(name2) {
    return __awaiter2(this, void 0, void 0, function* () {
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger2.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: network.name });
      }
      const transaction = {
        to: network.ensAddress,
        data: "0x0178b8bf" + namehash(name2).substring(2)
      };
      try {
        return this.formatter.callAddress(yield this.call(transaction));
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  resolveName(name2) {
    return __awaiter2(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger2.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter2(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddress = yield this._getResolver(reverseName);
      if (!resolverAddress) {
        return null;
      }
      let bytes = arrayify(yield this.call({
        to: resolverAddress,
        data: "0x691f3431" + namehash(reverseName).substring(2)
      }));
      if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) {
        return null;
      }
      bytes = bytes.slice(32);
      if (bytes.length < 32) {
        return null;
      }
      const length = BigNumber.from(bytes.slice(0, 32)).toNumber();
      bytes = bytes.slice(32);
      if (length > bytes.length) {
        return null;
      }
      const name2 = toUtf8String(bytes.slice(0, length));
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter2(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(reverseName);
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, "_", address);
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger2.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event(getEventTag(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger3 = new Logger(version);
var errorGas = ["call", "estimateGas"];
function checkError(method, error, params) {
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e = error.error;
    if (e && e.message.match("reverted") && isHexString(e.data)) {
      return e.data;
    }
    logger3.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
      error,
      data: "0x"
    });
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  const transaction = params.transaction || params.signedTransaction;
  if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
    logger3.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce too low/)) {
    logger3.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced/)) {
    logger3.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/)) {
    logger3.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger3.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer2(timeout2) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout2);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
var _constructorGuard = {};
var JsonRpcSigner = class extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    logger3.checkNew(new.target, JsonRpcSigner);
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger3.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger3.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts2) => {
      if (accounts2.length <= this._index) {
        logger3.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts2[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter3(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger3.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger3.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash2) => {
        return hash2;
      }, (error) => {
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger3.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter3(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash2 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter3(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash2);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash2, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash2;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter3(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
    });
  }
  _legacySignMessage(message) {
    return __awaiter3(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter3(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      return yield this.provider.send("eth_signTypedData_v4", [
        address.toLowerCase(),
        JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
      ]);
    });
  }
  unlock(password) {
    return __awaiter3(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
};
var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash2) => {
      return {
        hash: hash2,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash2, confirmations);
        }
      };
    });
  }
};
var allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
var JsonRpcProvider = class extends BaseProvider {
  constructor(url, network) {
    logger3.checkNew(new.target, JsonRpcProvider);
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter3(this, void 0, void 0, function* () {
      yield timer2(0);
      let chainId2 = null;
      try {
        chainId2 = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId2 = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId2 != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId2).toNumber());
        } catch (error) {
          return logger3.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId: chainId2,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger3.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts2) => {
      return accounts2.map((a2) => this.formatter.address(a2));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
      default:
        break;
    }
    return null;
  }
  perform(method, params) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger3.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash2) {
            self2._emitted["t:" + hash2.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash2).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer2(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys);
    if (allowExtra) {
      for (const key in allowExtra) {
        if (allowExtra[key]) {
          allowed[key] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key) {
      if (transaction[key] == null) {
        return;
      }
      const value = hexValue(transaction[key]);
      if (key === "gasLimit") {
        key = "gas";
      }
      result[key] = value;
    });
    ["from", "to", "data"].forEach(function(key) {
      if (transaction[key] == null) {
        return;
      }
      result[key] = hexlify(transaction[key]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/ws.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger16 = new Logger(version);
  WS = function() {
    logger16.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
"use strict";
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger4 = new Logger(version);
var NextId = 1;
var WebSocketProvider = class extends JsonRpcProvider {
  constructor(url, network) {
    if (network === "any") {
      logger4.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    super(url, network);
    this._pollingInterval = -1;
    this._wsReady = false;
    defineReadOnly(this, "_websocket", new WS(this.connection.url));
    defineReadOnly(this, "_requests", {});
    defineReadOnly(this, "_subs", {});
    defineReadOnly(this, "_subIds", {});
    defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    this._websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id2) => {
        this._websocket.send(this._requests[id2].payload);
      });
    };
    this._websocket.onmessage = (messageEvent) => {
      const data = messageEvent.data;
      const result = JSON.parse(data);
      if (result.id != null) {
        const id2 = String(result.id);
        const request = this._requests[id2];
        delete this._requests[id2];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly(error, "code", result.error.code || null);
            defineReadOnly(error, "response", data);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger4.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger4.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter4(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger4.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this._websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter4(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash2 = event2.hash;
          this.getTransactionReceipt(hash2).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash2, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e) => e.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e) => e.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (this._websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this._websocket.onopen = function() {
            resolve(true);
          };
          this._websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this._websocket.close(1e3);
    });
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger5 = new Logger(version);
var StaticJsonRpcProvider = class extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter5(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger5.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
};
var UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger5.checkAbstract(new.target, UrlJsonRpcProvider);
    network = getStatic(new.target, "getNetwork")(network);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key) => {
        defineReadOnly(this, key, apiKey[key]);
      });
    }
  }
  _startPending() {
    logger5.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger5.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(apiKey) {
    return apiKey;
  }
  static getUrl(network, apiKey) {
    return logger5.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
"use strict";
var logger6 = new Logger(version);
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var AlchemyWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    defineReadOnly(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};
var AlchemyProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger6.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "ropsten":
        host = "eth-ropsten.alchemyapi.io/v2/";
        break;
      case "rinkeby":
        host = "eth-rinkeby.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.alchemyapi.io/v2/";
        break;
      case "kovan":
        host = "eth-kovan.alchemyapi.io/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-rinkeby":
        host = "arb-rinkeby.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-kovan":
        host = "opt-kovan.g.alchemy.com/v2/";
        break;
      default:
        logger6.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger7 = new Logger(version);
var CloudflareProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger7.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger7.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter6(this, void 0, void 0, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger8 = new Logger(version);
function getTransactionPostData(transaction) {
  const result = {};
  for (let key in transaction) {
    if (transaction[key] == null) {
      continue;
    }
    let value = transaction[key];
    if (key === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
      value = hexValue(hexlify(value));
    } else if (key === "accessList") {
      value = "[" + accessListify(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key] = value;
  }
  return result;
}
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || result.message != "OK") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
var defaultApiKey2 = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";
function checkError2(method, error, transaction) {
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e = error.error;
    if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
      let data = e.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString(data)) {
        return data;
      }
      logger8.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger8.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger8.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger8.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger8.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
var EtherscanProvider = class extends BaseProvider {
  constructor(network, apiKey) {
    logger8.checkNew(new.target, EtherscanProvider);
    super(network);
    defineReadOnly(this, "baseUrl", this.getBaseUrl());
    defineReadOnly(this, "apiKey", apiKey || defaultApiKey2);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "ropsten":
        return "https://api-ropsten.etherscan.io";
      case "rinkeby":
        return "https://api-rinkeby.etherscan.io";
      case "kovan":
        return "https://api-kovan.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      default:
    }
    return logger8.throwArgumentError("unsupported network", "network", name);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module, params, post) {
    return __awaiter7(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult2;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key) => {
          return `${key}=${payload[key]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter7(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter7(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError2("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger8.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger8.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks = {};
          for (let i2 = 0; i2 < logs.length; i2++) {
            const log = logs[i2];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
        default:
          break;
      }
      return _super.perform.call(this, method, params);
    });
  }
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter7(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key) {
          if (tx[key] == "") {
            delete tx[key];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger9 = new Logger(version);
function now() {
  return new Date().getTime();
}
function checkNetworks(networks) {
  let result = null;
  for (let i2 = 0; i2 < networks.length; i2++) {
    const network = networks[i2];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger9.throwArgumentError("provider mismatch", "networks", networks);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a2 = values[middle - 1], b2 = values[middle];
  if (maxDelta != null && Math.abs(a2 - b2) > maxDelta) {
    return null;
  }
  return (a2 + b2) / 2;
}
function serialize2(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i2) => serialize2(i2)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map((key) => {
      let v2 = value[key];
      if (typeof v2 === "function") {
        v2 = "[function]";
      } else {
        v2 = serialize2(v2);
      }
      return JSON.stringify(key) + ":" + v2;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
var nextRid = 1;
function stall2(duration) {
  let cancel = null;
  let timer3 = null;
  let promise2 = new Promise((resolve) => {
    cancel = function() {
      if (timer3) {
        clearTimeout(timer3);
        timer3 = null;
      }
      resolve();
    };
    timer3 = setTimeout(cancel, duration);
  });
  const wait2 = (func) => {
    promise2 = promise2.then(func);
    return promise2;
  };
  function getPromise() {
    return promise2;
  }
  return { cancel, getPromise, wait: wait2 };
}
var ForwardErrors = [
  Logger.errors.CALL_EXCEPTION,
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED,
  Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config2, now3) {
  const result = {
    weight: config2.weight
  };
  Object.defineProperty(result, "provider", { get: () => config2.provider });
  if (config2.start) {
    result.start = config2.start;
  }
  if (now3) {
    result.duration = now3 - config2.start;
  }
  if (config2.done) {
    if (config2.error) {
      result.error = config2.error;
    } else {
      result.result = config2.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c2) => {
      const value = normalize(c2.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c2.result };
      }
      tally[value].count++;
    });
    const keys = Object.keys(tally);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const check = tally[keys[i2]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize = serialize2;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        let blockNumber = median(configs.map((c2) => c2.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c2) => c2.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize2(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize2(block);
        };
      } else {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          return serialize2(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize, provider.quorum);
}
function waitForSync(config2, blockNumber) {
  return __awaiter8(this, void 0, void 0, function* () {
    const provider = config2.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config2.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config2, currentBlockNumber, method, params) {
  return __awaiter8(this, void 0, void 0, function* () {
    let provider = config2.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter2 = params.filter;
        if (filter2.fromBlock && isHexString(filter2.fromBlock) || filter2.toBlock && isHexString(filter2.toBlock)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getLogs(filter2);
      }
    }
    return logger9.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
var FallbackProvider = class extends BaseProvider {
  constructor(providers, quorum) {
    logger9.checkNew(new.target, FallbackProvider);
    if (providers.length === 0) {
      logger9.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config2 = shallowCopy(configOrProvider);
      if (config2.priority == null) {
        config2.priority = 1;
      }
      if (config2.stallTimeout == null) {
        config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config2.weight == null) {
        config2.weight = 1;
      }
      const weight = config2.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger9.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config2);
    });
    const total = providerConfigs.reduce((accum, c2) => accum + c2.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger9.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c2) => c2.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter8(this, void 0, void 0, function* () {
      const networks = yield Promise.all(this.providerConfigs.map((c2) => c2.provider.getNetwork()));
      return checkNetworks(networks);
    });
  }
  perform(method, params) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results = yield Promise.all(this.providerConfigs.map((c2) => {
          return c2.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i3 = 0; i3 < results.length; i3++) {
          const result = results[i3];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy));
      configs.sort((a2, b2) => a2.priority - b2.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i2 = 0;
      let first2 = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c2) => c2.runner && t0 - c2.start < c2.stallTimeout).reduce((accum, c2) => accum + c2.weight, 0);
        while (inflightWeight < this.quorum && i2 < configs.length) {
          const config2 = configs[i2++];
          const rid = nextRid++;
          config2.start = now();
          config2.staller = stall2(config2.stallTimeout);
          config2.staller.wait(() => {
            config2.staller = null;
          });
          config2.runner = getRunner(config2, currentBlockNumber, method, params).then((result) => {
            config2.done = true;
            config2.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          }, (error) => {
            config2.done = true;
            config2.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config2, null),
              request: { method, params: deepCopy(params) },
              provider: this
            });
          }
          inflightWeight += config2.weight;
        }
        const waiting = [];
        configs.forEach((c2) => {
          if (c2.done || !c2.runner) {
            return;
          }
          waiting.push(c2.runner);
          if (c2.staller) {
            waiting.push(c2.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results = configs.filter((c2) => c2.done && c2.error == null);
        if (results.length >= this.quorum) {
          const result = processFunc(results);
          if (result !== void 0) {
            configs.forEach((c2) => {
              if (c2.staller) {
                c2.staller.cancel();
              }
              c2.cancelled = true;
            });
            return result;
          }
          if (!first2) {
            yield stall2(100).getPromise();
          }
          first2 = false;
        }
        const errors = configs.reduce((accum, c2) => {
          if (!c2.done || c2.error == null) {
            return accum;
          }
          const code = c2.error.code;
          if (ForwardErrors.indexOf(code) >= 0) {
            if (!accum[code]) {
              accum[code] = { error: c2.error, weight: 0 };
            }
            accum[code].weight += c2.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach((errorCode) => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c2) => {
            if (c2.staller) {
              c2.staller.cancel();
            }
            c2.cancelled = true;
          });
          const e = tally.error;
          const props = {};
          ForwardProperties.forEach((name2) => {
            if (e[name2] == null) {
              return;
            }
            props[name2] = e[name2];
          });
          logger9.throwError(e.reason || e.message, errorCode, props);
        });
        if (configs.filter((c2) => !c2.done).length === 0) {
          break;
        }
      }
      configs.forEach((c2) => {
        if (c2.staller) {
          c2.staller.cancel();
        }
        c2.cancelled = true;
      });
      return logger9.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
        method,
        params,
        results: configs.map((c2) => exposeDebugConfig(c2)),
        provider: this
      });
    });
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var IpcProvider = null;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/infura-provider.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var logger10 = new Logger(version);
var defaultProjectId = "84842078b09946638c03157f83405213";
var InfuraWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger10.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly(this, "apiKey", provider.projectId);
    defineReadOnly(this, "projectId", provider.projectId);
    defineReadOnly(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
var InfuraProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger10.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger10.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "ropsten":
        host = "ropsten.infura.io";
        break;
      case "rinkeby":
        host = "rinkeby.infura.io";
        break;
      case "kovan":
        host = "kovan.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-kovan":
        host = "optimism-kovan.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-rinkeby":
        host = "arbitrum-rinkeby.infura.io";
        break;
      default:
        logger10.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
init_virtual_process_polyfill();
init_buffer();
var JsonRpcBatchProvider = class extends JsonRpcProvider {
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise2 = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy(request2),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise2;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var logger11 = new Logger(version);
var defaultApiKey3 = "ETHERS_JS_SHARED";
var NodesmithProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger11.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey3;
  }
  static getUrl(network, apiKey) {
    logger11.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger11.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var logger12 = new Logger(version);
var defaultApplicationIds = {
  homestead: "6004bcd10040261633ade990",
  ropsten: "6004bd4d0040261633ade991",
  rinkeby: "6004bda20040261633ade994",
  goerli: "6004bd860040261633ade992"
};
var PocketProvider = class extends UrlJsonRpcProvider {
  constructor(network, apiKey) {
    if (apiKey == null) {
      const n = getStatic(new.target, "getNetwork")(network);
      if (n) {
        const applicationId = defaultApplicationIds[n.name];
        if (applicationId) {
          apiKey = {
            applicationId,
            loadBalancer: true
          };
        }
      }
      if (apiKey == null) {
        logger12.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
      }
    }
    super(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      logger12.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", apiKey);
    }
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: false,
      applicationSecretKey: null
    };
    if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      logger12.assertArgument(typeof apiKey.applicationId === "string", "applicationSecretKey requires an applicationId", "applicationId", apiKey.applicationId);
      logger12.assertArgument(typeof apiKey.applicationSecretKey === "string", "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]");
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else if (apiKey.applicationId) {
      logger12.assertArgument(typeof apiKey.applicationId === "string", "apiKey.applicationId must be a string", "apiKey.applicationId", apiKey.applicationId);
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else {
      logger12.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      default:
        logger12.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    let url = null;
    if (apiKey.loadBalancer) {
      url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    } else {
      url = `https://${host}/v1/${apiKey.applicationId}`;
    }
    const connection = { url };
    connection.headers = {};
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationIds[this.network.name];
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/web3-provider.js
init_virtual_process_polyfill();
init_buffer();
"use strict";
var logger13 = new Logger(version);
var _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
var Web3Provider = class extends JsonRpcProvider {
  constructor(provider, network) {
    logger13.checkNew(new.target, Web3Provider);
    if (provider == null) {
      logger13.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger13.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/index.js
"use strict";
var logger14 = new Logger(version);
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1]) {
        case "http":
          return new JsonRpcProvider(network);
        case "ws":
          return new WebSocketProvider(network);
        default:
          logger14.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n = getNetwork(network);
  if (!n || !n._defaultProvider) {
    logger14.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger,
  ParamType: () => ParamType,
  RLP: () => lib_exports,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify,
  base58: () => Base58,
  base64: () => lib_exports3,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize,
  sha256: () => sha256,
  sha512: () => sha512,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack,
  soliditySha256: () => sha2562,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});
init_virtual_process_polyfill();
init_buffer();
"use strict";

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/_version.js
init_virtual_process_polyfill();
init_buffer();
var version2 = "ethers/5.5.3";

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/ethers.js
"use strict";
var logger15 = new Logger(version2);

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/index.js
"use strict";
try {
  const anyGlobal = window;
  if (anyGlobal._ethers == null) {
    anyGlobal._ethers = ethers_exports;
  }
} catch (error) {
}

// node_modules/svelte-i18n/dist/runtime.esm.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/svelte/store/index.mjs
init_virtual_process_polyfill();
init_buffer();

// node_modules/svelte/internal/index.mjs
init_virtual_process_polyfill();
init_buffer();
function noop2() {
}
function run(fn) {
  return fn();
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop2;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var tasks = new Set();
var managed_styles = new Map();
var resolved_promise = Promise.resolve();
var seen_callbacks = new Set();
var outroing = new Set();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : globalThis;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop2;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop2) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe3(run3, invalidate = noop2) {
    const subscriber = [run3, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop2;
    }
    run3(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe3 };
}
function derived(stores, fn, initial_value) {
  const single2 = !Array.isArray(stores);
  const stores_array = single2 ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop2;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single2 ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop2;
      }
    };
    const unsubscribers = stores_array.map((store, i2) => subscribe(store, (value) => {
      values[i2] = value;
      pending &= ~(1 << i2);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i2;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}

// node_modules/svelte-i18n/dist/runtime.esm.js
var import_deepmerge = __toModule(require_cjs());

// node_modules/intl-messageformat/lib/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/intl-messageformat/lib/src/core.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/intl-messageformat/node_modules/tslib/tslib.es6.js
init_virtual_process_polyfill();
init_buffer();
var extendStatics2 = function(d2, b2) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics2(d2, b2);
};
function __extends2(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics2(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign4(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray2(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/@formatjs/icu-messageformat-parser/lib/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@formatjs/icu-messageformat-parser/node_modules/tslib/tslib.es6.js
init_virtual_process_polyfill();
init_buffer();
var __assign2 = function() {
  __assign2 = Object.assign || function __assign4(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign2.apply(this, arguments);
};

// node_modules/@formatjs/icu-messageformat-parser/lib/error.js
init_virtual_process_polyfill();
init_buffer();
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));

// node_modules/@formatjs/icu-messageformat-parser/lib/parser.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@formatjs/icu-messageformat-parser/lib/types.js
init_virtual_process_polyfill();
init_buffer();
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
  TYPE2[TYPE2["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}

// node_modules/@formatjs/icu-messageformat-parser/lib/regex.generated.js
init_virtual_process_polyfill();
init_buffer();
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

// node_modules/@formatjs/icu-skeleton-parser/lib/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js
init_virtual_process_polyfill();
init_buffer();
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match) {
    var len = match.length;
    switch (match[0]) {
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        result.weekday = len === 4 ? "short" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "a":
        result.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}

// node_modules/@formatjs/icu-skeleton-parser/lib/number.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@formatjs/icu-skeleton-parser/node_modules/tslib/tslib.es6.js
init_virtual_process_polyfill();
init_buffer();
var __assign3 = function() {
  __assign3 = Object.assign || function __assign4(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign3.apply(this, arguments);
};

// node_modules/@formatjs/icu-skeleton-parser/lib/regex.generated.js
init_virtual_process_polyfill();
init_buffer();
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

// node_modules/@formatjs/icu-skeleton-parser/lib/number.js
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x2) {
    return x2.length > 0;
  });
  var tokens = [];
  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
    var stringToken = stringTokens_1[_i];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
    for (var _a2 = 0, options_1 = options; _a2 < options_1.length; _a2++) {
      var option = options_1[_a2];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_2, g1, g2) {
    if (typeof g2 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g2 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g2 === "string" ? g2.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    switch (token.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign3(__assign3(__assign3({}, result), { notation: "scientific" }), token.options.reduce(function(all, opt2) {
          return __assign3(__assign3({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign3(__assign3(__assign3({}, result), { notation: "engineering" }), token.options.reduce(function(all, opt2) {
          return __assign3(__assign3({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token.options[0]);
        continue;
      case "integer-width":
        if (token.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token.options[0].replace(INTEGER_WIDTH_REGEX, function(_2, g1, g2, g3, g4, g5) {
          if (g1) {
            result.minimumIntegerDigits = g2.length;
          } else if (g3 && g4) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g5) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
      result.minimumIntegerDigits = token.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token.stem)) {
      if (token.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token.stem.replace(FRACTION_PRECISION_REGEX, function(_2, g1, g2, g3, g4, g5) {
        if (g2 === "*") {
          result.minimumFractionDigits = g1.length;
        } else if (g3 && g3[0] === "#") {
          result.maximumFractionDigits = g3.length;
        } else if (g4 && g5) {
          result.minimumFractionDigits = g4.length;
          result.maximumFractionDigits = g4.length + g5.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length;
        }
        return "";
      });
      var opt = token.options[0];
      if (opt === "w") {
        result = __assign3(__assign3({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign3(__assign3({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
      result = __assign3(__assign3({}, result), parseSignificantPrecision(token.stem));
      continue;
    }
    var signOpts = parseSign(token.stem);
    if (signOpts) {
      result = __assign3(__assign3({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign3(__assign3({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}

// node_modules/@formatjs/icu-messageformat-parser/lib/parser.js
var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start, end) {
  return { start, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith;
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n) {
  return typeof n === "number" && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (_2) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var re;
var startsWith = hasNativeStartsWith ? function startsWith2(s2, search, position) {
  return s2.startsWith(search, position);
} : function startsWith3(s2, search, position) {
  return s2.slice(position, position + search.length) === search;
};
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : function fromCodePoint2() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  var elements = "";
  var length = codePoints.length;
  var i2 = 0;
  var code;
  while (length > i2) {
    code = codePoints[i2++];
    if (code > 1114111)
      throw RangeError(code + " is not a valid code point");
    elements += code < 65536 ? String.fromCharCode(code) : String.fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
  }
  return elements;
};
var fromEntries = hasNativeFromEntries ? Object.fromEntries : function fromEntries2(entries) {
  var obj = {};
  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
    var _a2 = entries_1[_i], k2 = _a2[0], v2 = _a2[1];
    obj[k2] = v2;
  }
  return obj;
};
var codePointAt = hasNativeCodePointAt ? function codePointAt2(s2, index) {
  return s2.codePointAt(index);
} : function codePointAt3(s2, index) {
  var size = s2.length;
  if (index < 0 || index >= size) {
    return void 0;
  }
  var first2 = s2.charCodeAt(index);
  var second;
  return first2 < 55296 || first2 > 56319 || index + 1 === size || (second = s2.charCodeAt(index + 1)) < 56320 || second > 57343 ? first2 : (first2 - 55296 << 10) + (second - 56320) + 65536;
};
var trimStart = hasTrimStart ? function trimStart2(s2) {
  return s2.trimStart();
} : function trimStart3(s2) {
  return s2.replace(SPACE_SEPARATOR_START_REGEX, "");
};
var trimEnd = hasTrimEnd ? function trimEnd2(s2) {
  return s2.trimEnd();
} : function trimEnd3(s2) {
  return s2.replace(SPACE_SEPARATOR_END_REGEX, "");
};
function RE(s2, flag) {
  return new RegExp(s2, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s2, index) {
    var _a2;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index;
    var match = IDENTIFIER_PREFIX_RE_1.exec(s2);
    return (_a2 = match[1]) !== null && _a2 !== void 0 ? _a2 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s2, index) {
    var match = [];
    while (true) {
      var c2 = codePointAt(s2, index);
      if (c2 === void 0 || _isWhiteSpace(c2) || _isPatternSyntax(c2)) {
        break;
      }
      match.push(c2);
      index += c2 >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, match);
  };
}
var IDENTIFIER_PREFIX_RE_1;
var Parser2 = function() {
  function Parser3(message, options) {
    if (options === void 0) {
      options = {};
    }
    this.message = message;
    this.position = { offset: 0, line: 1, column: 1 };
    this.ignoreTag = !!options.ignoreTag;
    this.requiresOtherClause = !!options.requiresOtherClause;
    this.shouldParseSkeletons = !!options.shouldParseSkeletons;
  }
  Parser3.prototype.parse = function() {
    if (this.offset() !== 0) {
      throw Error("parser can only be used once");
    }
    return this.parseMessage(0, "", false);
  };
  Parser3.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
    var elements = [];
    while (!this.isEOF()) {
      var char = this.char();
      if (char === 123) {
        var result = this.parseArgument(nestingLevel, expectingCloseTag);
        if (result.err) {
          return result;
        }
        elements.push(result.val);
      } else if (char === 125 && nestingLevel > 0) {
        break;
      } else if (char === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
        var position = this.clonePosition();
        this.bump();
        elements.push({
          type: TYPE.pound,
          location: createLocation(position, this.clonePosition())
        });
      } else if (char === 60 && !this.ignoreTag && this.peek() === 47) {
        if (expectingCloseTag) {
          break;
        } else {
          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
        }
      } else if (char === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
        var result = this.parseTag(nestingLevel, parentArgType);
        if (result.err) {
          return result;
        }
        elements.push(result.val);
      } else {
        var result = this.parseLiteral(nestingLevel, parentArgType);
        if (result.err) {
          return result;
        }
        elements.push(result.val);
      }
    }
    return { val: elements, err: null };
  };
  Parser3.prototype.parseTag = function(nestingLevel, parentArgType) {
    var startPosition = this.clonePosition();
    this.bump();
    var tagName = this.parseTagName();
    this.bumpSpace();
    if (this.bumpIf("/>")) {
      return {
        val: {
          type: TYPE.literal,
          value: "<".concat(tagName, "/>"),
          location: createLocation(startPosition, this.clonePosition())
        },
        err: null
      };
    } else if (this.bumpIf(">")) {
      var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
      if (childrenResult.err) {
        return childrenResult;
      }
      var children2 = childrenResult.val;
      var endTagStartPosition = this.clonePosition();
      if (this.bumpIf("</")) {
        if (this.isEOF() || !_isAlpha(this.char())) {
          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
        }
        var closingTagNameStartPosition = this.clonePosition();
        var closingTagName = this.parseTagName();
        if (tagName !== closingTagName) {
          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
        }
        this.bumpSpace();
        if (!this.bumpIf(">")) {
          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
        }
        return {
          val: {
            type: TYPE.tag,
            value: tagName,
            children: children2,
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else {
        return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
      }
    } else {
      return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
    }
  };
  Parser3.prototype.parseTagName = function() {
    var startOffset = this.offset();
    this.bump();
    while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
      this.bump();
    }
    return this.message.slice(startOffset, this.offset());
  };
  Parser3.prototype.parseLiteral = function(nestingLevel, parentArgType) {
    var start = this.clonePosition();
    var value = "";
    while (true) {
      var parseQuoteResult = this.tryParseQuote(parentArgType);
      if (parseQuoteResult) {
        value += parseQuoteResult;
        continue;
      }
      var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
      if (parseUnquotedResult) {
        value += parseUnquotedResult;
        continue;
      }
      var parseLeftAngleResult = this.tryParseLeftAngleBracket();
      if (parseLeftAngleResult) {
        value += parseLeftAngleResult;
        continue;
      }
      break;
    }
    var location = createLocation(start, this.clonePosition());
    return {
      val: { type: TYPE.literal, value, location },
      err: null
    };
  };
  Parser3.prototype.tryParseLeftAngleBracket = function() {
    if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || !_isAlphaOrSlash(this.peek() || 0))) {
      this.bump();
      return "<";
    }
    return null;
  };
  Parser3.prototype.tryParseQuote = function(parentArgType) {
    if (this.isEOF() || this.char() !== 39) {
      return null;
    }
    switch (this.peek()) {
      case 39:
        this.bump();
        this.bump();
        return "'";
      case 123:
      case 60:
      case 62:
      case 125:
        break;
      case 35:
        if (parentArgType === "plural" || parentArgType === "selectordinal") {
          break;
        }
        return null;
      default:
        return null;
    }
    this.bump();
    var codePoints = [this.char()];
    this.bump();
    while (!this.isEOF()) {
      var ch = this.char();
      if (ch === 39) {
        if (this.peek() === 39) {
          codePoints.push(39);
          this.bump();
        } else {
          this.bump();
          break;
        }
      } else {
        codePoints.push(ch);
      }
      this.bump();
    }
    return fromCodePoint.apply(void 0, codePoints);
  };
  Parser3.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
    if (this.isEOF()) {
      return null;
    }
    var ch = this.char();
    if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
      return null;
    } else {
      this.bump();
      return fromCodePoint(ch);
    }
  };
  Parser3.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
    var openingBracePosition = this.clonePosition();
    this.bump();
    this.bumpSpace();
    if (this.isEOF()) {
      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
    }
    if (this.char() === 125) {
      this.bump();
      return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
    }
    var value = this.parseIdentifierIfPossible().value;
    if (!value) {
      return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
    }
    this.bumpSpace();
    if (this.isEOF()) {
      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
    }
    switch (this.char()) {
      case 125: {
        this.bump();
        return {
          val: {
            type: TYPE.argument,
            value,
            location: createLocation(openingBracePosition, this.clonePosition())
          },
          err: null
        };
      }
      case 44: {
        this.bump();
        this.bumpSpace();
        if (this.isEOF()) {
          return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
      }
      default:
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
    }
  };
  Parser3.prototype.parseIdentifierIfPossible = function() {
    var startingPosition = this.clonePosition();
    var startOffset = this.offset();
    var value = matchIdentifierAtIndex(this.message, startOffset);
    var endOffset = startOffset + value.length;
    this.bumpTo(endOffset);
    var endPosition = this.clonePosition();
    var location = createLocation(startingPosition, endPosition);
    return { value, location };
  };
  Parser3.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value, openingBracePosition) {
    var _a2;
    var typeStartPosition = this.clonePosition();
    var argType = this.parseIdentifierIfPossible().value;
    var typeEndPosition = this.clonePosition();
    switch (argType) {
      case "":
        return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      case "number":
      case "date":
      case "time": {
        this.bumpSpace();
        var styleAndLocation = null;
        if (this.bumpIf(",")) {
          this.bumpSpace();
          var styleStartPosition = this.clonePosition();
          var result = this.parseSimpleArgStyleIfPossible();
          if (result.err) {
            return result;
          }
          var style = trimEnd(result.val);
          if (style.length === 0) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
          }
          var styleLocation = createLocation(styleStartPosition, this.clonePosition());
          styleAndLocation = { style, styleLocation };
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        var location_1 = createLocation(openingBracePosition, this.clonePosition());
        if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
          var skeleton = trimStart(styleAndLocation.style.slice(2));
          if (argType === "number") {
            var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
            if (result.err) {
              return result;
            }
            return {
              val: { type: TYPE.number, value, location: location_1, style: result.val },
              err: null
            };
          } else {
            if (skeleton.length === 0) {
              return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
            }
            var style = {
              type: SKELETON_TYPE.dateTime,
              pattern: skeleton,
              location: styleAndLocation.styleLocation,
              parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(skeleton) : {}
            };
            var type = argType === "date" ? TYPE.date : TYPE.time;
            return {
              val: { type, value, location: location_1, style },
              err: null
            };
          }
        }
        return {
          val: {
            type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
            value,
            location: location_1,
            style: (_a2 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a2 !== void 0 ? _a2 : null
          },
          err: null
        };
      }
      case "plural":
      case "selectordinal":
      case "select": {
        var typeEndPosition_1 = this.clonePosition();
        this.bumpSpace();
        if (!this.bumpIf(",")) {
          return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign2({}, typeEndPosition_1)));
        }
        this.bumpSpace();
        var identifierAndLocation = this.parseIdentifierIfPossible();
        var pluralOffset = 0;
        if (argType !== "select" && identifierAndLocation.value === "offset") {
          if (!this.bumpIf(":")) {
            return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
          }
          this.bumpSpace();
          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
          if (result.err) {
            return result;
          }
          this.bumpSpace();
          identifierAndLocation = this.parseIdentifierIfPossible();
          pluralOffset = result.val;
        }
        var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
        if (optionsResult.err) {
          return optionsResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        var location_2 = createLocation(openingBracePosition, this.clonePosition());
        if (argType === "select") {
          return {
            val: {
              type: TYPE.select,
              value,
              options: fromEntries(optionsResult.val),
              location: location_2
            },
            err: null
          };
        } else {
          return {
            val: {
              type: TYPE.plural,
              value,
              options: fromEntries(optionsResult.val),
              offset: pluralOffset,
              pluralType: argType === "plural" ? "cardinal" : "ordinal",
              location: location_2
            },
            err: null
          };
        }
      }
      default:
        return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
    }
  };
  Parser3.prototype.tryParseArgumentClose = function(openingBracePosition) {
    if (this.isEOF() || this.char() !== 125) {
      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
    }
    this.bump();
    return { val: true, err: null };
  };
  Parser3.prototype.parseSimpleArgStyleIfPossible = function() {
    var nestedBraces = 0;
    var startPosition = this.clonePosition();
    while (!this.isEOF()) {
      var ch = this.char();
      switch (ch) {
        case 39: {
          this.bump();
          var apostrophePosition = this.clonePosition();
          if (!this.bumpUntil("'")) {
            return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
          }
          this.bump();
          break;
        }
        case 123: {
          nestedBraces += 1;
          this.bump();
          break;
        }
        case 125: {
          if (nestedBraces > 0) {
            nestedBraces -= 1;
          } else {
            return {
              val: this.message.slice(startPosition.offset, this.offset()),
              err: null
            };
          }
          break;
        }
        default:
          this.bump();
          break;
      }
    }
    return {
      val: this.message.slice(startPosition.offset, this.offset()),
      err: null
    };
  };
  Parser3.prototype.parseNumberSkeletonFromString = function(skeleton, location) {
    var tokens = [];
    try {
      tokens = parseNumberSkeletonFromString(skeleton);
    } catch (e) {
      return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);
    }
    return {
      val: {
        type: SKELETON_TYPE.number,
        tokens,
        location,
        parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
      },
      err: null
    };
  };
  Parser3.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
    var _a2;
    var hasOtherClause = false;
    var options = [];
    var parsedSelectors = new Set();
    var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
    while (true) {
      if (selector.length === 0) {
        var startPosition = this.clonePosition();
        if (parentArgType !== "select" && this.bumpIf("=")) {
          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
          if (result.err) {
            return result;
          }
          selectorLocation = createLocation(startPosition, this.clonePosition());
          selector = this.message.slice(startPosition.offset, this.offset());
        } else {
          break;
        }
      }
      if (parsedSelectors.has(selector)) {
        return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
      }
      if (selector === "other") {
        hasOtherClause = true;
      }
      this.bumpSpace();
      var openingBracePosition = this.clonePosition();
      if (!this.bumpIf("{")) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
      }
      var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
      if (fragmentResult.err) {
        return fragmentResult;
      }
      var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
      if (argCloseResult.err) {
        return argCloseResult;
      }
      options.push([
        selector,
        {
          value: fragmentResult.val,
          location: createLocation(openingBracePosition, this.clonePosition())
        }
      ]);
      parsedSelectors.add(selector);
      this.bumpSpace();
      _a2 = this.parseIdentifierIfPossible(), selector = _a2.value, selectorLocation = _a2.location;
    }
    if (options.length === 0) {
      return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
    }
    if (this.requiresOtherClause && !hasOtherClause) {
      return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
    }
    return { val: options, err: null };
  };
  Parser3.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
    var sign = 1;
    var startingPosition = this.clonePosition();
    if (this.bumpIf("+")) {
    } else if (this.bumpIf("-")) {
      sign = -1;
    }
    var hasDigits = false;
    var decimal = 0;
    while (!this.isEOF()) {
      var ch = this.char();
      if (ch >= 48 && ch <= 57) {
        hasDigits = true;
        decimal = decimal * 10 + (ch - 48);
        this.bump();
      } else {
        break;
      }
    }
    var location = createLocation(startingPosition, this.clonePosition());
    if (!hasDigits) {
      return this.error(expectNumberError, location);
    }
    decimal *= sign;
    if (!isSafeInteger(decimal)) {
      return this.error(invalidNumberError, location);
    }
    return { val: decimal, err: null };
  };
  Parser3.prototype.offset = function() {
    return this.position.offset;
  };
  Parser3.prototype.isEOF = function() {
    return this.offset() === this.message.length;
  };
  Parser3.prototype.clonePosition = function() {
    return {
      offset: this.position.offset,
      line: this.position.line,
      column: this.position.column
    };
  };
  Parser3.prototype.char = function() {
    var offset = this.position.offset;
    if (offset >= this.message.length) {
      throw Error("out of bound");
    }
    var code = codePointAt(this.message, offset);
    if (code === void 0) {
      throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
    }
    return code;
  };
  Parser3.prototype.error = function(kind, location) {
    return {
      val: null,
      err: {
        kind,
        message: this.message,
        location
      }
    };
  };
  Parser3.prototype.bump = function() {
    if (this.isEOF()) {
      return;
    }
    var code = this.char();
    if (code === 10) {
      this.position.line += 1;
      this.position.column = 1;
      this.position.offset += 1;
    } else {
      this.position.column += 1;
      this.position.offset += code < 65536 ? 1 : 2;
    }
  };
  Parser3.prototype.bumpIf = function(prefix) {
    if (startsWith(this.message, prefix, this.offset())) {
      for (var i2 = 0; i2 < prefix.length; i2++) {
        this.bump();
      }
      return true;
    }
    return false;
  };
  Parser3.prototype.bumpUntil = function(pattern) {
    var currentOffset = this.offset();
    var index = this.message.indexOf(pattern, currentOffset);
    if (index >= 0) {
      this.bumpTo(index);
      return true;
    } else {
      this.bumpTo(this.message.length);
      return false;
    }
  };
  Parser3.prototype.bumpTo = function(targetOffset) {
    if (this.offset() > targetOffset) {
      throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
    }
    targetOffset = Math.min(targetOffset, this.message.length);
    while (true) {
      var offset = this.offset();
      if (offset === targetOffset) {
        break;
      }
      if (offset > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
      }
      this.bump();
      if (this.isEOF()) {
        break;
      }
    }
  };
  Parser3.prototype.bumpSpace = function() {
    while (!this.isEOF() && _isWhiteSpace(this.char())) {
      this.bump();
    }
  };
  Parser3.prototype.peek = function() {
    if (this.isEOF()) {
      return null;
    }
    var code = this.char();
    var offset = this.offset();
    var nextCode = this.message.charCodeAt(offset + (code >= 65536 ? 2 : 1));
    return nextCode !== null && nextCode !== void 0 ? nextCode : null;
  };
  return Parser3;
}();
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c2) {
  return c2 === 45 || c2 === 46 || c2 >= 48 && c2 <= 57 || c2 === 95 || c2 >= 97 && c2 <= 122 || c2 >= 65 && c2 <= 90 || c2 == 183 || c2 >= 192 && c2 <= 214 || c2 >= 216 && c2 <= 246 || c2 >= 248 && c2 <= 893 || c2 >= 895 && c2 <= 8191 || c2 >= 8204 && c2 <= 8205 || c2 >= 8255 && c2 <= 8256 || c2 >= 8304 && c2 <= 8591 || c2 >= 11264 && c2 <= 12271 || c2 >= 12289 && c2 <= 55295 || c2 >= 63744 && c2 <= 64975 || c2 >= 65008 && c2 <= 65533 || c2 >= 65536 && c2 <= 983039;
}
function _isWhiteSpace(c2) {
  return c2 >= 9 && c2 <= 13 || c2 === 32 || c2 === 133 || c2 >= 8206 && c2 <= 8207 || c2 === 8232 || c2 === 8233;
}
function _isPatternSyntax(c2) {
  return c2 >= 33 && c2 <= 35 || c2 === 36 || c2 >= 37 && c2 <= 39 || c2 === 40 || c2 === 41 || c2 === 42 || c2 === 43 || c2 === 44 || c2 === 45 || c2 >= 46 && c2 <= 47 || c2 >= 58 && c2 <= 59 || c2 >= 60 && c2 <= 62 || c2 >= 63 && c2 <= 64 || c2 === 91 || c2 === 92 || c2 === 93 || c2 === 94 || c2 === 96 || c2 === 123 || c2 === 124 || c2 === 125 || c2 === 126 || c2 === 161 || c2 >= 162 && c2 <= 165 || c2 === 166 || c2 === 167 || c2 === 169 || c2 === 171 || c2 === 172 || c2 === 174 || c2 === 176 || c2 === 177 || c2 === 182 || c2 === 187 || c2 === 191 || c2 === 215 || c2 === 247 || c2 >= 8208 && c2 <= 8213 || c2 >= 8214 && c2 <= 8215 || c2 === 8216 || c2 === 8217 || c2 === 8218 || c2 >= 8219 && c2 <= 8220 || c2 === 8221 || c2 === 8222 || c2 === 8223 || c2 >= 8224 && c2 <= 8231 || c2 >= 8240 && c2 <= 8248 || c2 === 8249 || c2 === 8250 || c2 >= 8251 && c2 <= 8254 || c2 >= 8257 && c2 <= 8259 || c2 === 8260 || c2 === 8261 || c2 === 8262 || c2 >= 8263 && c2 <= 8273 || c2 === 8274 || c2 === 8275 || c2 >= 8277 && c2 <= 8286 || c2 >= 8592 && c2 <= 8596 || c2 >= 8597 && c2 <= 8601 || c2 >= 8602 && c2 <= 8603 || c2 >= 8604 && c2 <= 8607 || c2 === 8608 || c2 >= 8609 && c2 <= 8610 || c2 === 8611 || c2 >= 8612 && c2 <= 8613 || c2 === 8614 || c2 >= 8615 && c2 <= 8621 || c2 === 8622 || c2 >= 8623 && c2 <= 8653 || c2 >= 8654 && c2 <= 8655 || c2 >= 8656 && c2 <= 8657 || c2 === 8658 || c2 === 8659 || c2 === 8660 || c2 >= 8661 && c2 <= 8691 || c2 >= 8692 && c2 <= 8959 || c2 >= 8960 && c2 <= 8967 || c2 === 8968 || c2 === 8969 || c2 === 8970 || c2 === 8971 || c2 >= 8972 && c2 <= 8991 || c2 >= 8992 && c2 <= 8993 || c2 >= 8994 && c2 <= 9e3 || c2 === 9001 || c2 === 9002 || c2 >= 9003 && c2 <= 9083 || c2 === 9084 || c2 >= 9085 && c2 <= 9114 || c2 >= 9115 && c2 <= 9139 || c2 >= 9140 && c2 <= 9179 || c2 >= 9180 && c2 <= 9185 || c2 >= 9186 && c2 <= 9254 || c2 >= 9255 && c2 <= 9279 || c2 >= 9280 && c2 <= 9290 || c2 >= 9291 && c2 <= 9311 || c2 >= 9472 && c2 <= 9654 || c2 === 9655 || c2 >= 9656 && c2 <= 9664 || c2 === 9665 || c2 >= 9666 && c2 <= 9719 || c2 >= 9720 && c2 <= 9727 || c2 >= 9728 && c2 <= 9838 || c2 === 9839 || c2 >= 9840 && c2 <= 10087 || c2 === 10088 || c2 === 10089 || c2 === 10090 || c2 === 10091 || c2 === 10092 || c2 === 10093 || c2 === 10094 || c2 === 10095 || c2 === 10096 || c2 === 10097 || c2 === 10098 || c2 === 10099 || c2 === 10100 || c2 === 10101 || c2 >= 10132 && c2 <= 10175 || c2 >= 10176 && c2 <= 10180 || c2 === 10181 || c2 === 10182 || c2 >= 10183 && c2 <= 10213 || c2 === 10214 || c2 === 10215 || c2 === 10216 || c2 === 10217 || c2 === 10218 || c2 === 10219 || c2 === 10220 || c2 === 10221 || c2 === 10222 || c2 === 10223 || c2 >= 10224 && c2 <= 10239 || c2 >= 10240 && c2 <= 10495 || c2 >= 10496 && c2 <= 10626 || c2 === 10627 || c2 === 10628 || c2 === 10629 || c2 === 10630 || c2 === 10631 || c2 === 10632 || c2 === 10633 || c2 === 10634 || c2 === 10635 || c2 === 10636 || c2 === 10637 || c2 === 10638 || c2 === 10639 || c2 === 10640 || c2 === 10641 || c2 === 10642 || c2 === 10643 || c2 === 10644 || c2 === 10645 || c2 === 10646 || c2 === 10647 || c2 === 10648 || c2 >= 10649 && c2 <= 10711 || c2 === 10712 || c2 === 10713 || c2 === 10714 || c2 === 10715 || c2 >= 10716 && c2 <= 10747 || c2 === 10748 || c2 === 10749 || c2 >= 10750 && c2 <= 11007 || c2 >= 11008 && c2 <= 11055 || c2 >= 11056 && c2 <= 11076 || c2 >= 11077 && c2 <= 11078 || c2 >= 11079 && c2 <= 11084 || c2 >= 11085 && c2 <= 11123 || c2 >= 11124 && c2 <= 11125 || c2 >= 11126 && c2 <= 11157 || c2 === 11158 || c2 >= 11159 && c2 <= 11263 || c2 >= 11776 && c2 <= 11777 || c2 === 11778 || c2 === 11779 || c2 === 11780 || c2 === 11781 || c2 >= 11782 && c2 <= 11784 || c2 === 11785 || c2 === 11786 || c2 === 11787 || c2 === 11788 || c2 === 11789 || c2 >= 11790 && c2 <= 11798 || c2 === 11799 || c2 >= 11800 && c2 <= 11801 || c2 === 11802 || c2 === 11803 || c2 === 11804 || c2 === 11805 || c2 >= 11806 && c2 <= 11807 || c2 === 11808 || c2 === 11809 || c2 === 11810 || c2 === 11811 || c2 === 11812 || c2 === 11813 || c2 === 11814 || c2 === 11815 || c2 === 11816 || c2 === 11817 || c2 >= 11818 && c2 <= 11822 || c2 === 11823 || c2 >= 11824 && c2 <= 11833 || c2 >= 11834 && c2 <= 11835 || c2 >= 11836 && c2 <= 11839 || c2 === 11840 || c2 === 11841 || c2 === 11842 || c2 >= 11843 && c2 <= 11855 || c2 >= 11856 && c2 <= 11857 || c2 === 11858 || c2 >= 11859 && c2 <= 11903 || c2 >= 12289 && c2 <= 12291 || c2 === 12296 || c2 === 12297 || c2 === 12298 || c2 === 12299 || c2 === 12300 || c2 === 12301 || c2 === 12302 || c2 === 12303 || c2 === 12304 || c2 === 12305 || c2 >= 12306 && c2 <= 12307 || c2 === 12308 || c2 === 12309 || c2 === 12310 || c2 === 12311 || c2 === 12312 || c2 === 12313 || c2 === 12314 || c2 === 12315 || c2 === 12316 || c2 === 12317 || c2 >= 12318 && c2 <= 12319 || c2 === 12320 || c2 === 12336 || c2 === 64830 || c2 === 64831 || c2 >= 65093 && c2 <= 65094;
}

// node_modules/@formatjs/icu-messageformat-parser/lib/index.js
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k2 in el.options) {
        delete el.options[k2].location;
        pruneLocation(el.options[k2].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse2(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign2({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser2(message, opts).parse();
  if (result.err) {
    var error = SyntaxError(ErrorKind[result.err.kind]);
    error.location = result.err.location;
    error.originalMessage = result.err.message;
    throw error;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}

// node_modules/@formatjs/fast-memoize/lib/index.js
init_virtual_process_polyfill();
init_buffer();
function memoize(fn, options) {
  var cache = options && options.cache ? options.cache : cacheDefault;
  var serializer = options && options.serializer ? options.serializer : serializerDefault;
  var strategy = options && options.strategy ? options.strategy : strategyDefault;
  return strategy(fn, {
    cache,
    serializer
  });
}
function isPrimitive(value) {
  return value == null || typeof value === "number" || typeof value === "boolean";
}
function monadic(fn, cache, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
  var computedValue = cache.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn.call(this, arg);
    cache.set(cacheKey, computedValue);
  }
  return computedValue;
}
function variadic(fn, cache, serializer) {
  var args = Array.prototype.slice.call(arguments, 3);
  var cacheKey = serializer(args);
  var computedValue = cache.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn.apply(this, args);
    cache.set(cacheKey, computedValue);
  }
  return computedValue;
}
function assemble(fn, context2, strategy, cache, serialize3) {
  return strategy.bind(context2, fn, cache, serialize3);
}
function strategyDefault(fn, options) {
  var strategy = fn.length === 1 ? monadic : variadic;
  return assemble(fn, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn, options) {
  return assemble(fn, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn, options) {
  return assemble(fn, this, monadic, options.cache.create(), options.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key) {
  return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function(key, value) {
  this.cache[key] = value;
};
var cacheDefault = {
  create: function create() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
};

// node_modules/intl-messageformat/lib/src/formatters.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/intl-messageformat/lib/src/error.js
init_virtual_process_polyfill();
init_buffer();
var ErrorCode2;
(function(ErrorCode3) {
  ErrorCode3["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode3["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode3["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode2 || (ErrorCode2 = {}));
var FormatError = function(_super) {
  __extends2(FormatError2, _super);
  function FormatError2(msg, code, originalMessage) {
    var _this = _super.call(this, msg) || this;
    _this.code = code;
    _this.originalMessage = originalMessage;
    return _this;
  }
  FormatError2.prototype.toString = function() {
    return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
  };
  return FormatError2;
}(Error);
var InvalidValueError = function(_super) {
  __extends2(InvalidValueError2, _super);
  function InvalidValueError2(variableId, value, options, originalMessage) {
    return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value, '". Options are "').concat(Object.keys(options).join('", "'), '"'), ErrorCode2.INVALID_VALUE, originalMessage) || this;
  }
  return InvalidValueError2;
}(FormatError);
var InvalidValueTypeError = function(_super) {
  __extends2(InvalidValueTypeError2, _super);
  function InvalidValueTypeError2(value, type, originalMessage) {
    return _super.call(this, 'Value for "'.concat(value, '" must be of type ').concat(type), ErrorCode2.INVALID_VALUE, originalMessage) || this;
  }
  return InvalidValueTypeError2;
}(FormatError);
var MissingValueError = function(_super) {
  __extends2(MissingValueError2, _super);
  function MissingValueError2(variableId, originalMessage) {
    return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode2.MISSING_VALUE, originalMessage) || this;
  }
  return MissingValueError2;
}(FormatError);

// node_modules/intl-messageformat/lib/src/formatters.js
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all, part) {
    var lastPart = all[all.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
    var el = els_1[_i];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values && varName in values)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value = values[varName];
    if (isArgumentElement(el)) {
      if (!value || typeof value === "string" || typeof value === "number") {
        value = typeof value === "string" || typeof value === "number" ? String(value) : "";
      }
      result.push({
        type: typeof value === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style && style.scale) {
        value = value * (style.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getNumberFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children2 = el.children, value_1 = el.value;
      var formatFn = values[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts(children2, locales, formatters, formats, values, currentPluralValue);
      var chunks = formatFn(parts.map(function(p2) {
        return p2.value;
      }));
      if (!Array.isArray(chunks)) {
        chunks = [chunks];
      }
      result.push.apply(result, chunks.map(function(c2) {
        return {
          type: typeof c2 === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c2
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode2.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(value - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}

// node_modules/intl-messageformat/lib/src/core.js
function mergeConfig(c1, c2) {
  if (!c2) {
    return c1;
  }
  return __assign(__assign(__assign({}, c1 || {}), c2 || {}), Object.keys(c1).reduce(function(all, k2) {
    all[k2] = __assign(__assign({}, c1[k2]), c2[k2] || {});
    return all;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all, k2) {
    all[k2] = mergeConfig(defaultConfig[k2], configs[k2]);
    return all;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createDefaultFormatters(cache) {
  if (cache === void 0) {
    cache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray2([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray2([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray2([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = function() {
  function IntlMessageFormat2(message, locales, overrideFormats, opts) {
    var _this = this;
    if (locales === void 0) {
      locales = IntlMessageFormat2.defaultLocale;
    }
    this.formatterCache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
    this.format = function(values) {
      var parts = _this.formatToParts(values);
      if (parts.length === 1) {
        return parts[0].value;
      }
      var result = parts.reduce(function(all, part) {
        if (!all.length || part.type !== PART_TYPE.literal || typeof all[all.length - 1] !== "string") {
          all.push(part.value);
        } else {
          all[all.length - 1] += part.value;
        }
        return all;
      }, []);
      if (result.length <= 1) {
        return result[0] || "";
      }
      return result;
    };
    this.formatToParts = function(values) {
      return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, void 0, _this.message);
    };
    this.resolvedOptions = function() {
      return {
        locale: Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
      };
    };
    this.getAst = function() {
      return _this.ast;
    };
    if (typeof message === "string") {
      this.message = message;
      if (!IntlMessageFormat2.__parse) {
        throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
      }
      this.ast = IntlMessageFormat2.__parse(message, {
        ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag
      });
    } else {
      this.ast = message;
    }
    if (!Array.isArray(this.ast)) {
      throw new TypeError("A message must be provided as a String or AST.");
    }
    this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
    this.locales = locales;
    this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
  }
  Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
    get: function() {
      if (!IntlMessageFormat2.memoizedDefaultLocale) {
        IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
      }
      return IntlMessageFormat2.memoizedDefaultLocale;
    },
    enumerable: false,
    configurable: true
  });
  IntlMessageFormat2.memoizedDefaultLocale = null;
  IntlMessageFormat2.__parse = parse2;
  IntlMessageFormat2.formats = {
    number: {
      integer: {
        maximumFractionDigits: 0
      },
      currency: {
        style: "currency"
      },
      percent: {
        style: "percent"
      }
    },
    date: {
      short: {
        month: "numeric",
        day: "numeric",
        year: "2-digit"
      },
      medium: {
        month: "short",
        day: "numeric",
        year: "numeric"
      },
      long: {
        month: "long",
        day: "numeric",
        year: "numeric"
      },
      full: {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      }
    },
    time: {
      short: {
        hour: "numeric",
        minute: "numeric"
      },
      medium: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      },
      long: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      },
      full: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      }
    }
  };
  return IntlMessageFormat2;
}();

// node_modules/intl-messageformat/lib/index.js
var lib_default = IntlMessageFormat;

// node_modules/svelte-i18n/dist/runtime.esm.js
var r = {};
var i = (e, n, t2) => t2 ? (n in r || (r[n] = {}), e in r[n] || (r[n][e] = t2), t2) : t2;
var l = (e, n) => {
  if (n == null)
    return;
  if (n in r && e in r[n])
    return r[n][e];
  const t2 = E(n);
  for (let o = 0; o < t2.length; o++) {
    const r2 = c(t2[o], e);
    if (r2)
      return i(e, n, r2);
  }
};
var a;
var s = writable({});
function u(e) {
  return e in a;
}
function c(e, n) {
  if (!u(e))
    return null;
  return function(e2, n2) {
    if (n2 == null)
      return;
    if (n2 in e2)
      return e2[n2];
    const t2 = n2.split(".");
    let o = e2;
    for (let e3 = 0; e3 < t2.length; e3++)
      if (typeof o == "object") {
        if (e3 > 0) {
          const n3 = t2.slice(e3, t2.length).join(".");
          if (n3 in o) {
            o = o[n3];
            break;
          }
        }
        o = o[t2[e3]];
      } else
        o = void 0;
    return o;
  }(function(e2) {
    return a[e2] || null;
  }(e), n);
}
function m(e, ...n) {
  delete r[e], s.update((o) => (o[e] = import_deepmerge.default.all([o[e] || {}, ...n]), o));
}
var f = derived([s], ([e]) => Object.keys(e));
s.subscribe((e) => a = e);
var d = {};
function g(e) {
  return d[e];
}
function w(e) {
  return e != null && E(e).some((e2) => {
    var n;
    return (n = g(e2)) === null || n === void 0 ? void 0 : n.size;
  });
}
function h(e, n) {
  return Promise.all(n.map((n2) => (function(e2, n3) {
    d[e2].delete(n3), d[e2].size === 0 && delete d[e2];
  }(e, n2), n2().then((e2) => e2.default || e2)))).then((n2) => m(e, ...n2));
}
var p = {};
function b(e) {
  if (!w(e))
    return e in p ? p[e] : Promise.resolve();
  const n = function(e2) {
    return E(e2).map((e3) => {
      const n2 = g(e3);
      return [e3, n2 ? [...n2] : []];
    }).filter(([, e3]) => e3.length > 0);
  }(e);
  return p[e] = Promise.all(n.map(([e2, n2]) => h(e2, n2))).then(() => {
    if (w(e))
      return b(e);
    delete p[e];
  }), p[e];
}
function v(e, n) {
  var t2 = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && n.indexOf(o) < 0 && (t2[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") {
    var r2 = 0;
    for (o = Object.getOwnPropertySymbols(e); r2 < o.length; r2++)
      n.indexOf(o[r2]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r2]) && (t2[o[r2]] = e[o[r2]]);
  }
  return t2;
}
var O = { fallbackLocale: null, loadingDelay: 200, formats: { number: { scientific: { notation: "scientific" }, engineering: { notation: "engineering" }, compactLong: { notation: "compact", compactDisplay: "long" }, compactShort: { notation: "compact", compactDisplay: "short" } }, date: { short: { month: "numeric", day: "numeric", year: "2-digit" }, medium: { month: "short", day: "numeric", year: "numeric" }, long: { month: "long", day: "numeric", year: "numeric" }, full: { weekday: "long", month: "long", day: "numeric", year: "numeric" } }, time: { short: { hour: "numeric", minute: "numeric" }, medium: { hour: "numeric", minute: "numeric", second: "numeric" }, long: { hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short" }, full: { hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short" } } }, warnOnMissingMessages: true, ignoreTag: true };
function j() {
  return O;
}
function $(e) {
  const { formats: n } = e, t2 = v(e, ["formats"]), o = e.initialLocale || e.fallbackLocale;
  return Object.assign(O, t2, { initialLocale: o }), n && ("number" in n && Object.assign(O.formats.number, n.number), "date" in n && Object.assign(O.formats.date, n.date), "time" in n && Object.assign(O.formats.time, n.time)), M.set(o);
}
var k = writable(false);
var L;
var T = writable(null);
function x(e) {
  return e.split("-").map((e2, n, t2) => t2.slice(0, n + 1).join("-")).reverse();
}
function E(e, n = j().fallbackLocale) {
  const t2 = x(e);
  return n ? [...new Set([...t2, ...x(n)])] : t2;
}
function D() {
  return L != null ? L : void 0;
}
T.subscribe((e) => {
  L = e != null ? e : void 0, typeof window != "undefined" && e != null && document.documentElement.setAttribute("lang", e);
});
var M = Object.assign(Object.assign({}, T), { set: (e) => {
  if (e && function(e2) {
    if (e2 == null)
      return;
    const n = E(e2);
    for (let e3 = 0; e3 < n.length; e3++) {
      const t2 = n[e3];
      if (u(t2))
        return t2;
    }
  }(e) && w(e)) {
    const { loadingDelay: n } = j();
    let t2;
    return typeof window != "undefined" && D() != null && n ? t2 = window.setTimeout(() => k.set(true), n) : k.set(true), b(e).then(() => {
      T.set(e);
    }).finally(() => {
      clearTimeout(t2), k.set(false);
    });
  }
  return T.set(e);
} });
var I = () => typeof window == "undefined" ? null : window.navigator.language || window.navigator.languages[0];
var Z = (e) => {
  const n = Object.create(null);
  return (t2) => {
    const o = JSON.stringify(t2);
    return o in n ? n[o] : n[o] = e(t2);
  };
};
var C = (e, n) => {
  const { formats: t2 } = j();
  if (e in t2 && n in t2[e])
    return t2[e][n];
  throw new Error(`[svelte-i18n] Unknown "${n}" ${e} format.`);
};
var G = Z((e) => {
  var { locale: n, format: t2 } = e, o = v(e, ["locale", "format"]);
  if (n == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format numbers');
  return t2 && (o = C("number", t2)), new Intl.NumberFormat(n, o);
});
var J = Z((e) => {
  var { locale: n, format: t2 } = e, o = v(e, ["locale", "format"]);
  if (n == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format dates');
  return t2 ? o = C("date", t2) : Object.keys(o).length === 0 && (o = C("date", "short")), new Intl.DateTimeFormat(n, o);
});
var U = Z((e) => {
  var { locale: n, format: t2 } = e, o = v(e, ["locale", "format"]);
  if (n == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format time values');
  return t2 ? o = C("time", t2) : Object.keys(o).length === 0 && (o = C("time", "short")), new Intl.DateTimeFormat(n, o);
});
var _ = (e = {}) => {
  var { locale: n = D() } = e, t2 = v(e, ["locale"]);
  return G(Object.assign({ locale: n }, t2));
};
var q = (e = {}) => {
  var { locale: n = D() } = e, t2 = v(e, ["locale"]);
  return J(Object.assign({ locale: n }, t2));
};
var B = (e = {}) => {
  var { locale: n = D() } = e, t2 = v(e, ["locale"]);
  return U(Object.assign({ locale: n }, t2));
};
var H = Z((e, n = D()) => new lib_default(e, n, j().formats, { ignoreTag: j().ignoreTag }));
var K = (e, n = {}) => {
  let t2 = n;
  typeof e == "object" && (t2 = e, e = t2.id);
  const { values: o, locale: r2 = D(), default: i2 } = t2;
  if (r2 == null)
    throw new Error("[svelte-i18n] Cannot format a message without first setting the initial locale.");
  let a2 = l(e, r2);
  if (a2) {
    if (typeof a2 != "string")
      return console.warn(`[svelte-i18n] Message with id "${e}" must be of type "string", found: "${typeof a2}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`), a2;
  } else
    j().warnOnMissingMessages && console.warn(`[svelte-i18n] The message "${e}" was not found in "${E(r2).join('", "')}".${w(D()) ? "\n\nNote: there are at least one loader still registered to this locale that wasn't executed." : ""}`), a2 = i2 != null ? i2 : e;
  if (!o)
    return a2;
  let s2 = a2;
  try {
    s2 = H(a2, r2).format(o);
  } catch (n2) {
    console.warn(`[svelte-i18n] Message "${e}" has syntax error:`, n2.message);
  }
  return s2;
};
var Q = (e, n) => B(n).format(e);
var R = (e, n) => q(n).format(e);
var V = (e, n) => _(n).format(e);
var W = (e, n = D()) => l(e, n);
var X = derived([M, s], () => K);
var Y = derived([M], () => Q);
var ee = derived([M], () => R);
var ne = derived([M], () => V);
var te = derived([M, s], () => W);

// node_modules/@web3-onboard/core/dist/index.js
var import_lodash2 = __toModule(require_lodash2());
var import_eventemitter3 = __toModule(require_eventemitter3());
var ADD_CHAINS = "add_chains";
var RESET_STORE = "reset_store";
var ADD_WALLET = "add_wallet";
var UPDATE_WALLET = "update_wallet";
var REMOVE_WALLET = "remove_wallet";
var UPDATE_ACCOUNT = "update_account";
var SET_WALLET_MODULES = "set_wallet_modules";
var APP_INITIAL_STATE = {
  chains: [],
  walletModules: [],
  wallets: []
};
var STORAGE_KEYS = {
  TERMS_AGREEMENT: "onboard.js:agreement"
};
var notNullish = (value) => value != null;
function getDeviceInfo() {
  const parsed = bowser_default.getParser(window.navigator.userAgent);
  const os = parsed.getOS();
  const browser = parsed.getBrowser();
  const { type } = parsed.getPlatform();
  return {
    type,
    os,
    browser
  };
}
function validEnsChain(chainId2) {
  switch (chainId2) {
    case "0x1":
    case "0x3":
    case "0x4":
    case "0x5":
      return true;
    default:
      return false;
  }
}
function isSVG(str) {
  return str.includes("<svg");
}
function initializeWalletModules(modules, device) {
  return modules.reduce((acc, walletInit2) => {
    const initialized = walletInit2({ device });
    if (initialized) {
      acc.push(...Array.isArray(initialized) ? initialized : [initialized]);
    }
    return acc;
  }, []);
}
function reducer(state2, action) {
  const { type, payload } = action;
  switch (type) {
    case ADD_CHAINS:
      return __spreadProps(__spreadValues({}, state2), {
        chains: [...state2.chains, ...payload]
      });
    case ADD_WALLET: {
      const wallet2 = payload;
      const existingWallet = state2.wallets.find(({ label }) => label === wallet2.label);
      return __spreadProps(__spreadValues({}, state2), {
        wallets: [
          existingWallet || payload,
          ...state2.wallets.filter(({ label }) => label !== wallet2.label)
        ]
      });
    }
    case UPDATE_WALLET: {
      const update2 = payload;
      const _a2 = update2, { id: id2 } = _a2, walletUpdate = __objRest(_a2, ["id"]);
      const updatedWallets = state2.wallets.map((wallet2) => wallet2.label === id2 ? __spreadValues(__spreadValues({}, wallet2), walletUpdate) : wallet2);
      return __spreadProps(__spreadValues({}, state2), {
        wallets: updatedWallets
      });
    }
    case REMOVE_WALLET: {
      const update2 = payload;
      return __spreadProps(__spreadValues({}, state2), {
        wallets: state2.wallets.filter(({ label }) => label !== update2.id)
      });
    }
    case UPDATE_ACCOUNT: {
      const update2 = payload;
      const _b = update2, { id: id2, address } = _b, accountUpdate = __objRest(_b, ["id", "address"]);
      const updatedWallets = state2.wallets.map((wallet2) => {
        if (wallet2.label === id2) {
          wallet2.accounts = wallet2.accounts.map((account2) => {
            if (account2.address === address) {
              return __spreadValues(__spreadValues({}, account2), accountUpdate);
            }
            return account2;
          });
        }
        return wallet2;
      });
      return __spreadProps(__spreadValues({}, state2), {
        wallets: updatedWallets
      });
    }
    case SET_WALLET_MODULES: {
      return __spreadProps(__spreadValues({}, state2), {
        walletModules: payload
      });
    }
    case RESET_STORE:
      return APP_INITIAL_STATE;
    default:
      throw new Error(`Unknown type: ${type} in appStore reducer`);
  }
}
var _store = new BehaviorSubject(APP_INITIAL_STATE);
var _stateUpdates = new Subject();
_stateUpdates.subscribe(_store);
function dispatch$1(action) {
  const state2 = _store.getValue();
  _stateUpdates.next(reducer(state2, action));
}
function select(stateKey) {
  if (!stateKey)
    return _stateUpdates.asObservable();
  const validStateKeys = Object.keys(_store.getValue());
  if (!validStateKeys.includes(String(stateKey))) {
    throw new Error(`key: ${stateKey} does not exist on this store`);
  }
  return _stateUpdates.asObservable().pipe(distinctUntilKeyChanged(stateKey), pluck(stateKey), filter(notNullish));
}
function get() {
  return _store.getValue();
}
var state = {
  select,
  get
};
function noop3() {
}
var identity2 = (x2) => x2;
function assign(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return tar;
}
function is_promise(value) {
  return value && typeof value === "object" && typeof value.then === "function";
}
function run2(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all2(fns) {
  fns.forEach(run2);
}
function is_function2(thing) {
  return typeof thing === "function";
}
function safe_not_equal2(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty2(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe2(store, ...callbacks) {
  if (store == null) {
    return noop3;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe2(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
var is_client = typeof window !== "undefined";
var now2 = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop3;
var tasks2 = new Set();
function run_tasks(now3) {
  tasks2.forEach((task) => {
    if (!task.c(now3)) {
      tasks2.delete(task);
      task.f();
    }
  });
  if (tasks2.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks2.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks2.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks2.delete(task);
    }
  };
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name2) {
  return document.createElement(name2);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty2() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name2, toggle) {
  element2.classList[toggle ? "add" : "remove"](name2);
}
function custom_event(type, detail, bubbles = false) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, false, detail);
  return e;
}
var HtmlTag = class {
  constructor() {
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      this.e = element(target.nodeName);
      this.t = target;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.childNodes);
  }
  i(anchor) {
    for (let i2 = 0; i2 < this.n.length; i2 += 1) {
      insert(this.t, this.n[i2], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
};
var managed_styles2 = new Map();
var active = 0;
function hash(str) {
  let hash2 = 5381;
  let i2 = str.length;
  while (i2--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i2);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles2.set(doc, info);
  return info;
}
function create_rule(node, a2, b2, duration, delay2, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p2 = 0; p2 <= 1; p2 += step) {
    const t2 = a2 + (b2 - a2) * ease(p2);
    keyframes += p2 * 100 + `%{${fn(t2, 1 - t2)}}
`;
  }
  const rule = keyframes + `100% {${fn(b2, 1 - b2)}}
}`;
  const name2 = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles2.get(doc) || create_style_information(doc, node);
  if (!rules[name2]) {
    rules[name2] = true;
    stylesheet.insertRule(`@keyframes ${name2} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name2} ${duration}ms linear ${delay2}ms 1 both`;
  active += 1;
  return name2;
}
function delete_rule(node, name2) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(name2 ? (anim) => anim.indexOf(name2) < 0 : (anim) => anim.indexOf("__svelte") === -1);
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles2.forEach((info) => {
      const { stylesheet } = info;
      let i2 = stylesheet.cssRules.length;
      while (i2--)
        stylesheet.deleteRule(i2);
      info.rules = {};
    });
    managed_styles2.clear();
  });
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function beforeUpdate(fn) {
  get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise2 = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise2.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks2 = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks2.has(callback)) {
        seen_callbacks2.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks2.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all2($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing2 = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all2(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing2.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing2.has(block))
      return;
    outroing2.add(block);
    outros.c.push(() => {
      outroing2.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
var null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  let config2 = fn(node, params);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const { delay: delay2 = 0, duration = 300, easing = identity2, tick = noop3, css } = config2 || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay2, easing, css, uid++);
    tick(0, 1);
    const start_time = now2() + delay2;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now3) => {
      if (running) {
        if (now3 >= end_time) {
          tick(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now3 >= start_time) {
          const t2 = easing((now3 - start_time) / duration);
          tick(t2, 1 - t2);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function2(config2)) {
        config2 = config2();
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_bidirectional_transition(node, fn, params, intro) {
  let config2 = fn(node, params);
  let t2 = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d2 = program.b - t2;
    duration *= Math.abs(d2);
    return {
      a: t2,
      b: program.b,
      d: d2,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b2) {
    const { delay: delay2 = 0, duration = 300, easing = identity2, tick = noop3, css } = config2 || null_transition;
    const program = {
      start: now2() + delay2,
      b: b2
    };
    if (!b2) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t2, b2, duration, delay2, easing, css);
      }
      if (b2)
        tick(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b2, "start"));
      loop((now3) => {
        if (pending_program && now3 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t2, running_program.b, running_program.duration, 0, easing, config2.css);
          }
        }
        if (running_program) {
          if (now3 >= running_program.end) {
            tick(t2 = running_program.b, 1 - t2);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all2(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now3 >= running_program.start) {
            const p2 = now3 - running_program.start;
            t2 = running_program.a + running_program.d * easing(p2 / running_program.duration);
            tick(t2, 1 - t2);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b2) {
      if (is_function2(config2)) {
        wait().then(() => {
          config2 = config2();
          go(b2);
        });
      } else {
        go(b2);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function handle_promise(promise2, info) {
  const token = info.token = {};
  function update2(type, index, key, value) {
    if (info.token !== token)
      return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i2) => {
          if (i2 !== index && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i2] === block2) {
                info.blocks[i2] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks)
      info.blocks[index] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise2)) {
    const current_component2 = get_current_component();
    promise2.then((value) => {
      set_current_component(current_component2);
      update2(info.then, 1, info.value, value);
      set_current_component(null);
    }, (error) => {
      set_current_component(current_component2);
      update2(info.catch, 2, info.error, error);
      set_current_component(null);
      if (!info.hasCatch) {
        throw error;
      }
    });
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise2);
      return true;
    }
    info.resolved = promise2;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved: resolved2 } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved2;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved2;
  }
  info.block.p(child_ctx, dirty);
}
function bind2(component, name2, callback) {
  const index = component.$$.props[name2];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run2).filter(is_function2);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all2(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component2(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all2($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init$1(component, options, instance2, create_fragment2, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop3,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all2($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    flush();
  }
  set_current_component(parent_component);
}
var SvelteComponent = class {
  $destroy() {
    destroy_component2(this, 1);
    this.$destroy = noop3;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty2($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};
var chainId = import_joi.default.string().pattern(/^0x[0-9a-fA-F]+$/);
var chainNamespace = import_joi.default.string().valid("evm");
var unknownObject = import_joi.default.object().unknown();
var chain = import_joi.default.object({
  namespace: chainNamespace,
  id: chainId.required(),
  rpcUrl: import_joi.default.string().required(),
  label: import_joi.default.string().required(),
  token: import_joi.default.string().required()
});
var connectedChain = import_joi.default.object({
  namespace: chainNamespace.required(),
  id: chainId.required()
});
var ens = import_joi.default.any().allow(import_joi.default.object({
  name: import_joi.default.string().required(),
  avatar: import_joi.default.string(),
  contentHash: import_joi.default.any().allow(import_joi.default.string(), null),
  getText: import_joi.default.function().arity(1).required()
}), null);
var balance = import_joi.default.any().allow(import_joi.default.object({
  eth: import_joi.default.number()
}).unknown(), null);
var account = {
  address: import_joi.default.string().required(),
  ens,
  balance
};
var chains = import_joi.default.array().items(chain);
var accounts = import_joi.default.array().items(account);
var wallet = import_joi.default.object({
  label: import_joi.default.string(),
  icon: import_joi.default.string(),
  provider: unknownObject,
  instance: unknownObject,
  accounts,
  chains: import_joi.default.array().items(connectedChain)
});
var recommendedWallet = import_joi.default.object({
  name: import_joi.default.string().required(),
  url: import_joi.default.string().uri().required()
});
var agreement = import_joi.default.object({
  version: import_joi.default.string().required(),
  termsUrl: import_joi.default.string().uri(),
  privacyUrl: import_joi.default.string().uri()
});
var appMetadata = import_joi.default.object({
  name: import_joi.default.string().required(),
  description: import_joi.default.string().required(),
  icon: import_joi.default.string().required(),
  logo: import_joi.default.string(),
  gettingStartedGuide: import_joi.default.string(),
  email: import_joi.default.string(),
  appUrl: import_joi.default.string(),
  explore: import_joi.default.string(),
  recommendedInjectedWallets: import_joi.default.array().items(recommendedWallet),
  agreement
});
import_joi.default.object({
  label: import_joi.default.string().required(),
  getInfo: import_joi.default.function().arity(1).required(),
  getInterface: import_joi.default.function().arity(1).required()
});
var walletInit = import_joi.default.array().items(import_joi.default.function()).required();
var initOptions = import_joi.default.object({
  wallets: walletInit,
  chains: chains.required(),
  appMetadata,
  i18n: import_joi.default.object().unknown()
});
var connectOptions = import_joi.default.object({
  autoSelect: [
    import_joi.default.object({
      label: import_joi.default.string().required(),
      disableModals: import_joi.default.boolean()
    }),
    import_joi.default.string()
  ]
});
var disconnectOptions = import_joi.default.object({
  label: import_joi.default.string().required()
}).required();
var setChainOptions = import_joi.default.object({
  chainId: chainId.required(),
  wallet: import_joi.default.string()
});
function validate(validator, data) {
  const result = validator.validate(data);
  return result.error ? result : null;
}
function validateWallet(data) {
  return validate(wallet, data);
}
function validateInitOptions(data) {
  return validate(initOptions, data);
}
function validateConnectOptions(data) {
  return validate(connectOptions, data);
}
function validateDisconnectOptions(data) {
  return validate(disconnectOptions, data);
}
function validateString(str) {
  return validate(import_joi.default.string().required(), str);
}
function validateSetChainOptions(data) {
  return validate(setChainOptions, data);
}
function validateWalletInit(data) {
  return validate(walletInit, data);
}
function addChains(chains2) {
  const action = {
    type: ADD_CHAINS,
    payload: chains2.map((_a2) => {
      var _b = _a2, { namespace = "evm" } = _b, rest = __objRest(_b, ["namespace"]);
      return __spreadProps(__spreadValues({}, rest), {
        namespace
      });
    })
  };
  dispatch$1(action);
}
function addWallet(wallet2) {
  const error = validateWallet(wallet2);
  if (error) {
    console.error(error);
    throw error;
  }
  const action = {
    type: ADD_WALLET,
    payload: wallet2
  };
  dispatch$1(action);
}
function updateWallet(id2, update2) {
  const error = validateWallet(update2);
  if (error) {
    console.error(error);
    throw error;
  }
  const action = {
    type: UPDATE_WALLET,
    payload: __spreadValues({
      id: id2
    }, update2)
  };
  dispatch$1(action);
}
function removeWallet(id2) {
  const error = validateString(id2);
  if (error) {
    throw error;
  }
  const action = {
    type: REMOVE_WALLET,
    payload: {
      id: id2
    }
  };
  dispatch$1(action);
}
function updateAccount(id2, address, update2) {
  const action = {
    type: UPDATE_ACCOUNT,
    payload: __spreadValues({
      id: id2,
      address
    }, update2)
  };
  dispatch$1(action);
}
function resetStore() {
  const action = {
    type: RESET_STORE
  };
  dispatch$1(action);
}
function setWalletModules(wallets) {
  const error = validateWalletInit(wallets);
  if (error) {
    throw error;
  }
  const modules = initializeWalletModules(wallets, internalState$.getValue().device);
  const action = {
    type: SET_WALLET_MODULES,
    payload: modules
  };
  dispatch$1(action);
}
var reset$ = new Subject();
var disconnectWallet$ = new Subject();
var internalState$ = new BehaviorSubject({
  svelteInstance: null,
  appMetadata: null,
  device: null
});
var connectWallet$ = new BehaviorSubject({ inProgress: false, actionRequired: "" });
var switchChainModal$ = new BehaviorSubject(null);
var wallets$ = state.select("wallets").pipe(shareReplay(1));
reset$.pipe(withLatestFrom(wallets$), pluck("1")).subscribe((wallets) => {
  wallets.forEach(({ label }) => {
    disconnectWallet$.next(label);
  });
  resetStore();
});
defer(() => {
  const subject = new Subject();
  onMount(() => {
    subject.next();
  });
  return subject.asObservable().pipe(take(1));
});
var onDestroy$ = defer(() => {
  const subject = new Subject();
  onDestroy(() => {
    subject.next();
  });
  return subject.asObservable().pipe(take(1));
});
defer(() => {
  const subject = new Subject();
  afterUpdate(() => {
    subject.next();
  });
  return subject.asObservable().pipe(takeUntil(onDestroy$));
});
defer(() => {
  const subject = new Subject();
  beforeUpdate(() => {
    subject.next();
  });
  return subject.asObservable().pipe(takeUntil(onDestroy$));
});
async function connect$1(options) {
  if (options) {
    const error = validateConnectOptions(options);
    if (error) {
      throw error;
    }
  }
  const { chains: chains2 } = state.get();
  if (!chains2.length)
    throw new Error("At least one chain must be set before attempting to connect a wallet");
  const { autoSelect } = options || {
    autoSelect: { label: "", disableModals: false }
  };
  connectWallet$.next({
    autoSelect: typeof autoSelect === "string" ? { label: autoSelect, disableModals: false } : autoSelect,
    inProgress: true
  });
  const result$ = connectWallet$.pipe(filter(({ inProgress, actionRequired }) => inProgress === false && !actionRequired), withLatestFrom(wallets$), pluck(1));
  return firstValueFrom(result$);
}
async function disconnect(options) {
  const error = validateDisconnectOptions(options);
  if (error) {
    throw error;
  }
  const { label } = options;
  disconnectWallet$.next(label);
  removeWallet(label);
  return state.get().wallets;
}
var ethersProviders = {};
function requestAccounts(provider) {
  const args = { method: "eth_requestAccounts" };
  return provider.request(args);
}
function selectAccounts(provider) {
  const args = { method: "eth_selectAccounts" };
  return provider.request(args);
}
function getChainId(provider) {
  return provider.request({ method: "eth_chainId" });
}
function listenAccountsChanged(args) {
  const { provider, disconnected$ } = args;
  const addHandler = (handler) => {
    provider.on("accountsChanged", handler);
  };
  const removeHandler = (handler) => {
    provider.removeListener("accountsChanged", handler);
  };
  return fromEventPattern(addHandler, removeHandler).pipe(takeUntil(disconnected$));
}
function listenChainChanged(args) {
  const { provider, disconnected$ } = args;
  const addHandler = (handler) => {
    provider.on("chainChanged", handler);
  };
  const removeHandler = (handler) => {
    provider.removeListener("chainChanged", handler);
  };
  return fromEventPattern(addHandler, removeHandler).pipe(takeUntil(disconnected$));
}
function trackWallet(provider, label) {
  const disconnected$ = disconnectWallet$.pipe(filter((wallet2) => wallet2 === label), take(1));
  const accountsChanged$ = listenAccountsChanged({
    provider,
    disconnected$
  }).pipe(share());
  accountsChanged$.subscribe(([address]) => {
    if (!address) {
      disconnect({ label });
      return;
    }
    const { wallets } = state.get();
    const { accounts: accounts2 } = wallets.find((wallet2) => wallet2.label === label);
    const [[existingAccount], restAccounts] = (0, import_lodash.default)(accounts2, (account2) => account2.address === address);
    updateWallet(label, {
      accounts: [
        existingAccount || { address, ens: null, balance: null },
        ...restAccounts
      ]
    });
  });
  accountsChanged$.pipe(switchMap(async ([address]) => {
    if (!address)
      return;
    const { wallets, chains: chains2 } = state.get();
    const { chains: walletChains, accounts: accounts2 } = wallets.find((wallet2) => wallet2.label === label);
    const [connectedWalletChain] = walletChains;
    const chain2 = chains2.find(({ namespace, id: id2 }) => namespace === "evm" && id2 === connectedWalletChain.id);
    const balanceProm = getBalance(address, chain2);
    const account2 = accounts2.find((account3) => account3.address === address);
    const ensProm = account2.ens ? Promise.resolve(account2.ens) : validEnsChain(connectedWalletChain.id) ? getEns(address, chain2) : Promise.resolve(null);
    return Promise.all([Promise.resolve(address), balanceProm, ensProm]);
  })).subscribe((res) => {
    if (!res)
      return;
    const [address, balance2, ens2] = res;
    updateAccount(label, address, { balance: balance2, ens: ens2 });
  });
  const chainChanged$ = listenChainChanged({ provider, disconnected$ }).pipe(share());
  chainChanged$.subscribe((chainId2) => {
    const { wallets } = state.get();
    const { chains: chains2, accounts: accounts2 } = wallets.find((wallet2) => wallet2.label === label);
    const [connectedWalletChain] = chains2;
    if (chainId2 === connectedWalletChain.id)
      return;
    const resetAccounts = accounts2.map(({ address }) => ({
      address,
      ens: null,
      balance: null
    }));
    updateWallet(label, {
      chains: [{ namespace: "evm", id: chainId2 }],
      accounts: resetAccounts
    });
  });
  chainChanged$.pipe(switchMap(async (chainId2) => {
    const { wallets, chains: chains2 } = state.get();
    const { accounts: accounts2 } = wallets.find((wallet2) => wallet2.label === label);
    const chain2 = chains2.find(({ namespace, id: id2 }) => namespace === "evm" && id2 === chainId2);
    return Promise.all(accounts2.map(async ({ address }) => {
      const balanceProm = getBalance(address, chain2);
      const ensProm = validEnsChain(chainId2) ? getEns(address, chain2) : Promise.resolve(null);
      const [balance2, ens2] = await Promise.all([balanceProm, ensProm]);
      return {
        address,
        balance: balance2,
        ens: ens2
      };
    }));
  })).subscribe((updatedAccounts) => {
    updatedAccounts && updateWallet(label, { accounts: updatedAccounts });
  });
  disconnected$.subscribe(() => {
    provider.disconnect && provider.disconnect();
  });
}
async function getEns(address, chain2) {
  if (!chain2)
    return null;
  if (!ethersProviders[chain2.rpcUrl]) {
    ethersProviders[chain2.rpcUrl] = new lib_exports4.StaticJsonRpcProvider(chain2.rpcUrl);
  }
  const provider = ethersProviders[chain2.rpcUrl];
  try {
    const name2 = await provider.lookupAddress(address);
    let ens2 = null;
    if (name2) {
      const resolver = await provider.getResolver(name2);
      if (resolver) {
        const [contentHash, avatar] = await Promise.all([
          resolver.getContentHash(),
          resolver.getAvatar()
        ]);
        const getText = resolver.getText.bind(resolver);
        ens2 = {
          name: name2,
          avatar,
          contentHash,
          getText
        };
      }
    }
    return ens2;
  } catch (error) {
    console.error(error);
    return null;
  }
}
async function getBalance(address, chain2) {
  if (!chain2)
    return null;
  if (!ethersProviders[chain2.rpcUrl]) {
    ethersProviders[chain2.rpcUrl] = new lib_exports4.StaticJsonRpcProvider(chain2.rpcUrl);
  }
  const provider = ethersProviders[chain2.rpcUrl];
  try {
    const balanceWei = await provider.getBalance(address);
    return balanceWei ? { [chain2.token || "eth"]: utils_exports.formatEther(balanceWei) } : null;
  } catch (error) {
    console.error(error);
    return null;
  }
}
function switchChain(provider, chainId2) {
  return provider.request({
    method: "wallet_switchEthereumChain",
    params: [{ chainId: chainId2 }]
  });
}
function addNewChain(provider, chain2) {
  return provider.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: chain2.id,
        chainName: chain2.label,
        nativeCurrency: {
          name: chain2.label,
          symbol: chain2.token,
          decimals: 18
        },
        rpcUrls: [chain2.rpcUrl]
      }
    ]
  });
}
async function setChain(options) {
  const error = validateSetChainOptions(options);
  if (error) {
    throw error;
  }
  const { wallets, chains: chains2 } = state.get();
  const { chainId: chainId2, chainNamespace: chainNamespace2 = "evm", wallet: walletToSet } = options;
  const chain2 = chains2.find(({ namespace, id: id2 }) => namespace === chainNamespace2 && id2 === chainId2);
  if (!chain2) {
    throw new Error(`Chain with chainId: ${chainId2} and chainNamespace: ${chainNamespace2} has not been set and must be added when Onboard is initialized.`);
  }
  const wallet2 = walletToSet ? wallets.find(({ label }) => label === walletToSet) : wallets[0];
  if (!wallet2) {
    throw new Error(walletToSet ? `Wallet with label ${walletToSet} is not connected` : "A wallet must be connected before a chain can be set");
  }
  const [walletConnectedChain] = wallet2.chains;
  if (walletConnectedChain.namespace === chainNamespace2 && walletConnectedChain.id === chainId2) {
    return true;
  }
  try {
    await switchChain(wallet2.provider, chainId2);
    return true;
  } catch (error2) {
    const { code } = error2;
    const switchChainModalClosed$ = switchChainModal$.pipe(filter((x2) => x2 === null), mapTo(false));
    if (code === ProviderRpcErrorCode.CHAIN_NOT_ADDED) {
      try {
        await addNewChain(wallet2.provider, chain2);
        await switchChain(wallet2.provider, chainId2);
        return true;
      } catch (error3) {
        switchChainModal$.next({ chain: chain2 });
        return firstValueFrom(switchChainModalClosed$);
      }
    }
    if (code === ProviderRpcErrorCode.UNSUPPORTED_METHOD) {
      switchChainModal$.next({ chain: chain2 });
      return firstValueFrom(switchChainModalClosed$);
    }
  }
  return false;
}
var connect2 = {
  selectingWallet: {
    header: "Available Wallets",
    sidebar: {
      heading: "Get Started",
      subheading: "Connect your wallet",
      paragraph: "Connecting your wallet is like \u201Clogging in\u201D to Web3. Select your wallet from the options to get started."
    },
    recommendedWalletsPart1: "{app} only supports",
    recommendedWalletsPart2: "on this platform. Please use or install one of the supported wallets to continue",
    installWallet: "You do not have any wallets installed that {app} supports, please use a supported wallet",
    agreement: {
      agree: "I agree to the",
      terms: "Terms & Conditions",
      and: "and",
      privacy: "Privacy Policy"
    }
  },
  connectingWallet: {
    header: "{connectionRejected, select, false {Connecting to {wallet}...} other {Connection Rejected}}",
    sidebar: {
      subheading: "Approve Connection",
      paragraph: "Please approve the connection in your wallet and authorize access to continue."
    },
    mainText: "Connecting...",
    paragraph: "Make sure to select all accounts that you want to grant access to.",
    rejectedText: "Connection Rejected!",
    rejectedCTA: "Click here to try again",
    primaryButton: "Back to wallets"
  },
  connectedWallet: {
    header: "Connection Successful",
    sidebar: {
      subheading: "Connection Successful!",
      paragraph: "Your wallet is now connected to {app}"
    },
    mainText: "Connected"
  }
};
var modals = {
  actionRequired: {
    heading: "Action required in {wallet}",
    paragraph: "Please switch the active account in your wallet.",
    linkText: "Learn more.",
    buttonText: "Okay"
  },
  switchChain: {
    heading: "Switch Chain",
    paragraph1: "{app} requires that you switch your wallet to the {nextNetworkName} network to continue.",
    paragraph2: "*Some wallets may not support changing networks. If you can not change networks in your wallet you may consider switching to a different wallet."
  }
};
var en = {
  connect: connect2,
  modals
};
function initialize(options) {
  if (options) {
    const { en: customizedEn } = options;
    const merged = (0, import_lodash2.default)(en, customizedEn || {});
    m("en", merged);
    const customLocales = Object.keys(options).filter((key) => key !== "en");
    customLocales.forEach((locale) => {
      const dictionary = options[locale];
      dictionary && m(locale, dictionary);
    });
  } else {
    m("en", en);
  }
  $({
    fallbackLocale: "en",
    initialLocale: I()
  });
}
var closeIcon = `
  <svg width="100%" height="100%" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M11.6569 1.75736L7.41429 6L11.6569 10.2426L10.2427 11.6569L6.00008 7.41421L1.75744 11.6569L0.343227 10.2426L4.58587 6L0.343227 1.75736L1.75744 0.343146L6.00008 4.58579L10.2427 0.343146L11.6569 1.75736Z" fill="currentColor"/>
  </svg>
`;
function add_css$h(target) {
  append_styles(target, "svelte-fio0ht", ".close-button-container.svelte-fio0ht{cursor:pointer;display:flex;justify-content:center;align-items:center}.close-button.svelte-fio0ht{width:2rem;height:2rem;box-sizing:border-box;display:flex;justify-content:center;align-items:center;padding:0.4rem;background:var(\n      --onboard-close-button-background,\n      var(--onboard-gray-100, var(--gray-100))\n    );border-radius:40px;color:var(\n      --onboard-close-button-color,\n      var(--onboard-gray-400, var(--gray-400))\n    )}.close-icon.svelte-fio0ht{width:14px;display:flex;align-items:center}");
}
function create_fragment$h(ctx) {
  let div2;
  let div1;
  let div0;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "close-icon svelte-fio0ht");
      attr(div1, "class", "close-button svelte-fio0ht");
      attr(div2, "class", "close-button-container svelte-fio0ht");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      div0.innerHTML = closeIcon;
    },
    p: noop3,
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
var CloseButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, null, create_fragment$h, safe_not_equal2, {}, add_css$h);
  }
};
function fade(node, { delay: delay2 = 0, duration = 400, easing = identity2 } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay: delay2,
    duration,
    easing,
    css: (t2) => `opacity: ${t2 * o}`
  };
}
function add_css$g(target) {
  append_styles(target, "svelte-lkspmm", "section.svelte-lkspmm{position:absolute;top:0;left:0;pointer-events:none;z-index:var(--onboard-modal-z-index, var(--modal-z-index))}.background.svelte-lkspmm{width:100vw;height:100vh;display:flex;justify-content:center;align-items:center;background:rgba(0, 0, 0, 0.6);pointer-events:all}.relative.svelte-lkspmm{position:relative;display:flex;max-height:calc(100vh - 2rem)}.modal-overflow.svelte-lkspmm{position:relative;overflow:hidden;border-radius:24px;display:flex;justify-content:center}.modal.svelte-lkspmm{position:relative;border-radius:24px;overflow-y:auto;background:white}@media all and (max-width: 520px){.relative.svelte-lkspmm{width:calc(100% - 1rem)}.modal-overflow.svelte-lkspmm{width:100%}.modal.svelte-lkspmm{width:100%}}");
}
function create_fragment$g(ctx) {
  let section;
  let div3;
  let div2;
  let div1;
  let div0;
  let section_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      section = element("section");
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "modal svelte-lkspmm");
      attr(div1, "class", "modal-overflow svelte-lkspmm");
      attr(div2, "class", "relative svelte-lkspmm");
      attr(div3, "class", "background svelte-lkspmm");
      attr(section, "class", "svelte-lkspmm");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div3);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div2, "click", stop_propagation(ctx[3])),
          listen(div3, "click", function() {
            if (is_function2(ctx[0]))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx, ctx[1], !current ? get_all_dirty_from_scope(ctx[1]) : get_slot_changes(default_slot_template, ctx[1], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!section_transition)
          section_transition = create_bidirectional_transition(section, fade, {}, true);
        section_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (!section_transition)
        section_transition = create_bidirectional_transition(section, fade, {}, false);
      section_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && section_transition)
        section_transition.end();
      mounted = false;
      run_all2(dispose);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { close } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("close" in $$props2)
      $$invalidate(0, close = $$props2.close);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [close, $$scope, slots, click_handler];
}
var Modal = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$g, create_fragment$g, safe_not_equal2, { close: 0 }, add_css$g);
  }
};
function add_css$f(target) {
  append_styles(target, "svelte-1y8va6v", ".container.svelte-1y8va6v{display:flex;align-items:center;padding:var(--onboard-spacing-4, var(--spacing-4));font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:24px}label.svelte-1y8va6v{display:flex;align-items:center}input.svelte-1y8va6v{height:1rem;width:1rem;margin-right:0.5rem}.spacer.svelte-1y8va6v{padding-top:var(--onboard-spacing-4, var(--spacing-4))}");
}
function create_else_block$4(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "spacer svelte-1y8va6v");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop3,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$9(ctx) {
  let div;
  let label;
  let input;
  let t0;
  let span;
  let t1_value = ctx[1]("connect.selectingWallet.agreement.agree") + "";
  let t1;
  let t2;
  let t3_value = " ";
  let t3;
  let t4;
  let t5;
  let mounted;
  let dispose;
  let if_block0 = ctx[2] && create_if_block_2$3(ctx);
  let if_block1 = ctx[3] && create_if_block_1$4(ctx);
  return {
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      if (if_block1)
        if_block1.c();
      attr(input, "class", " svelte-1y8va6v");
      attr(input, "type", "checkbox");
      attr(label, "class", "svelte-1y8va6v");
      attr(div, "class", "container svelte-1y8va6v");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      input.checked = ctx[0];
      append(label, t0);
      append(label, span);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(span, t4);
      if (if_block0)
        if_block0.m(span, null);
      append(span, t5);
      if (if_block1)
        if_block1.m(span, null);
      if (!mounted) {
        dispose = listen(input, "change", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        input.checked = ctx2[0];
      }
      if (dirty & 2 && t1_value !== (t1_value = ctx2[1]("connect.selectingWallet.agreement.agree") + ""))
        set_data(t1, t1_value);
      if (ctx2[2])
        if_block0.p(ctx2, dirty);
      if (ctx2[3])
        if_block1.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$3(ctx) {
  let a2;
  let t0_value = ctx[1]("connect.selectingWallet.agreement.terms") + "";
  let t0;
  let t1_value = (ctx[3] ? " " + ctx[1]("connect.selectingWallet.agreement.and") + " " : ".") + "";
  let t1;
  return {
    c() {
      a2 = element("a");
      t0 = text(t0_value);
      t1 = text(t1_value);
      attr(a2, "href", ctx[2]);
      attr(a2, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      append(a2, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1]("connect.selectingWallet.agreement.terms") + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t1_value !== (t1_value = (ctx2[3] ? " " + ctx2[1]("connect.selectingWallet.agreement.and") + " " : ".") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(a2);
      if (detaching)
        detach(t1);
    }
  };
}
function create_if_block_1$4(ctx) {
  let a2;
  let t0_value = ctx[1]("connect.selectingWallet.agreement.privacy") + "";
  let t0;
  let t1;
  return {
    c() {
      a2 = element("a");
      t0 = text(t0_value);
      t1 = text(".");
      attr(a2, "href", ctx[3]);
      attr(a2, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      append(a2, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1]("connect.selectingWallet.agreement.privacy") + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(a2);
      if (detaching)
        detach(t1);
    }
  };
}
function create_fragment$f(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block$9;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: noop3,
    o: noop3,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(1, $_ = $$value));
  let { agreed } = $$props;
  const { terms: termsAgreed, privacy: privacyAgreed, version: versionAgreed } = JSON.parse(localStorage.getItem(STORAGE_KEYS.TERMS_AGREEMENT) || "{}");
  const blankAgreement = {
    termsUrl: "",
    privacyUrl: "",
    version: ""
  };
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  const { termsUrl, privacyUrl, version: version3 } = appMetadata2 && appMetadata2.agreement || blankAgreement;
  const showTermsOfService = !!(termsUrl && !termsAgreed || privacyUrl && !privacyAgreed || version3 && version3 !== versionAgreed);
  agreed = !showTermsOfService;
  function input_change_handler() {
    agreed = this.checked;
    $$invalidate(0, agreed);
  }
  $$self.$$set = ($$props2) => {
    if ("agreed" in $$props2)
      $$invalidate(0, agreed = $$props2.agreed);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (agreed) {
        localStorage.setItem(STORAGE_KEYS.TERMS_AGREEMENT, JSON.stringify({
          version: version3,
          terms: !!termsUrl,
          privacy: !!privacyUrl
        }));
      } else if (agreed === false) {
        localStorage.removeItem(STORAGE_KEYS.TERMS_AGREEMENT);
      }
    }
  };
  return [agreed, $_, termsUrl, privacyUrl, showTermsOfService, input_change_handler];
}
var Agreement = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$f, create_fragment$f, safe_not_equal2, { agreed: 0 }, add_css$f);
  }
};
var success = `
  <svg width="100%" height="100%" viewBox="0 0 10 8" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M3.5002 6.0998L1.4002 3.9998L0.700195 4.6998L3.5002 7.4998L9.5002 1.4998L8.8002 0.799805L3.5002 6.0998Z" fill="currentColor"/>
  </svg>
`;
function add_css$e(target) {
  append_styles(target, "svelte-1nnukeb", ".loading-container.svelte-1nnukeb.svelte-1nnukeb{display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:inherit;font-size:inherit;color:inherit}span.svelte-1nnukeb.svelte-1nnukeb{font-family:inherit;font-size:0.889em;margin-top:1rem}.loading.svelte-1nnukeb.svelte-1nnukeb{display:inline-block;position:relative}.loading.svelte-1nnukeb div.svelte-1nnukeb{box-sizing:border-box;font-size:inherit;display:block;position:absolute;border:3px solid;border-radius:50%;animation:svelte-1nnukeb-bn-loading 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;border-color:currentColor transparent transparent transparent}.loading.svelte-1nnukeb .loading-first.svelte-1nnukeb{animation-delay:-0.45s}.loading.svelte-1nnukeb .loading-second.svelte-1nnukeb{animation-delay:-0.3s}.loading.svelte-1nnukeb .loading-third.svelte-1nnukeb{animation-delay:-0.15s}@keyframes svelte-1nnukeb-bn-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}");
}
function create_if_block$8(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(ctx[0]);
      attr(span, "class", "svelte-1nnukeb");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t2, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$e(ctx) {
  let div4;
  let div3;
  let div0;
  let div0_style_value;
  let t0;
  let div1;
  let div1_style_value;
  let t1;
  let div2;
  let div2_style_value;
  let div3_style_value;
  let t2;
  let if_block = ctx[0] && create_if_block$8(ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "loading-first svelte-1nnukeb");
      attr(div0, "style", div0_style_value = `height: ${ctx[1]}; width: ${ctx[1]};`);
      attr(div1, "class", "loading-second svelte-1nnukeb");
      attr(div1, "style", div1_style_value = `height: ${ctx[1]}; width: ${ctx[1]};`);
      attr(div2, "class", "loading-third svelte-1nnukeb");
      attr(div2, "style", div2_style_value = `height: ${ctx[1]}; width: ${ctx[1]};`);
      attr(div3, "class", "loading svelte-1nnukeb");
      attr(div3, "style", div3_style_value = `height: ${ctx[1]}; width: ${ctx[1]};`);
      attr(div4, "class", "loading-container absolute svelte-1nnukeb");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      append(div3, t0);
      append(div3, div1);
      append(div3, t1);
      append(div3, div2);
      append(div4, t2);
      if (if_block)
        if_block.m(div4, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && div0_style_value !== (div0_style_value = `height: ${ctx2[1]}; width: ${ctx2[1]};`)) {
        attr(div0, "style", div0_style_value);
      }
      if (dirty & 2 && div1_style_value !== (div1_style_value = `height: ${ctx2[1]}; width: ${ctx2[1]};`)) {
        attr(div1, "style", div1_style_value);
      }
      if (dirty & 2 && div2_style_value !== (div2_style_value = `height: ${ctx2[1]}; width: ${ctx2[1]};`)) {
        attr(div2, "style", div2_style_value);
      }
      if (dirty & 2 && div3_style_value !== (div3_style_value = `height: ${ctx2[1]}; width: ${ctx2[1]};`)) {
        attr(div3, "style", div3_style_value);
      }
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          if_block.m(div4, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let { description = "" } = $$props;
  let { size = "2rem" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("description" in $$props2)
      $$invalidate(0, description = $$props2.description);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
  };
  return [description, size];
}
var Spinner = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$e, create_fragment$e, safe_not_equal2, { description: 0, size: 1 }, add_css$e);
  }
};
function add_css$d(target) {
  append_styles(target, "svelte-1rtrnn2", ".icon-container.svelte-1rtrnn2{position:relative;border-radius:12px;box-sizing:border-box}.icon.svelte-1rtrnn2{display:flex;justify-content:center;align-items:center;height:100%}.border-yellow.svelte-1rtrnn2{border:1px solid var(--onboard-warning-500, var(--warning-500))}.border-gray.svelte-1rtrnn2{border:1px solid var(--onboard-gray-300, var(--gray-300))}.border-green.svelte-1rtrnn2{border:1px solid var(--onboard-success-500, var(--success-500))}.border-dark-green.svelte-1rtrnn2{border:1px solid var(--onboard-success-700, var(--success-700))}.border-blue.svelte-1rtrnn2{border:1px solid\n      var(\n        --onboard-wallet-app-icon-border-color,\n        var(--onboard-primary-300, var(--primary-300))\n      )}.border-dark-blue.svelte-1rtrnn2{border:1px solid\n      var(\n        --onboard-wallet-app-icon-border-color,\n        var(--onboard-primary-600, var(--primary-600))\n      )}.background-gray.svelte-1rtrnn2{background:var(--onboard-gray-500, var(--gray-500))}.background-light-gray.svelte-1rtrnn2{background:var(--onboard-gray-100, var(--gray-100))}.background-light-blue.svelte-1rtrnn2{background:var(--onboard-primary-100, var(--primary-100))}.background-green.svelte-1rtrnn2{background:var(--onboard-success-100, var(--success-100))}.background-white.svelte-1rtrnn2{background:var(--onboard-white, var(--white))}.background-transparent.svelte-1rtrnn2{background:transparent}@keyframes svelte-1rtrnn2-pulse{from{opacity:0}to{opacity:1}}.placeholder-icon.svelte-1rtrnn2{width:100%;height:100%;background:var(--onboard-gray-100, var(--gray-100));border-radius:32px;animation:svelte-1rtrnn2-pulse infinite 750ms alternate ease-in-out}.spinner-container.svelte-1rtrnn2{color:var(--onboard-primary-300, var(--primary-300))}img.svelte-1rtrnn2{max-width:100%;height:auto}");
}
var get_status_slot_changes = (dirty) => ({});
var get_status_slot_context = (ctx) => ({});
function create_else_block$3(ctx) {
  let await_block_anchor;
  let promise2;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 10
  };
  handle_promise(promise2 = ctx[1], info);
  return {
    c() {
      await_block_anchor = empty2();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 2 && promise2 !== (promise2 = ctx[1]) && handle_promise(promise2, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      transition_in(info.block);
    },
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block$7(ctx) {
  let div;
  let spinner;
  let current;
  spinner = new Spinner({ props: { size: "2rem" } });
  return {
    c() {
      div = element("div");
      create_component(spinner.$$.fragment);
      attr(div, "class", "spinner-container svelte-1rtrnn2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner, div, null);
      current = true;
    },
    p: noop3,
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component2(spinner);
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop3,
    m: noop3,
    p: noop3,
    i: noop3,
    o: noop3,
    d: noop3
  };
}
function create_then_block(ctx) {
  let div;
  let show_if;
  let div_intro;
  function select_block_type_1(ctx2, dirty) {
    if (dirty & 2)
      show_if = null;
    if (show_if == null)
      show_if = !!isSVG(ctx2[10]);
    if (show_if)
      return create_if_block_1$3;
    return create_else_block_1$1;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "icon svelte-1rtrnn2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    i(local) {
      if (!div_intro) {
        add_render_callback(() => {
          div_intro = create_in_transition(div, fade, {});
          div_intro.start();
        });
      }
    },
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_else_block_1$1(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = ctx[10]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "logo");
      attr(img, "class", "svelte-1rtrnn2");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && !src_url_equal(img.src, img_src_value = ctx2[10])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_1$3(ctx) {
  let html_tag;
  let raw_value = ctx[10] + "";
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag();
      html_anchor = empty2();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && raw_value !== (raw_value = ctx2[10] + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_pending_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "placeholder-icon svelte-1rtrnn2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop3,
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$d(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t2;
  let div_style_value;
  let current;
  const if_block_creators = [create_if_block$7, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const status_slot_template = ctx[9].status;
  const status_slot = create_slot(status_slot_template, ctx, ctx[8], get_status_slot_context);
  return {
    c() {
      div = element("div");
      if_block.c();
      t2 = space();
      if (status_slot)
        status_slot.c();
      attr(div, "class", "icon-container svelte-1rtrnn2");
      attr(div, "style", div_style_value = `${ctx[5] === "custom" ? ctx[6] : ""}; padding: ${ctx[3] - 1}px; width: ${ctx[0]}px; height: ${ctx[0]}px;`);
      toggle_class(div, "opaque", ctx[7]);
      toggle_class(div, "border-yellow", ctx[4] === "yellow");
      toggle_class(div, "border-gray", ctx[4] === "gray");
      toggle_class(div, "border-green", ctx[4] === "green");
      toggle_class(div, "border-dark-green", ctx[4] === "darkGreen");
      toggle_class(div, "border-blue", ctx[4] === "blue");
      toggle_class(div, "border-dark-blue", ctx[4] === "darkBlue");
      toggle_class(div, "background-gray", ctx[5] === "gray");
      toggle_class(div, "background-light-gray", ctx[5] === "lightGray");
      toggle_class(div, "background-light-blue", ctx[5] === "lightBlue");
      toggle_class(div, "background-green", ctx[5] === "green");
      toggle_class(div, "background-white", ctx[5] === "white");
      toggle_class(div, "background-transparent", ctx[5] === "transparent");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t2);
      if (status_slot) {
        status_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t2);
      }
      if (status_slot) {
        if (status_slot.p && (!current || dirty & 256)) {
          update_slot_base(status_slot, status_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(status_slot_template, ctx2[8], dirty, get_status_slot_changes), get_status_slot_context);
        }
      }
      if (!current || dirty & 105 && div_style_value !== (div_style_value = `${ctx2[5] === "custom" ? ctx2[6] : ""}; padding: ${ctx2[3] - 1}px; width: ${ctx2[0]}px; height: ${ctx2[0]}px;`)) {
        attr(div, "style", div_style_value);
      }
      if (dirty & 128) {
        toggle_class(div, "opaque", ctx2[7]);
      }
      if (dirty & 16) {
        toggle_class(div, "border-yellow", ctx2[4] === "yellow");
      }
      if (dirty & 16) {
        toggle_class(div, "border-gray", ctx2[4] === "gray");
      }
      if (dirty & 16) {
        toggle_class(div, "border-green", ctx2[4] === "green");
      }
      if (dirty & 16) {
        toggle_class(div, "border-dark-green", ctx2[4] === "darkGreen");
      }
      if (dirty & 16) {
        toggle_class(div, "border-blue", ctx2[4] === "blue");
      }
      if (dirty & 16) {
        toggle_class(div, "border-dark-blue", ctx2[4] === "darkBlue");
      }
      if (dirty & 32) {
        toggle_class(div, "background-gray", ctx2[5] === "gray");
      }
      if (dirty & 32) {
        toggle_class(div, "background-light-gray", ctx2[5] === "lightGray");
      }
      if (dirty & 32) {
        toggle_class(div, "background-light-blue", ctx2[5] === "lightBlue");
      }
      if (dirty & 32) {
        toggle_class(div, "background-green", ctx2[5] === "green");
      }
      if (dirty & 32) {
        toggle_class(div, "background-white", ctx2[5] === "white");
      }
      if (dirty & 32) {
        toggle_class(div, "background-transparent", ctx2[5] === "transparent");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(status_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(status_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (status_slot)
        status_slot.d(detaching);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { size } = $$props;
  let { icon } = $$props;
  let { loading = false } = $$props;
  let { padding = size / 6 } = $$props;
  let { border = "blue" } = $$props;
  let { background = "white" } = $$props;
  let { customBackgroundColor = "" } = $$props;
  let { backgroundOpaque = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("loading" in $$props2)
      $$invalidate(2, loading = $$props2.loading);
    if ("padding" in $$props2)
      $$invalidate(3, padding = $$props2.padding);
    if ("border" in $$props2)
      $$invalidate(4, border = $$props2.border);
    if ("background" in $$props2)
      $$invalidate(5, background = $$props2.background);
    if ("customBackgroundColor" in $$props2)
      $$invalidate(6, customBackgroundColor = $$props2.customBackgroundColor);
    if ("backgroundOpaque" in $$props2)
      $$invalidate(7, backgroundOpaque = $$props2.backgroundOpaque);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [
    size,
    icon,
    loading,
    padding,
    border,
    background,
    customBackgroundColor,
    backgroundOpaque,
    $$scope,
    slots
  ];
}
var WalletAppBadge = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$d, create_fragment$d, safe_not_equal2, {
      size: 0,
      icon: 1,
      loading: 2,
      padding: 3,
      border: 4,
      background: 5,
      customBackgroundColor: 6,
      backgroundOpaque: 7
    }, add_css$d);
  }
};
var defaultAppIcon = `
<svg height="80%" viewBox="0 0 12 19" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.07004 9.85C5.84004 8.46 7.32004 7.64 8.18004 6.41C9.09004 5.12 8.58004 2.71 6.00004 2.71C4.31004 2.71 3.48004 3.99 3.13004 5.05L0.540039 3.96C1.25004 1.83 3.18004 0 5.99004 0C8.34004 0 9.95004 1.07 10.77 2.41C11.47 3.56 11.88 5.71 10.8 7.31C9.60004 9.08 8.45004 9.62 7.83004 10.76C7.58004 11.22 7.48004 11.52 7.48004 13H4.59004C4.58004 12.22 4.46004 10.95 5.07004 9.85ZM8.00004 17C8.00004 18.1 7.10004 19 6.00004 19C4.90004 19 4.00004 18.1 4.00004 17C4.00004 15.9 4.90004 15 6.00004 15C7.10004 15 8.00004 15.9 8.00004 17Z" fill="#999CA5"/>
</svg>
`;
function add_css$c(target) {
  append_styles(target, "svelte-sv0as5", ".icon.svelte-sv0as5{display:flex;color:var(--onboard-white, var(--white));border-radius:50px;box-sizing:border-box;position:absolute;z-index:1}.green.svelte-sv0as5{background:var(--onboard-success-600, var(--success-600))}.blue.svelte-sv0as5{background:var(--onboard-primary-1, var(--primary-1))}");
}
function create_fragment$c(ctx) {
  let div;
  let div_style_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", "icon svelte-sv0as5");
      attr(div, "style", div_style_value = `width: ${ctx[0]}px; height: ${ctx[0]}px; padding: ${ctx[0] / 5}px; ${ctx[2] !== null ? `bottom: ${ctx[2]}px;` : ""} ${ctx[3] !== null ? `right: ${ctx[3]}px;` : ""}`);
      toggle_class(div, "green", ctx[1] === "green");
      toggle_class(div, "blue", ctx[1] === "blue");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = success;
    },
    p(ctx2, [dirty]) {
      if (dirty & 13 && div_style_value !== (div_style_value = `width: ${ctx2[0]}px; height: ${ctx2[0]}px; padding: ${ctx2[0] / 5}px; ${ctx2[2] !== null ? `bottom: ${ctx2[2]}px;` : ""} ${ctx2[3] !== null ? `right: ${ctx2[3]}px;` : ""}`)) {
        attr(div, "style", div_style_value);
      }
      if (dirty & 2) {
        toggle_class(div, "green", ctx2[1] === "green");
      }
      if (dirty & 2) {
        toggle_class(div, "blue", ctx2[1] === "blue");
      }
    },
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let { size } = $$props;
  let { color = "green" } = $$props;
  let { bottom = -4 } = $$props;
  let { right = -4 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("bottom" in $$props2)
      $$invalidate(2, bottom = $$props2.bottom);
    if ("right" in $$props2)
      $$invalidate(3, right = $$props2.right);
  };
  return [size, color, bottom, right];
}
var SuccessStatusIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$c, create_fragment$c, safe_not_equal2, { size: 0, color: 1, bottom: 2, right: 3 }, add_css$c);
  }
};
function add_css$b(target) {
  append_styles(target, "svelte-1cswia4", ".container.svelte-1cswia4{padding:var(--onboard-spacing-4, var(--spacing-4))}.connecting-container.svelte-1cswia4{display:flex;justify-content:space-between;align-items:center;padding:var(--onboard-spacing-4, var(--spacing-4));border-radius:24px;background:var(--onboard-success-100, var(--success-100));border:1px solid var(--onboard-success-600, var(--success-600));width:100%;box-sizing:border-box}.icons.svelte-1cswia4{display:flex;justify-content:center;position:relative}.text.svelte-1cswia4{position:relative;right:var(--onboard-spacing-5, var(--spacing-5))}.tick.svelte-1cswia4{display:flex;color:var(--onboard-success-700, var(--success-700))}@media all and (max-width: 520px){}");
}
function create_fragment$b(ctx) {
  let div6;
  let div5;
  let div2;
  let walletappbadge0;
  let t0;
  let div0;
  let successstatusicon;
  let t1;
  let div1;
  let walletappbadge1;
  let t2;
  let div3;
  let t3_value = ctx[1]("connect.connectedWallet.mainText", {
    default: en.connect.connectedWallet.mainText
  }) + "";
  let t3;
  let t4;
  let div4;
  let current;
  walletappbadge0 = new WalletAppBadge({
    props: {
      size: 40,
      padding: 8,
      background: ctx[2] && ctx[2].icon ? "lightBlue" : "lightGray",
      border: "darkGreen",
      icon: ctx[2] && ctx[2].icon || defaultAppIcon
    }
  });
  successstatusicon = new SuccessStatusIcon({ props: { size: 17, right: null } });
  walletappbadge1 = new WalletAppBadge({
    props: {
      size: 40,
      padding: 8,
      border: "darkGreen",
      icon: ctx[0].icon
    }
  });
  return {
    c() {
      div6 = element("div");
      div5 = element("div");
      div2 = element("div");
      create_component(walletappbadge0.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(successstatusicon.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(walletappbadge1.$$.fragment);
      t2 = space();
      div3 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div4 = element("div");
      set_style(div0, "position", "relative");
      set_style(div0, "right", "0.85rem");
      set_style(div0, "top", "2px");
      set_style(div1, "position", "relative");
      set_style(div1, "right", "0.5rem");
      attr(div2, "class", "icons svelte-1cswia4");
      attr(div3, "class", "text svelte-1cswia4");
      attr(div4, "class", "tick svelte-1cswia4");
      set_style(div4, "width", "20px");
      attr(div5, "class", "connecting-container svelte-1cswia4");
      attr(div6, "class", "container svelte-1cswia4");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div2);
      mount_component(walletappbadge0, div2, null);
      append(div2, t0);
      append(div2, div0);
      mount_component(successstatusicon, div0, null);
      append(div2, t1);
      append(div2, div1);
      mount_component(walletappbadge1, div1, null);
      append(div5, t2);
      append(div5, div3);
      append(div3, t3);
      append(div5, t4);
      append(div5, div4);
      div4.innerHTML = success;
      current = true;
    },
    p(ctx2, [dirty]) {
      const walletappbadge1_changes = {};
      if (dirty & 1)
        walletappbadge1_changes.icon = ctx2[0].icon;
      walletappbadge1.$set(walletappbadge1_changes);
      if ((!current || dirty & 2) && t3_value !== (t3_value = ctx2[1]("connect.connectedWallet.mainText", {
        default: en.connect.connectedWallet.mainText
      }) + ""))
        set_data(t3, t3_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(walletappbadge0.$$.fragment, local);
      transition_in(successstatusicon.$$.fragment, local);
      transition_in(walletappbadge1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(walletappbadge0.$$.fragment, local);
      transition_out(successstatusicon.$$.fragment, local);
      transition_out(walletappbadge1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_component2(walletappbadge0);
      destroy_component2(successstatusicon);
      destroy_component2(walletappbadge1);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(1, $_ = $$value));
  let { selectedWallet } = $$props;
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  $$self.$$set = ($$props2) => {
    if ("selectedWallet" in $$props2)
      $$invalidate(0, selectedWallet = $$props2.selectedWallet);
  };
  return [selectedWallet, $_, appMetadata2];
}
var ConnectedWallet = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$b, create_fragment$b, safe_not_equal2, { selectedWallet: 0 }, add_css$b);
  }
};
function add_css$a(target) {
  append_styles(target, "svelte-gfxo3f", ".container.svelte-gfxo3f{display:flex;flex-direction:column;align-items:center;padding:var(--onboard-spacing-4, var(--spacing-4))}.connecting-container.svelte-gfxo3f{display:flex;justify-content:space-between;align-items:center;width:100%;padding:var(--onboard-spacing-4, var(--spacing-4));transition:background-color 100ms ease-in-out,\n      border-color 100ms ease-in-out;border-radius:24px;background-color:var(--onboard-primary-100, var(--primary-100));border:1px solid;border-color:var(--onboard-primary-300, var(--primary-300));box-sizing:border-box;color:var(--onboard-gray-600, var(--gray-600))}.connecting-container.warning.svelte-gfxo3f{background-color:var(--onboard-warning-100, var(--warning-100));border-color:var(--onboard-warning-400, var(--warning-400))}.icons.svelte-gfxo3f{display:flex;justify-content:center;position:relative}.text.svelte-gfxo3f{line-height:16px;margin-bottom:var(--onboard-spacing-5, var(--spacing-5))}.text.text-rejected.svelte-gfxo3f{line-height:24px;margin-bottom:0}.subtext.svelte-gfxo3f{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px}.rejected-cta.svelte-gfxo3f{color:var(--onboard-primary-500, var(--primary-500));cursor:pointer}.onboard-button-primary.svelte-gfxo3f{position:absolute;bottom:var(--onboard-spacing-3, var(--spacing-3))}.centered-flex-column.svelte-gfxo3f{display:flex;flex-direction:column;justify-content:center}.ml.svelte-gfxo3f{margin-left:var(--onboard-spacing-4, var(--spacing-4))}");
}
function create_else_block$2(ctx) {
  let div;
  let t_value = ctx[5]("connect.connectingWallet.paragraph", {
    default: en.connect.connectingWallet.paragraph
  }) + "";
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      attr(div, "class", "subtext svelte-gfxo3f");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[5]("connect.connectingWallet.paragraph", {
        default: en.connect.connectingWallet.paragraph
      }) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$6(ctx) {
  let div;
  let t_value = ctx[5]("connect.connectingWallet.rejectedCTA", {
    default: en.connect.connectingWallet.rejectedCTA
  }) + "";
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      attr(div, "class", "rejected-cta subtext svelte-gfxo3f");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
      if (!mounted) {
        dispose = listen(div, "click", function() {
          if (is_function2(ctx[0]))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && t_value !== (t_value = ctx[5]("connect.connectingWallet.rejectedCTA", {
        default: en.connect.connectingWallet.rejectedCTA
      }) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$a(ctx) {
  let div6;
  let div5;
  let div4;
  let div1;
  let walletappbadge0;
  let t0;
  let div0;
  let walletappbadge1;
  let t1;
  let div3;
  let div2;
  let t2_value = ctx[5](ctx[4] ? "connect.connectingWallet.rejectedText" : "connect.connectingWallet.mainText", {
    default: ctx[4] ? en.connect.connectingWallet.rejectedText : en.connect.connectingWallet.mainText
  }) + "";
  let t2;
  let t3;
  let t4;
  let button;
  let t5_value = ctx[5]("connect.connectingWallet.primaryButton", {
    default: en.connect.connectingWallet.primaryButton
  }) + "";
  let t5;
  let current;
  let mounted;
  let dispose;
  walletappbadge0 = new WalletAppBadge({
    props: {
      size: 40,
      padding: 8,
      icon: ctx[6] && ctx[6].icon || defaultAppIcon,
      border: ctx[4] ? "yellow" : "blue",
      background: "lightGray"
    }
  });
  walletappbadge1 = new WalletAppBadge({
    props: {
      size: 40,
      padding: 8,
      border: ctx[4] ? "yellow" : "blue",
      background: "white",
      icon: ctx[1].icon
    }
  });
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block$6;
    return create_else_block$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div6 = element("div");
      div5 = element("div");
      div4 = element("div");
      div1 = element("div");
      create_component(walletappbadge0.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(walletappbadge1.$$.fragment);
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      t2 = text(t2_value);
      t3 = space();
      if_block.c();
      t4 = space();
      button = element("button");
      t5 = text(t5_value);
      set_style(div0, "position", "relative");
      set_style(div0, "right", "0.5rem");
      attr(div1, "class", "icons svelte-gfxo3f");
      attr(div2, "class", "text svelte-gfxo3f");
      toggle_class(div2, "text-rejected", ctx[4]);
      attr(div3, "class", "centered-flex-column ml svelte-gfxo3f");
      set_style(div4, "display", "flex");
      attr(div5, "class", "connecting-container svelte-gfxo3f");
      toggle_class(div5, "warning", ctx[4]);
      attr(button, "class", "onboard-button-primary svelte-gfxo3f");
      attr(div6, "class", "container svelte-gfxo3f");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div4);
      append(div4, div1);
      mount_component(walletappbadge0, div1, null);
      append(div1, t0);
      append(div1, div0);
      mount_component(walletappbadge1, div0, null);
      append(div4, t1);
      append(div4, div3);
      append(div3, div2);
      append(div2, t2);
      append(div3, t3);
      if_block.m(div3, null);
      append(div6, t4);
      append(div6, button);
      append(button, t5);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const walletappbadge0_changes = {};
      if (dirty & 16)
        walletappbadge0_changes.border = ctx2[4] ? "yellow" : "blue";
      walletappbadge0.$set(walletappbadge0_changes);
      const walletappbadge1_changes = {};
      if (dirty & 16)
        walletappbadge1_changes.border = ctx2[4] ? "yellow" : "blue";
      if (dirty & 2)
        walletappbadge1_changes.icon = ctx2[1].icon;
      walletappbadge1.$set(walletappbadge1_changes);
      if ((!current || dirty & 48) && t2_value !== (t2_value = ctx2[5](ctx2[4] ? "connect.connectingWallet.rejectedText" : "connect.connectingWallet.mainText", {
        default: ctx2[4] ? en.connect.connectingWallet.rejectedText : en.connect.connectingWallet.mainText
      }) + ""))
        set_data(t2, t2_value);
      if (dirty & 16) {
        toggle_class(div2, "text-rejected", ctx2[4]);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div3, null);
        }
      }
      if (dirty & 16) {
        toggle_class(div5, "warning", ctx2[4]);
      }
      if ((!current || dirty & 32) && t5_value !== (t5_value = ctx2[5]("connect.connectingWallet.primaryButton", {
        default: en.connect.connectingWallet.primaryButton
      }) + ""))
        set_data(t5, t5_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(walletappbadge0.$$.fragment, local);
      transition_in(walletappbadge1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(walletappbadge0.$$.fragment, local);
      transition_out(walletappbadge1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_component2(walletappbadge0);
      destroy_component2(walletappbadge1);
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(5, $_ = $$value));
  let { connectWallet } = $$props;
  let { selectedWallet } = $$props;
  let { deselectWallet } = $$props;
  let { setStep } = $$props;
  let { connectionRejected } = $$props;
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  const click_handler = () => {
    deselectWallet(selectedWallet.label);
    setStep("selectingWallet");
  };
  $$self.$$set = ($$props2) => {
    if ("connectWallet" in $$props2)
      $$invalidate(0, connectWallet = $$props2.connectWallet);
    if ("selectedWallet" in $$props2)
      $$invalidate(1, selectedWallet = $$props2.selectedWallet);
    if ("deselectWallet" in $$props2)
      $$invalidate(2, deselectWallet = $$props2.deselectWallet);
    if ("setStep" in $$props2)
      $$invalidate(3, setStep = $$props2.setStep);
    if ("connectionRejected" in $$props2)
      $$invalidate(4, connectionRejected = $$props2.connectionRejected);
  };
  return [
    connectWallet,
    selectedWallet,
    deselectWallet,
    setStep,
    connectionRejected,
    $_,
    appMetadata2,
    click_handler
  ];
}
var ConnectingWallet = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$a, create_fragment$a, safe_not_equal2, {
      connectWallet: 0,
      selectedWallet: 1,
      deselectWallet: 2,
      setStep: 3,
      connectionRejected: 4
    }, add_css$a);
  }
};
var infoIcon = `
<svg width="100%" height="100%" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M8 0.5C3.86 0.5 0.5 3.86 0.5 8C0.5 12.14 3.86 15.5 8 15.5C12.14 15.5 15.5 12.14 15.5 8C15.5 3.86 12.14 0.5 8 0.5ZM8.75 11.75H7.25L7.25 7.25L8.75 7.25L8.75 11.75ZM8.75 5.75L7.25 5.75L7.25 4.25H8.75L8.75 5.75Z" fill="currentColor"/>
</svg>
`;
function add_css$9(target) {
  append_styles(target, "svelte-2c2etc", ".container.svelte-2c2etc{display:flex;justify-content:space-between;padding:var(--onboard-spacing-5, var(--spacing-5));color:var(--onboard-warning-700, var(--warning-700));font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px;border:1px solid var(--onboard-warning-400, var(--warning-400));background-color:var(--onboard-warning-100, var(--warning-100));margin:0;border-radius:12px}.icon.svelte-2c2etc{color:var(--onboard-warning-700, var(--warning-700));width:1rem;height:1rem;margin-left:var(--onboard-spacing-5, var(--spacing-5))}p.svelte-2c2etc{margin:0;width:fit-content}");
}
function create_fragment$9(ctx) {
  let div1;
  let p2;
  let t2;
  let div0;
  let div1_intro;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div1 = element("div");
      p2 = element("p");
      if (default_slot)
        default_slot.c();
      t2 = space();
      div0 = element("div");
      attr(p2, "class", "svelte-2c2etc");
      attr(div0, "class", "icon svelte-2c2etc");
      attr(div1, "class", "container svelte-2c2etc");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p2);
      if (default_slot) {
        default_slot.m(p2, null);
      }
      append(div1, t2);
      append(div1, div0);
      div0.innerHTML = infoIcon;
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (!div1_intro) {
        add_render_callback(() => {
          div1_intro = create_in_transition(div1, fade, {});
          div1_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Warning = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$9, create_fragment$9, safe_not_equal2, {}, add_css$9);
  }
};
function add_css$8(target) {
  append_styles(target, "svelte-up669r", ".outer-container.svelte-up669r{padding:var(--onboard-spacing-4, var(--spacing-4))}.link.svelte-up669r{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px;color:var(--onboard-primary-500, var(--primary-500));cursor:pointer;text-decoration:none}");
}
function get_each_context$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2].name;
  child_ctx[3] = list[i2].url;
  child_ctx[5] = i2;
  return child_ctx;
}
function create_else_block$1(ctx) {
  let t_value = ctx[0]("connect.selectingWallet.installWallet", {
    default: en.connect.selectingWallet.installWallet,
    values: { app: ctx[2] || "this app" }
  }) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0]("connect.selectingWallet.installWallet", {
        default: en.connect.selectingWallet.installWallet,
        values: { app: ctx2[2] || "this app" }
      }) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t2);
    }
  };
}
function create_if_block$5(ctx) {
  let t0_value = ctx[0]("connect.selectingWallet.recommendedWalletsPart1", {
    default: en.connect.selectingWallet.recommendedWalletsPart1,
    values: { app: ctx[2] || "This app" }
  }) + "";
  let t0;
  let t1;
  let t2;
  let t3_value = ctx[0]("connect.selectingWallet.recommendedWalletsPart2", {
    default: en.connect.selectingWallet.recommendedWalletsPart2
  }) + "";
  let t3;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1(get_each_context$1(ctx, each_value, i2));
  }
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t2, anchor);
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[0]("connect.selectingWallet.recommendedWalletsPart1", {
        default: en.connect.selectingWallet.recommendedWalletsPart1,
        values: { app: ctx2[2] || "This app" }
      }) + ""))
        set_data(t0, t0_value);
      if (dirty & 2) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(t2.parentNode, t2);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 1 && t3_value !== (t3_value = ctx2[0]("connect.selectingWallet.recommendedWalletsPart2", {
        default: en.connect.selectingWallet.recommendedWalletsPart2
      }) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block$1(ctx) {
  let a2;
  let t0_value = ctx[2] + "";
  let t0;
  let t1_value = (ctx[5] < ctx[1].length - 1 ? ", " : "") + "";
  let t1;
  let a_href_value;
  return {
    c() {
      a2 = element("a");
      t0 = text(t0_value);
      t1 = text(t1_value);
      attr(a2, "class", "link svelte-up669r");
      attr(a2, "href", a_href_value = ctx[3]);
      attr(a2, "target", "_blank");
      attr(a2, "rel", "noreferrer noopener");
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      append(a2, t0);
      append(a2, t1);
    },
    p: noop3,
    d(detaching) {
      if (detaching)
        detach(a2);
    }
  };
}
function create_default_slot$4(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block$5;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$8(ctx) {
  let div;
  let warning;
  let current;
  warning = new Warning({
    props: {
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(warning.$$.fragment);
      attr(div, "class", "outer-container svelte-up669r");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(warning, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const warning_changes = {};
      if (dirty & 65) {
        warning_changes.$$scope = { dirty, ctx: ctx2 };
      }
      warning.$set(warning_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(warning.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(warning.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component2(warning);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(0, $_ = $$value));
  const { recommendedInjectedWallets, name: name2 } = internalState$.getValue().appMetadata || {};
  return [$_, recommendedInjectedWallets, name2];
}
var InstallWallet = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$8, create_fragment$8, safe_not_equal2, {}, add_css$8);
  }
};
function add_css$7(target) {
  append_styles(target, "svelte-kjyo9y", "button.svelte-kjyo9y{position:relative;background-color:var(\n      --onboard-wallet-button-background,\n      var(--onboard-white, var(--white))\n    );border:1px solid\n      var(\n        --onboard-wallet-button-border-color,\n        var(--onboard-primary-200, var(--primary-200))\n      );transition:background-color 250ms ease-in-out;color:var(\n      --onboard-wallet-button-color,\n      var(--onboard-gray-700, var(--gray-700))\n    )}button.svelte-kjyo9y:hover{background-color:var(\n      --onboard-wallet-button-background-hover,\n      var(--onboard-primary-100, var(--primary-100))\n    )}button.connected.svelte-kjyo9y{border:1px solid var(--onboard-success-200, var(--success-200))}button.connected.svelte-kjyo9y:hover{background-color:var(--onboard-success-100, var(--success-100))}.name.svelte-kjyo9y{margin-left:var(--onboard-spacing-4, var(--spacing-4))}");
}
function create_if_block$4(ctx) {
  let successstatusicon;
  let current;
  successstatusicon = new SuccessStatusIcon({
    props: { size: 16, bottom: null, right: 16 }
  });
  return {
    c() {
      create_component(successstatusicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(successstatusicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(successstatusicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(successstatusicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(successstatusicon, detaching);
    }
  };
}
function create_fragment$7(ctx) {
  let button;
  let walletappbadge;
  let t0;
  let span;
  let t1;
  let t2;
  let button_intro;
  let current;
  let mounted;
  let dispose;
  walletappbadge = new WalletAppBadge({
    props: {
      size: 48,
      icon: ctx[0],
      loading: ctx[4],
      border: ctx[3] ? "green" : "blue",
      background: "transparent"
    }
  });
  let if_block = ctx[3] && create_if_block$4();
  return {
    c() {
      button = element("button");
      create_component(walletappbadge.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(ctx[1]);
      t2 = space();
      if (if_block)
        if_block.c();
      attr(span, "class", "name svelte-kjyo9y");
      attr(button, "class", "svelte-kjyo9y");
      toggle_class(button, "connected", ctx[3]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(walletappbadge, button, null);
      append(button, t0);
      append(button, span);
      append(span, t1);
      append(button, t2);
      if (if_block)
        if_block.m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function2(ctx[2]))
            ctx[2].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const walletappbadge_changes = {};
      if (dirty & 1)
        walletappbadge_changes.icon = ctx[0];
      if (dirty & 16)
        walletappbadge_changes.loading = ctx[4];
      if (dirty & 8)
        walletappbadge_changes.border = ctx[3] ? "green" : "blue";
      walletappbadge.$set(walletappbadge_changes);
      if (!current || dirty & 2)
        set_data(t1, ctx[1]);
      if (ctx[3]) {
        if (if_block) {
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$4();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 8) {
        toggle_class(button, "connected", ctx[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(walletappbadge.$$.fragment, local);
      transition_in(if_block);
      if (!button_intro) {
        add_render_callback(() => {
          button_intro = create_in_transition(button, fade, {});
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(walletappbadge.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      destroy_component2(walletappbadge);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { icon } = $$props;
  let { label } = $$props;
  let { onClick } = $$props;
  let { connected } = $$props;
  let { connecting } = $$props;
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("connected" in $$props2)
      $$invalidate(3, connected = $$props2.connected);
    if ("connecting" in $$props2)
      $$invalidate(4, connecting = $$props2.connecting);
  };
  return [icon, label, onClick, connected, connecting];
}
var WalletButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$7, create_fragment$7, safe_not_equal2, {
      icon: 0,
      label: 1,
      onClick: 2,
      connected: 3,
      connecting: 4
    }, add_css$7);
  }
};
function add_css$6(target) {
  append_styles(target, "svelte-9xeusa", ".outer-container.svelte-9xeusa{display:flex;flex-direction:column;padding:var(--onboard-spacing-4, var(--spacing-4));padding-top:0}.wallets-container.svelte-9xeusa{display:grid;grid-template-columns:repeat(var(--onboard-wallet-columns, 2), 1fr);gap:var(--onboard-spacing-5, var(--spacing-5));width:100%}.warning-container.svelte-9xeusa{margin-bottom:1rem}@media all and (max-width: 520px){.wallets-container.svelte-9xeusa{grid-template-columns:repeat(1, 1fr)}}");
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_if_block$3(ctx) {
  let div;
  let warning;
  let current;
  warning = new Warning({
    props: {
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(warning.$$.fragment);
      attr(div, "class", "warning-container svelte-9xeusa");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(warning, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const warning_changes = {};
      if (dirty & 520) {
        warning_changes.$$scope = { dirty, ctx: ctx2 };
      }
      warning.$set(warning_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(warning.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(warning.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component2(warning);
    }
  };
}
function create_default_slot$3(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag();
      html_anchor = empty2();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(ctx[3], target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        html_tag.p(ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_each_block(ctx) {
  let walletbutton;
  let current;
  function func() {
    return ctx[5](ctx[6]);
  }
  walletbutton = new WalletButton({
    props: {
      connected: ctx[4](ctx[6].label),
      connecting: ctx[2] === ctx[6].label,
      label: ctx[6].label,
      icon: ctx[6].icon,
      onClick: func
    }
  });
  return {
    c() {
      create_component(walletbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(walletbutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const walletbutton_changes = {};
      if (dirty & 1)
        walletbutton_changes.connected = ctx[4](ctx[6].label);
      if (dirty & 5)
        walletbutton_changes.connecting = ctx[2] === ctx[6].label;
      if (dirty & 1)
        walletbutton_changes.label = ctx[6].label;
      if (dirty & 1)
        walletbutton_changes.icon = ctx[6].icon;
      if (dirty & 3)
        walletbutton_changes.onClick = func;
      walletbutton.$set(walletbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(walletbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(walletbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(walletbutton, detaching);
    }
  };
}
function create_fragment$6(ctx) {
  let div1;
  let t2;
  let div0;
  let current;
  let if_block = ctx[3] && create_if_block$3(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t2 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "wallets-container svelte-9xeusa");
      attr(div1, "class", "outer-container svelte-9xeusa");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 23) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { wallets } = $$props;
  let { selectWallet } = $$props;
  let { connectingWalletLabel } = $$props;
  let { connectingErrorMessage } = $$props;
  function checkConnected(label) {
    const { wallets: wallets2 } = state.get();
    return !!wallets2.find((wallet2) => wallet2.label === label);
  }
  const func = (wallet2) => selectWallet(wallet2);
  $$self.$$set = ($$props2) => {
    if ("wallets" in $$props2)
      $$invalidate(0, wallets = $$props2.wallets);
    if ("selectWallet" in $$props2)
      $$invalidate(1, selectWallet = $$props2.selectWallet);
    if ("connectingWalletLabel" in $$props2)
      $$invalidate(2, connectingWalletLabel = $$props2.connectingWalletLabel);
    if ("connectingErrorMessage" in $$props2)
      $$invalidate(3, connectingErrorMessage = $$props2.connectingErrorMessage);
  };
  return [
    wallets,
    selectWallet,
    connectingWalletLabel,
    connectingErrorMessage,
    checkConnected,
    func
  ];
}
var SelectingWallet = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$6, create_fragment$6, safe_not_equal2, {
      wallets: 0,
      selectWallet: 1,
      connectingWalletLabel: 2,
      connectingErrorMessage: 3
    }, add_css$6);
  }
};
var blocknative = `
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 790.34 114.51" width="80%">
  <defs>
    <style>.cls-1{fill:#262a3d;}.cls-2{fill:url(#linear-gradient);}.cls-3{fill:url(#linear-gradient-2);}</style>
    <linearGradient id="linear-gradient" x1="694.45" y1="46.08" x2="741.39" y2="46.08" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#55ccfe"/><stop offset="1" stop-color="#5e93ef"/>
    </linearGradient>
    <linearGradient id="linear-gradient-2" x1="694.45" y1="86.73" x2="788.33" y2="86.73" xlink:href="#linear-gradient"/>
  </defs>
  <polygon class="cls-1" points="710.09 86.73 694.45 59.63 725.74 59.63 725.74 59.63 741.39 86.73 710.09 86.73"/>
  <polygon class="cls-2" points="725.74 59.63 694.45 59.63 710.09 32.53 741.39 32.53 725.74 59.63"/>
  <polygon class="cls-1" points="757.03 59.63 741.39 32.53 710.09 32.53 694.45 5.43 757.03 5.43 788.33 59.63 757.03 59.63"/>
  <polygon class="cls-3" points="757.03 113.83 694.45 113.83 710.09 86.73 741.39 86.73 757.03 59.63 788.33 59.63 757.03 113.83"/>
  <path class="cls-1" d="M70.51,65.77c0,19.47-14.37,34.5-31.88,34.5-9.54,0-16.47-3.53-21.17-9.54v7.71H.6V6.87L17.46,1.68V40.82c4.7-6,11.63-9.54,21.17-9.54C56.14,31.28,70.51,46.3,70.51,65.77Zm-16.86,0c0-11-7.7-18.42-18.16-18.42s-18,7.45-18,18.42,7.71,18.43,18,18.43S53.65,76.75,53.65,65.77Z"/>
  <path class="cls-1" d="M78.09,6.87,94.94,1.68V98.44H78.09Z"/><path class="cls-1" d="M102.39,65.77a34.56,34.56,0,1,1,34.49,34.5A34.13,34.13,0,0,1,102.39,65.77Zm52.26,0c0-10.58-7.71-18-17.77-18s-17.64,7.45-17.64,18,7.71,18,17.64,18S154.65,76.36,154.65,65.77Z"/>
  <path class="cls-1" d="M177.9,65.77c0-19.47,14.63-34.49,34.49-34.49,12.81,0,23.91,6.79,29.27,16.85l-14.5,8.5c-2.62-5.36-8.24-8.76-14.9-8.76-10.06,0-17.51,7.45-17.51,17.9s7.45,17.77,17.51,17.77c6.8,0,12.41-3.26,15-8.62l14.63,8.36a33.47,33.47,0,0,1-29.53,17C192.53,100.27,177.9,85.24,177.9,65.77Z"/>
  <path class="cls-1" d="M290.32,98.44,266.54,68.78V98.44H249.68V6.87l16.86-5.19V61.85L289,33.11h20.12L282.87,65.38l27.05,33.06Z"/>
  <path class="cls-1" d="M377.26,58.32V98.44H360.4v-38c0-8.89-5.35-13.46-12.93-13.46-8.23,0-14.38,4.83-14.38,16.2V98.44H316.24V33.11h16.85v7.31c3.92-5.88,10.72-9.14,19.47-9.14C366.41,31.28,377.26,41,377.26,58.32Z"/>
  <path class="cls-1" d="M454.72,33.11V98.44H437.87V90.73c-4.71,5.88-11.76,9.54-21.3,9.54-17.38,0-31.75-15-31.75-34.5s14.37-34.49,31.75-34.49c9.54,0,16.59,3.66,21.3,9.54V33.11ZM437.87,65.77c0-11-7.71-18.42-18.17-18.42s-18,7.45-18,18.42,7.71,18.43,18,18.43S437.87,76.75,437.87,65.77Z"/>
  <path class="cls-1" d="M498.65,49.31V33.11H483.88V13.9L467,19.09v57.4c0,17.64,8,24.56,31.63,22V83.15c-9.67.53-14.77.39-14.77-6.66V49.31Z"/><path class="cls-1" d="M510.46,33.11h16.85V98.44H510.46Z"/>
  <path class="cls-1" d="M603.13,33.11,578.3,98.44H559.09L534.27,33.11h18.55l15.81,45.73,15.94-45.73Z"/><path class="cls-1" d="M639.2,85c6.53,0,11.76-2.74,14.64-6.53l13.58,7.84c-6.14,8.88-15.94,14-28.48,14-22,0-35.8-15-35.8-34.5s14-34.49,34.49-34.49c19.34,0,33.06,15.29,33.06,34.49A39.11,39.11,0,0,1,670,72.7H620.78C623.13,81.32,630.32,85,639.2,85Zm14.64-25.35c-2.1-9.41-9.15-13.2-16.21-13.2-9,0-15.15,4.84-17.12,13.2Z"/>
</svg>
`;
function add_css$5(target) {
  append_styles(target, "svelte-f9sn92", ".sidebar.svelte-f9sn92{padding:var(--onboard-spacing-3, var(--spacing-3));border-radius:24px 0 0 24px;background:var(\n      --onboard-connect-sidebar-background,\n      var(--onboard-gray-100, var(--gray-100))\n    );color:var(\n      --onboard-connect-sidebar-color,\n      var(--onboard-gray-700, var(--gray-700))\n    )}.inner-container.svelte-f9sn92{padding-left:var(--onboard-spacing-5, var(--spacing-5));max-width:236px}.icon-container.svelte-f9sn92{height:3rem;display:flex;margin-bottom:var(--onboard-spacing-4, var(--spacing-4))}.heading.svelte-f9sn92{font-size:var(--onboard-font-size-3, var(--font-size-3));margin:0 0 var(--onboard-spacing-5, var(--spacing-5)) 0}.subheading.svelte-f9sn92{margin:0 0 var(--onboard-spacing-5, var(--spacing-5)) 0}.description.svelte-f9sn92{line-height:20px;font-size:var(--onboard-font-size-6, var(--font-size-6));margin:0}.indicators.svelte-f9sn92{display:flex;align-items:center;margin-top:var(--onboard-spacing-2, var(--spacing-2))}.indicator.svelte-f9sn92{position:relative;width:8px;height:8px;border-radius:8px;background:var(\n      --onboard-connect-sidebar-progress-background,\n      var(--onboard-gray-200, var(--gray-200))\n    );transition:background 250ms ease-in-out}.indicator.on.svelte-f9sn92{background:var(\n      --onboard-connect-sidebar-progress-color,\n      var(--onboard-primary-600, var(--primary-600))\n    );border:2px solid\n      var(\n        --onboard-connect-sidebar-progress-background,\n        var(--onboard-gray-200, var(--gray-200))\n      )}.join.svelte-f9sn92{position:relative;z-index:1;right:4px;height:2px;background:var(\n      --onboard-connect-sidebar-progress-background,\n      var(--onboard-gray-200, var(--gray-200))\n    );transition:background 250ms ease-in-out}.join.active.svelte-f9sn92{background:var(\n      --onboard-connect-sidebar-progress-color,\n      var(--onboard-primary-600, var(--primary-600))\n    )}img.svelte-f9sn92{max-width:100%;height:auto}");
}
function create_else_block_1(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag();
      html_anchor = empty2();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(blocknative, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p: noop3,
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_if_block_1$2(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (isSVG(ctx2[3] || ctx2[2]))
      return create_if_block_2$2;
    return create_else_block;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = ctx[3] || ctx[2]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "logo");
      attr(img, "class", "svelte-f9sn92");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p: noop3,
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_2$2(ctx) {
  let html_tag;
  let raw_value = (ctx[3] || ctx[2]) + "";
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag();
      html_anchor = empty2();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p: noop3,
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_if_block$2(ctx) {
  let h2;
  let t_value = ctx[1](`connect.${ctx[0]}.sidebar.heading`, { default: ctx[7] }) + "";
  let t2;
  return {
    c() {
      h2 = element("h2");
      t2 = text(t_value);
      attr(h2, "class", "heading svelte-f9sn92");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      append(h2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 3 && t_value !== (t_value = ctx2[1](`connect.${ctx2[0]}.sidebar.heading`, { default: ctx2[7] }) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(h2);
    }
  };
}
function create_fragment$5(ctx) {
  let div8;
  let div7;
  let div0;
  let t0;
  let show_if = ctx[1](`connect.${ctx[0]}.sidebar.heading`, { default: "" });
  let t1;
  let h4;
  let t2_value = ctx[1](`connect.${ctx[0]}.sidebar.subheading`, { default: ctx[5] }) + "";
  let t2;
  let t3;
  let p2;
  let t4_value = ctx[1](`connect.${ctx[0]}.sidebar.paragraph`, {
    values: { app: ctx[4] },
    default: ctx[6]
  }) + "";
  let t4;
  let t5;
  let div6;
  let div1;
  let t6;
  let div2;
  let div2_style_value;
  let t7;
  let div3;
  let t8;
  let div4;
  let div4_style_value;
  let t9;
  let div5;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3] || ctx2[2])
      return create_if_block_1$2;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = show_if && create_if_block$2(ctx);
  return {
    c() {
      div8 = element("div");
      div7 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      p2 = element("p");
      t4 = text(t4_value);
      t5 = space();
      div6 = element("div");
      div1 = element("div");
      t6 = space();
      div2 = element("div");
      t7 = space();
      div3 = element("div");
      t8 = space();
      div4 = element("div");
      t9 = space();
      div5 = element("div");
      attr(div0, "class", "icon-container svelte-f9sn92");
      attr(h4, "class", "subheading svelte-f9sn92");
      attr(p2, "class", "description svelte-f9sn92");
      attr(div1, "class", "indicator svelte-f9sn92");
      toggle_class(div1, "on", true);
      attr(div2, "class", "join svelte-f9sn92");
      attr(div2, "style", div2_style_value = `${ctx[0] !== "selectingWallet" ? "right: 4px; width: 52px;" : "right: 2px; width: 54px;"}`);
      toggle_class(div2, "active", ctx[0] !== "selectingWallet");
      attr(div3, "class", "indicator svelte-f9sn92");
      attr(div3, "style", `right: 8px;`);
      toggle_class(div3, "on", ctx[0] !== "selectingWallet");
      attr(div4, "class", "join svelte-f9sn92");
      attr(div4, "style", div4_style_value = `${ctx[0] === "connectedWallet" ? "right: 12px; width: 52px;" : "right: 10px; width: 54px;"}`);
      toggle_class(div4, "active", ctx[0] === "connectedWallet");
      attr(div5, "style", `right: 16px;`);
      attr(div5, "class", "indicator svelte-f9sn92");
      toggle_class(div5, "on", ctx[0] === "connectedWallet");
      attr(div6, "class", "indicators svelte-f9sn92");
      attr(div7, "class", "inner-container svelte-f9sn92");
      attr(div8, "class", "sidebar svelte-f9sn92");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div7);
      append(div7, div0);
      if_block0.m(div0, null);
      append(div7, t0);
      if (if_block1)
        if_block1.m(div7, null);
      append(div7, t1);
      append(div7, h4);
      append(h4, t2);
      append(div7, t3);
      append(div7, p2);
      append(p2, t4);
      append(div7, t5);
      append(div7, div6);
      append(div6, div1);
      append(div6, t6);
      append(div6, div2);
      append(div6, t7);
      append(div6, div3);
      append(div6, t8);
      append(div6, div4);
      append(div6, t9);
      append(div6, div5);
    },
    p(ctx2, [dirty]) {
      if_block0.p(ctx2, dirty);
      if (dirty & 3)
        show_if = ctx2[1](`connect.${ctx2[0]}.sidebar.heading`, { default: "" });
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$2(ctx2);
          if_block1.c();
          if_block1.m(div7, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 3 && t2_value !== (t2_value = ctx2[1](`connect.${ctx2[0]}.sidebar.subheading`, { default: ctx2[5] }) + ""))
        set_data(t2, t2_value);
      if (dirty & 3 && t4_value !== (t4_value = ctx2[1](`connect.${ctx2[0]}.sidebar.paragraph`, {
        values: { app: ctx2[4] },
        default: ctx2[6]
      }) + ""))
        set_data(t4, t4_value);
      if (dirty & 1 && div2_style_value !== (div2_style_value = `${ctx2[0] !== "selectingWallet" ? "right: 4px; width: 52px;" : "right: 2px; width: 54px;"}`)) {
        attr(div2, "style", div2_style_value);
      }
      if (dirty & 1) {
        toggle_class(div2, "active", ctx2[0] !== "selectingWallet");
      }
      if (dirty & 1) {
        toggle_class(div3, "on", ctx2[0] !== "selectingWallet");
      }
      if (dirty & 1 && div4_style_value !== (div4_style_value = `${ctx2[0] === "connectedWallet" ? "right: 12px; width: 52px;" : "right: 10px; width: 54px;"}`)) {
        attr(div4, "style", div4_style_value);
      }
      if (dirty & 1) {
        toggle_class(div4, "active", ctx2[0] === "connectedWallet");
      }
      if (dirty & 1) {
        toggle_class(div5, "on", ctx2[0] === "connectedWallet");
      }
    },
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div8);
      if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(1, $_ = $$value));
  let { step } = $$props;
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  const { icon, logo, name: name2 = "This app" } = appMetadata2 || {};
  const defaultContent = en.connect[step].sidebar;
  const { subheading, paragraph } = defaultContent;
  const { heading } = defaultContent;
  $$self.$$set = ($$props2) => {
    if ("step" in $$props2)
      $$invalidate(0, step = $$props2.step);
  };
  return [step, $_, icon, logo, name2, subheading, paragraph, heading];
}
var Sidebar = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$5, create_fragment$5, safe_not_equal2, { step: 0 }, add_css$5);
  }
};
function add_css$4(target) {
  append_styles(target, "svelte-37ahne", ".container.svelte-37ahne{position:relative;display:flex;font-family:var(--onboard-font-family-normal, var(--font-family-normal));line-height:24px;color:var(--onboard-gray-700, var(--gray-700));font-size:var(--onboard-font-size-5, var(--font-size-5));height:var(--onboard-connect-content-height, 440px);overflow:hidden}.content.svelte-37ahne{width:var(--onboard-connect-content-width, 488px);display:flex;flex-direction:column}.scroll-container.svelte-37ahne{overflow-y:auto;transition:opacity 250ms ease-in-out;scrollbar-width:none}.scroll-container.svelte-37ahne::-webkit-scrollbar{display:none}.header.svelte-37ahne{position:relative;display:flex;align-items:center;box-shadow:var(--onboard-shadow-2, var(--shadow-2));background-color:var(\n      --onboard-connect-header-background,\n      var(--onboard-white, var(--white))\n    );color:var(\n      --onboard-connect-header-color,\n      var(--onboard-black, var(--black))\n    );border-radius:0 24px 0 0}.header-heading.svelte-37ahne{margin:var(--onboard-spacing-4, var(--spacing-4));line-height:16px}.button-container.svelte-37ahne{position:absolute;right:var(--onboard-spacing-5, var(--spacing-5));top:var(--onboard-spacing-5, var(--spacing-5))}.disabled.svelte-37ahne{opacity:0.2;pointer-events:none}@media all and (max-width: 520px){.content.svelte-37ahne{width:100%}.container.svelte-37ahne{height:auto;min-height:228px}}");
}
function create_if_block$1(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      close: ctx[13],
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 134219775) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(modal, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let sidebar;
  let current;
  sidebar = new Sidebar({ props: { step: ctx[1] } });
  return {
    c() {
      create_component(sidebar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sidebar_changes = {};
      if (dirty & 2)
        sidebar_changes.step = ctx2[1];
      sidebar.$set(sidebar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(sidebar, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4, create_if_block_5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3].length)
      return 0;
    if (!ctx2[0])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_5(ctx) {
  let installwallet;
  let current;
  installwallet = new InstallWallet({});
  return {
    c() {
      create_component(installwallet.$$.fragment);
    },
    m(target, anchor) {
      mount_component(installwallet, target, anchor);
      current = true;
    },
    p: noop3,
    i(local) {
      if (current)
        return;
      transition_in(installwallet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(installwallet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(installwallet, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let agreement2;
  let updating_agreed;
  let t2;
  let div;
  let selectingwallet;
  let current;
  function agreement_agreed_binding(value) {
    ctx[17](value);
  }
  let agreement_props = {};
  if (ctx[5] !== void 0) {
    agreement_props.agreed = ctx[5];
  }
  agreement2 = new Agreement({ props: agreement_props });
  binding_callbacks.push(() => bind2(agreement2, "agreed", agreement_agreed_binding));
  selectingwallet = new SelectingWallet({
    props: {
      selectWallet: ctx[11],
      wallets: ctx[3],
      connectingWalletLabel: ctx[6],
      connectingErrorMessage: ctx[7]
    }
  });
  return {
    c() {
      create_component(agreement2.$$.fragment);
      t2 = space();
      div = element("div");
      create_component(selectingwallet.$$.fragment);
      attr(div, "class", "svelte-37ahne");
      toggle_class(div, "disabled", !ctx[5]);
    },
    m(target, anchor) {
      mount_component(agreement2, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      mount_component(selectingwallet, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const agreement_changes = {};
      if (!updating_agreed && dirty & 32) {
        updating_agreed = true;
        agreement_changes.agreed = ctx2[5];
        add_flush_callback(() => updating_agreed = false);
      }
      agreement2.$set(agreement_changes);
      const selectingwallet_changes = {};
      if (dirty & 8)
        selectingwallet_changes.wallets = ctx2[3];
      if (dirty & 64)
        selectingwallet_changes.connectingWalletLabel = ctx2[6];
      if (dirty & 128)
        selectingwallet_changes.connectingErrorMessage = ctx2[7];
      selectingwallet.$set(selectingwallet_changes);
      if (dirty & 32) {
        toggle_class(div, "disabled", !ctx2[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(agreement2.$$.fragment, local);
      transition_in(selectingwallet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(agreement2.$$.fragment, local);
      transition_out(selectingwallet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(agreement2, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div);
      destroy_component2(selectingwallet);
    }
  };
}
function create_if_block_2$1(ctx) {
  let connectingwallet;
  let current;
  connectingwallet = new ConnectingWallet({
    props: {
      connectWallet: ctx[14],
      connectionRejected: ctx[2],
      setStep: ctx[15],
      deselectWallet: ctx[12],
      selectedWallet: ctx[4]
    }
  });
  return {
    c() {
      create_component(connectingwallet.$$.fragment);
    },
    m(target, anchor) {
      mount_component(connectingwallet, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const connectingwallet_changes = {};
      if (dirty & 4)
        connectingwallet_changes.connectionRejected = ctx2[2];
      if (dirty & 16)
        connectingwallet_changes.selectedWallet = ctx2[4];
      connectingwallet.$set(connectingwallet_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(connectingwallet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(connectingwallet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(connectingwallet, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let connectedwallet;
  let current;
  connectedwallet = new ConnectedWallet({
    props: {
      selectedWallet: ctx[4]
    }
  });
  return {
    c() {
      create_component(connectedwallet.$$.fragment);
    },
    m(target, anchor) {
      mount_component(connectedwallet, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const connectedwallet_changes = {};
      if (dirty & 16)
        connectedwallet_changes.selectedWallet = ctx2[4];
      connectedwallet.$set(connectedwallet_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(connectedwallet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(connectedwallet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(connectedwallet, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let div4;
  let t0;
  let div3;
  let div1;
  let h4;
  let t1_value = ctx[10](`connect.${ctx[1]}.header`, {
    default: en.connect[ctx[1]].header,
    values: {
      connectionRejected: ctx[2],
      wallet: ctx[4] && ctx[4].label
    }
  }) + "";
  let t1;
  let t2;
  let div0;
  let closebutton;
  let t3;
  let div2;
  let t4;
  let t5;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[8] >= 809 && create_if_block_6(ctx);
  closebutton = new CloseButton({});
  let if_block1 = ctx[1] === "selectingWallet" && create_if_block_3(ctx);
  let if_block2 = ctx[1] === "connectingWallet" && ctx[4] && create_if_block_2$1(ctx);
  let if_block3 = ctx[1] === "connectedWallet" && ctx[4] && create_if_block_1$1(ctx);
  return {
    c() {
      div4 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      h4 = element("h4");
      t1 = text(t1_value);
      t2 = space();
      div0 = element("div");
      create_component(closebutton.$$.fragment);
      t3 = space();
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      if (if_block3)
        if_block3.c();
      attr(h4, "class", "header-heading svelte-37ahne");
      attr(div0, "class", "button-container svelte-37ahne");
      attr(div1, "class", "header svelte-37ahne");
      attr(div2, "class", "scroll-container svelte-37ahne");
      attr(div3, "class", "content svelte-37ahne");
      attr(div4, "class", "container svelte-37ahne");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      if (if_block0)
        if_block0.m(div4, null);
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      append(div1, h4);
      append(h4, t1);
      append(div1, t2);
      append(div1, div0);
      mount_component(closebutton, div0, null);
      append(div3, t3);
      append(div3, div2);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t4);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t5);
      if (if_block3)
        if_block3.m(div2, null);
      ctx[18](div2);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[8] >= 809) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div4, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty & 1046) && t1_value !== (t1_value = ctx2[10](`connect.${ctx2[1]}.header`, {
        default: en.connect[ctx2[1]].header,
        values: {
          connectionRejected: ctx2[2],
          wallet: ctx2[4] && ctx2[4].label
        }
      }) + ""))
        set_data(t1, t1_value);
      if (ctx2[1] === "selectingWallet") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[1] === "connectingWallet" && ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 18) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t5);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[1] === "connectedWallet" && ctx2[4]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 18) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$1(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(closebutton.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(closebutton.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      destroy_component2(closebutton);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      ctx[18](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  add_render_callback(ctx[16]);
  let if_block = (!ctx[0] || ctx[0] && !ctx[0].disableModals) && create_if_block$1(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(window, "resize", ctx[16]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!ctx2[0] || ctx2[0] && !ctx2[0].disableModals) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(10, $_ = $$value));
  let { autoSelect } = $$props;
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  const { walletModules } = state.get();
  let connectionRejected = false;
  let wallets = [];
  let selectedWallet;
  let agreed;
  let connectingWalletLabel;
  let connectingErrorMessage;
  let windowWidth;
  let scrollContainer;
  const walletToAutoSelect = autoSelect && walletModules.find(({ label }) => label.toLowerCase() === autoSelect.label.toLowerCase());
  async function selectWallet({ label, icon, getInterface }) {
    $$invalidate(6, connectingWalletLabel = label);
    try {
      const existingWallet = state.get().wallets.find((wallet2) => wallet2.label === label);
      if (existingWallet) {
        addWallet(existingWallet);
        try {
          await selectAccounts(existingWallet.provider);
          setTimeout(() => setStep("connectedWallet"), 1);
        } catch (error) {
          const { code } = error;
          if (code === ProviderRpcErrorCode.UNSUPPORTED_METHOD || code === ProviderRpcErrorCode.DOES_NOT_EXIST) {
            connectWallet$.next({
              inProgress: false,
              actionRequired: existingWallet.label
            });
          }
        }
        $$invalidate(4, selectedWallet = existingWallet);
        return;
      }
      const { chains: chains2 } = state.get();
      const { provider, instance: instance2 } = await getInterface({
        chains: chains2,
        BigNumber,
        EventEmitter: import_eventemitter3.default,
        appMetadata: appMetadata2
      });
      const loadedIcon = await icon;
      $$invalidate(4, selectedWallet = {
        label,
        icon: loadedIcon,
        provider,
        instance: instance2,
        accounts: [],
        chains: [{ namespace: "evm", id: "0x1" }]
      });
      $$invalidate(7, connectingErrorMessage = "");
      setTimeout(() => setStep("connectingWallet"), 1);
    } catch (error) {
      const { message } = error;
      $$invalidate(7, connectingErrorMessage = message);
      scrollToTop();
    } finally {
      $$invalidate(6, connectingWalletLabel = "");
    }
  }
  function deselectWallet() {
    $$invalidate(4, selectedWallet = null);
  }
  function updateSelectedWallet(update2) {
    $$invalidate(4, selectedWallet = __spreadValues(__spreadValues({}, selectedWallet), update2));
  }
  async function autoSelectWallet(wallet2) {
    const { getIcon, getInterface, label } = wallet2;
    const icon = getIcon();
    selectWallet({ label, icon, getInterface });
  }
  async function loadWalletsForSelection() {
    $$invalidate(3, wallets = walletModules.map(({ getIcon, getInterface, label }) => {
      return { label, icon: getIcon(), getInterface };
    }));
  }
  function close() {
    connectWallet$.next({ inProgress: false });
  }
  async function connectWallet() {
    $$invalidate(2, connectionRejected = false);
    const { provider, label } = selectedWallet;
    try {
      const [address] = await requestAccounts(provider);
      if (!address) {
        return;
      }
      const chain2 = await getChainId(provider);
      const update2 = {
        accounts: [{ address, ens: null, balance: null }],
        chains: [{ namespace: "evm", id: chain2 }]
      };
      addWallet(__spreadValues(__spreadValues({}, selectedWallet), update2));
      trackWallet(provider, label);
      updateSelectedWallet(update2);
      setStep("connectedWallet");
    } catch (error) {
      const { code } = error;
      if (code === ProviderRpcErrorCode.ACCOUNT_ACCESS_REJECTED) {
        $$invalidate(2, connectionRejected = true);
        return;
      }
      if (code === ProviderRpcErrorCode.ACCOUNT_ACCESS_ALREADY_REQUESTED) {
        return;
      }
    }
  }
  async function updateAccountDetails() {
    const { accounts: accounts2, chains: selectedWalletChains } = selectedWallet;
    const appChains = state.get().chains;
    const [connectedWalletChain] = selectedWalletChains;
    const appChain = appChains.find(({ namespace, id: id2 }) => namespace === connectedWalletChain.namespace && id2 === connectedWalletChain.id);
    const { address } = accounts2[0];
    let { balance: balance2, ens: ens2 } = accounts2[0];
    if (balance2 === null) {
      getBalance(address, appChain).then((balance3) => {
        updateAccount(selectedWallet.label, address, { balance: balance3 });
      });
    }
    if (ens2 === null && validEnsChain(connectedWalletChain.id)) {
      getEns(address, appChain).then((ens3) => {
        updateAccount(selectedWallet.label, address, { ens: ens3 });
      });
    }
    setTimeout(() => connectWallet$.next({ inProgress: false }), 1500);
  }
  let step = "selectingWallet";
  function setStep(update2) {
    $$invalidate(1, step = update2);
  }
  function scrollToTop() {
    scrollContainer && scrollContainer.scrollTo(0, 0);
  }
  function onwindowresize() {
    $$invalidate(8, windowWidth = window.innerWidth);
  }
  function agreement_agreed_binding(value) {
    agreed = value;
    $$invalidate(5, agreed);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollContainer = $$value;
      $$invalidate(9, scrollContainer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("autoSelect" in $$props2)
      $$invalidate(0, autoSelect = $$props2.autoSelect);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      switch (step) {
        case "selectingWallet": {
          if (walletToAutoSelect) {
            autoSelectWallet(walletToAutoSelect);
          } else {
            loadWalletsForSelection();
          }
          break;
        }
        case "connectingWallet": {
          connectWallet();
          break;
        }
        case "connectedWallet": {
          updateAccountDetails();
          break;
        }
      }
    }
  };
  return [
    autoSelect,
    step,
    connectionRejected,
    wallets,
    selectedWallet,
    agreed,
    connectingWalletLabel,
    connectingErrorMessage,
    windowWidth,
    scrollContainer,
    $_,
    selectWallet,
    deselectWallet,
    close,
    connectWallet,
    setStep,
    onwindowresize,
    agreement_agreed_binding,
    div2_binding
  ];
}
var Index$1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$4, create_fragment$4, safe_not_equal2, { autoSelect: 0 }, add_css$4);
  }
};
function add_css$3(target) {
  append_styles(target, "svelte-gp520o", ".container.svelte-gp520o{position:relative;padding:var(--onboard-spacing-4, var(--spacing-4));font-family:var(--onboard-font-family-normal, var(--font-family-normal));line-height:16px;font-size:var(--onboard-font-size-5, var(--font-size-5))}.close.svelte-gp520o{position:absolute;top:var(--onboard-spacing-5, var(--spacing-5));right:var(--onboard-spacing-5, var(--spacing-5));padding:0.5rem}h4.svelte-gp520o{font-size:var(--onboard-font-size-3, var(--font-size-3));margin:var(--onboard-spacing-4, var(--spacing-4)) 0}p.svelte-gp520o{margin:0 0 var(--onboard-spacing-4, var(--spacing-4)) 0;max-width:488px}");
}
function create_default_slot$1(ctx) {
  let div1;
  let h4;
  let t0_value = ctx[0]("modals.switchChain.heading", { default: en.modals.switchChain.heading }) + "";
  let t0;
  let t1;
  let p0;
  let t2_value = ctx[0]("modals.switchChain.paragraph1", {
    default: en.modals.switchChain.paragraph1,
    values: {
      app: ctx[1] && ctx[1].name || "This app",
      nextNetworkName: ctx[2]
    }
  }) + "";
  let t2;
  let t3;
  let p1;
  let t4_value = ctx[0]("modals.switchChain.paragraph2", {
    default: en.modals.switchChain.paragraph2
  }) + "";
  let t4;
  let t5;
  let div0;
  let closebutton;
  let current;
  let mounted;
  let dispose;
  closebutton = new CloseButton({});
  return {
    c() {
      div1 = element("div");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      p0 = element("p");
      t2 = text(t2_value);
      t3 = space();
      p1 = element("p");
      t4 = text(t4_value);
      t5 = space();
      div0 = element("div");
      create_component(closebutton.$$.fragment);
      attr(h4, "class", "svelte-gp520o");
      attr(p0, "class", "svelte-gp520o");
      attr(p1, "class", "svelte-gp520o");
      attr(div0, "class", "close svelte-gp520o");
      attr(div1, "class", "container svelte-gp520o");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, h4);
      append(h4, t0);
      append(div1, t1);
      append(div1, p0);
      append(p0, t2);
      append(div1, t3);
      append(div1, p1);
      append(p1, t4);
      append(div1, t5);
      append(div1, div0);
      mount_component(closebutton, div0, null);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0]("modals.switchChain.heading", { default: en.modals.switchChain.heading }) + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0]("modals.switchChain.paragraph1", {
        default: en.modals.switchChain.paragraph1,
        values: {
          app: ctx2[1] && ctx2[1].name || "This app",
          nextNetworkName: ctx2[2]
        }
      }) + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 1) && t4_value !== (t4_value = ctx2[0]("modals.switchChain.paragraph2", {
        default: en.modals.switchChain.paragraph2
      }) + ""))
        set_data(t4, t4_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(closebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(closebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component2(closebutton);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      close: ctx[3],
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 33) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(modal, detaching);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $switchChainModal$;
  let $_;
  component_subscribe($$self, switchChainModal$, ($$value) => $$invalidate(4, $switchChainModal$ = $$value));
  component_subscribe($$self, X, ($$value) => $$invalidate(0, $_ = $$value));
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  const nextNetworkName = $switchChainModal$.chain.label;
  function close() {
    switchChainModal$.next(null);
  }
  return [$_, appMetadata2, nextNetworkName, close];
}
var SwitchChain = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$3, create_fragment$3, safe_not_equal2, {}, add_css$3);
  }
};
function add_css$2(target) {
  append_styles(target, "svelte-x7wzte", ".icon.svelte-x7wzte{display:flex;border-radius:50px;box-sizing:border-box;color:var(--onboard-primary-500, var(--primary-500))}");
}
function create_fragment$2(ctx) {
  let div;
  let div_style_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", "icon svelte-x7wzte");
      attr(div, "style", div_style_value = `width: ${ctx[0]}px; height: ${ctx[0]}px;`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = infoIcon;
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && div_style_value !== (div_style_value = `width: ${ctx2[0]}px; height: ${ctx2[0]}px;`)) {
        attr(div, "style", div_style_value);
      }
    },
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let { size = 20 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
  };
  return [size];
}
var InfoIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$2, create_fragment$2, safe_not_equal2, { size: 0 }, add_css$2);
  }
};
function add_css$1(target) {
  append_styles(target, "svelte-14tlaaq", ".content.svelte-14tlaaq{padding:1rem;width:300px;font-family:var(--onboard-font-family-normal, var(--font-family-normal));font-size:var(--onboard-font-size-5, var(--font-size-5));line-height:24px}.icon-container.svelte-14tlaaq{display:flex;justify-content:center;align-items:center;width:3rem;height:3rem;background-color:var(--onboard-primary-100, var(--primary-100));border-radius:24px}h4.svelte-14tlaaq{margin:1.5rem 0 0.5rem 0;font-weight:700}p.svelte-14tlaaq{margin:0;font-weight:400}a.svelte-14tlaaq{font-weight:700}button.svelte-14tlaaq{margin-top:1.5rem;width:100%;background-color:var(--onboard-gray-500, var(--gray-500));font-weight:700;line-height:16px;color:var(--onboard-white, var(--white));justify-content:center}");
}
function create_default_slot(ctx) {
  let div1;
  let div0;
  let infoicon;
  let t0;
  let h4;
  let t1_value = ctx[1]("modals.actionRequired.heading", { values: { wallet: ctx[0] } }) + "";
  let t1;
  let t2;
  let p2;
  let t3_value = ctx[1]("modals.actionRequired.paragraph") + "";
  let t3;
  let t4;
  let a2;
  let t5_value = ctx[1]("modals.actionRequired.linkText") + "";
  let t5;
  let t6;
  let button;
  let t7_value = ctx[1]("modals.actionRequired.buttonText") + "";
  let t7;
  let current;
  let mounted;
  let dispose;
  infoicon = new InfoIcon({});
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(infoicon.$$.fragment);
      t0 = space();
      h4 = element("h4");
      t1 = text(t1_value);
      t2 = space();
      p2 = element("p");
      t3 = text(t3_value);
      t4 = space();
      a2 = element("a");
      t5 = text(t5_value);
      t6 = space();
      button = element("button");
      t7 = text(t7_value);
      attr(div0, "class", "icon-container svelte-14tlaaq");
      attr(h4, "class", "svelte-14tlaaq");
      attr(a2, "href", "https://blocknative.com/blog");
      attr(a2, "target", "_blank");
      attr(a2, "rel", "noreferrer noopener");
      attr(a2, "class", "svelte-14tlaaq");
      attr(p2, "class", "svelte-14tlaaq");
      attr(button, "class", "svelte-14tlaaq");
      attr(div1, "class", "content svelte-14tlaaq");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(infoicon, div0, null);
      append(div1, t0);
      append(div1, h4);
      append(h4, t1);
      append(div1, t2);
      append(div1, p2);
      append(p2, t3);
      append(p2, t4);
      append(p2, a2);
      append(a2, t5);
      append(div1, t6);
      append(div1, button);
      append(button, t7);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 3) && t1_value !== (t1_value = ctx2[1]("modals.actionRequired.heading", { values: { wallet: ctx2[0] } }) + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 2) && t3_value !== (t3_value = ctx2[1]("modals.actionRequired.paragraph") + ""))
        set_data(t3, t3_value);
      if ((!current || dirty & 2) && t5_value !== (t5_value = ctx2[1]("modals.actionRequired.linkText") + ""))
        set_data(t5, t5_value);
      if ((!current || dirty & 2) && t7_value !== (t7_value = ctx2[1]("modals.actionRequired.buttonText") + ""))
        set_data(t7, t7_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(infoicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(infoicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component2(infoicon);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      close: ctx[2],
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 11) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(modal, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(1, $_ = $$value));
  let { wallet: wallet2 } = $$props;
  function close() {
    connectWallet$.next({ inProgress: false, actionRequired: "" });
  }
  $$self.$$set = ($$props2) => {
    if ("wallet" in $$props2)
      $$invalidate(0, wallet2 = $$props2.wallet);
  };
  return [wallet2, $_, close];
}
var ActionRequired = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$1, create_fragment$1, safe_not_equal2, { wallet: 0 }, add_css$1);
  }
};
function add_css(target) {
  append_styles(target, "svelte-seg8z3", `input, textarea{background:var(--onboard-white, var(--white))}input, textarea, select{width:100%;padding:0.5rem 1rem;outline:2px solid var(--onboard-gray-200, var(--gray-200));border:none;border-radius:8px;font-size:1rem;line-height:1.5;color:var(--onboard-gray-600, var(--gray-600));transition:all 200ms ease-in-out}input[type='checkbox']{-webkit-appearance:none;width:auto;background-color:var(--onboard-white, var(--white));outline:1px solid var(--onboard-gray-300, var(--gray-300));border:none;padding:0.5em;border-radius:3px;display:flex;justify-content:center;align-items:center;position:relative;cursor:pointer}input[type='checkbox']:hover{border-color:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    )}input[type='checkbox']:checked{background-color:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    );border-color:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    );color:var(--onboard-checkbox-color, var(--onboard-white, var(--white)))}input[type='checkbox']:checked:after{content:url("data:image/svg+xml,%3Csvg width='0.885em' height='0.6em' viewBox='0 0 14 11' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0 6L5 11L14 2L12.59 0.58L5 8.17L1.41 4.59L0 6Z' fill='white'/%3E%3C/svg%3E");font-size:12px;position:absolute;color:var(--onboard-checkbox-color, var(--onboard-white, var(--white)))}input:hover, textarea:hover, select:hover{border-color:var(
      --onboard-checkbox-color,
      var(--onboard-white, var(--white))
    )}input:focus, textarea.focus, select:focus{border-color:var(--onboard-primary-500, var(--primary-500));box-shadow:0 0 1px 1px
      var(
        --onboard-checkbox-background,
        var(--onboard-primary-500, var(--primary-500))
      );box-shadow:0 0 0 1px -moz-mac-focusring}input:disabled, textarea:disabled, select:disabled{background-color:var(--gray-100)}input::-moz-focus-inner{outline:0;padding:0;margin-top:-2px;margin-bottom:-2px}::-webkit-input-placeholder{color:var(--gray-300)}::-moz-placeholder{color:var(--gray-300)}:-ms-input-placeholder{color:var(--gray-300)}:-moz-placeholder{color:var(--gray-300)}a{color:var(
      --onboard-link-color,
      var(--onboard-primary-500, var(--primary-500))
    );text-decoration:none}button{display:flex;align-items:center;padding:calc(var(--onboard-spacing-4, var(--spacing-4)) - 1px);border-radius:24px;cursor:pointer;font:inherit;border:none}.onboard-button-primary{background:var(--onboard-white, var(--white));padding:calc(var(--onboard-spacing-5, var(--spacing-5)) - 1px)
      calc(var(--onboard-spacing-4, var(--spacing-4)) - 1px);color:var(--onboard-gray-500, var(--gray-500));font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));border:1px solid var(--onboard-gray-500, var(--gray-500));font-weight:700}`);
}
function create_if_block_2(ctx) {
  let connect3;
  let current;
  connect3 = new Index$1({
    props: {
      autoSelect: ctx[0].autoSelect
    }
  });
  return {
    c() {
      create_component(connect3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(connect3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const connect_changes = {};
      if (dirty & 1)
        connect_changes.autoSelect = ctx2[0].autoSelect;
      connect3.$set(connect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(connect3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(connect3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(connect3, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let actionrequired;
  let current;
  actionrequired = new ActionRequired({
    props: {
      wallet: ctx[0].actionRequired
    }
  });
  return {
    c() {
      create_component(actionrequired.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actionrequired, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actionrequired_changes = {};
      if (dirty & 1)
        actionrequired_changes.wallet = ctx2[0].actionRequired;
      actionrequired.$set(actionrequired_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionrequired.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionrequired.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(actionrequired, detaching);
    }
  };
}
function create_if_block(ctx) {
  let switchchain;
  let current;
  switchchain = new SwitchChain({});
  return {
    c() {
      create_component(switchchain.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switchchain, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(switchchain.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switchchain.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(switchchain, detaching);
    }
  };
}
function create_fragment(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[0].inProgress && create_if_block_2(ctx);
  let if_block1 = ctx[0].actionRequired && create_if_block_1(ctx);
  let if_block2 = ctx[1] && create_if_block();
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty2();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0].inProgress) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[0].actionRequired) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block2) {
          if (dirty & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $connectWallet$;
  let $switchChainModal$;
  component_subscribe($$self, connectWallet$, ($$value) => $$invalidate(0, $connectWallet$ = $$value));
  component_subscribe($$self, switchChainModal$, ($$value) => $$invalidate(1, $switchChainModal$ = $$value));
  return [$connectWallet$, $switchChainModal$];
}
var Index = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance, create_fragment, safe_not_equal2, {}, add_css);
  }
};
var API = {
  connectWallet: connect$1,
  disconnectWallet: disconnect,
  setChain,
  state: {
    get: state.get,
    select: state.select,
    actions: {
      setWalletModules
    }
  }
};
function init(options) {
  if (typeof window === "undefined")
    return API;
  if (options) {
    const error = validateInitOptions(options);
    if (error) {
      throw error;
    }
  }
  const { wallets, chains: chains2, appMetadata: appMetadata2 = null, i18n } = options;
  initialize(i18n);
  addChains(chains2);
  const { svelteInstance } = internalState$.getValue();
  if (svelteInstance) {
    console.warn("Re-initializing Onboard and resetting back to initial state");
    reset$.next();
  }
  const device = getDeviceInfo();
  const app = svelteInstance || mountApp();
  internalState$.next({
    appMetadata: appMetadata2,
    svelteInstance: app,
    device
  });
  setWalletModules(wallets);
  return API;
}
function mountApp() {
  class Onboard extends HTMLElement {
    constructor() {
      super();
    }
  }
  if (!customElements.get("onboard-v2")) {
    customElements.define("onboard-v2", Onboard);
  }
  const styleEl = document.createElement("style");
  styleEl.innerHTML = `
    ${SofiaProRegular}
  `;
  document.body.appendChild(styleEl);
  const onboard = document.createElement("onboard-v2");
  const target = onboard.attachShadow({ mode: "open" });
  onboard.style.all = "initial";
  target.innerHTML = `
      <style>
        :host {  
          /* COLORS */
          --white: white;
          --black: black;
          --primary-1: #2F80ED;
          --primary-100: #eff1fc;
          --primary-200: #d0d4f7;
          --primary-300: #b1b8f2;
          --primary-400: #929bed;
          --primary-500: #6370e5;
          --primary-600: #454ea0;
          --primary-700: #323873;
          --gray-100: #ebebed;
          --gray-200: #c2c4c9;
          --gray-300: #999ca5;
          --gray-400: #707481;
          --gray-500: #33394b;
          --gray-600: #242835;
          --gray-700: #1a1d26;
          --success-100: #d1fae3;
          --success-200: #baf7d5;
          --success-300: #a4f4c6;
          --success-400: #8df2b8;
          --success-500: #5aec99;
          --success-600: #18ce66;
          --success-700: #129b4d;
          --danger-100: #ffe5e6;
          --danger-200: #ffcccc;
          --danger-300: #ffb3b3;
          --danger-400: #ff8080;
          --danger-500: #ff4f4f;
          --danger-600: #cc0000;
          --danger-700: #660000;
          --warning-100: #ffefcc;
          --warning-200: #ffe7b3;
          --warning-300: #ffd780;
          --warning-400: #ffc74c;
          --warning-500: #ffaf00;
          --warning-600: #cc8c00;
          --warning-700: #664600;
  
          /* FONTS */
          --font-family-normal: Sofia Pro;
  
          --font-size-1: 3rem;
          --font-size-2: 2.25rem;
          --font-size-3: 1.5rem;
          --font-size-4: 1.25rem;
          --font-size-5: 1rem;
          --font-size-6: .875rem;
          --font-size-7: .75rem;
  
          --font-line-height-1: 24px;
          --font-line-height-2: 20px;
          --font-line-height-3: 16px;
          --font-line-height-4: 12px;
  
          /* SPACING */
          --spacing-1: 3rem;
          --spacing-2: 2rem;
          --spacing-3: 1.5rem;
          --spacing-4: 1rem;
          --spacing-5: 0.5rem;
  
          /* SHADOWS */
          --shadow-1: 0px 4px 12px rgba(0, 0, 0, 0.1);
          --shadow-2: inset 0px -1px 0px rgba(0, 0, 0, 0.1);

          --modal-z-index: 10;
        }
      </style>
    `;
  document.body.appendChild(onboard);
  const app = new Index({
    target
  });
  return app;
}

export {
  init
};
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=chunk-4PB6HZ4E.js.map
