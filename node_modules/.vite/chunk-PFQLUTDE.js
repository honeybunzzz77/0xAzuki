import {
  clsx_m_exports,
  esm5_exports,
  init_clsx_m,
  init_esm5,
  init_operators,
  operators_exports,
  require_bind_decorator,
  require_sha256
} from "./chunk-Y3S2DEQ6.js";
import {
  require_eth_query,
  require_fast_safe_stringify,
  require_pify,
  require_safe_event_emitter,
  require_safe_event_emitter2,
  require_subscriptionManager
} from "./chunk-AYJGFISQ.js";
import {
  require_js
} from "./chunk-KZZKH6LX.js";
import {
  buffer_exports,
  init_buffer as init_buffer2
} from "./chunk-7SH6SCUR.js";
import {
  Buffer,
  __commonJS,
  __esm,
  __export,
  init_buffer,
  init_virtual_process_polyfill,
  process
} from "./chunk-QYANIK43.js";

// node_modules/walletlink/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/walletlink/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer = window.Buffer;
        } else {
          Buffer = (init_buffer2(), buffer_exports).Buffer;
        }
      } catch (e3) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j3, w3;
        var off = 0;
        if (endian === "be") {
          for (i3 = number.length - 1, j3 = 0; i3 >= 0; i3 -= 3) {
            w3 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
            this.words[j3] |= w3 << off & 67108863;
            this.words[j3 + 1] = w3 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j3 = 0; i3 < number.length; i3 += 3) {
            w3 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
            this.words[j3] |= w3 << off & 67108863;
            this.words[j3 + 1] = w3 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c3 = string.charCodeAt(index);
        if (c3 >= 48 && c3 <= 57) {
          return c3 - 48;
        } else if (c3 >= 65 && c3 <= 70) {
          return c3 - 55;
        } else if (c3 >= 97 && c3 <= 102) {
          return c3 - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r3 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r3;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var off = 0;
        var j3 = 0;
        var w3;
        if (endian === "be") {
          for (i3 = number.length - 1; i3 >= start; i3 -= 2) {
            w3 = parseHexByte(number, start, i3) << off;
            this.words[j3] |= w3 & 67108863;
            if (off >= 18) {
              off -= 18;
              j3 += 1;
              this.words[j3] |= w3 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i3 = parseLength % 2 === 0 ? start + 1 : start; i3 < number.length; i3 += 2) {
            w3 = parseHexByte(number, start, i3) << off;
            this.words[j3] |= w3 & 67108863;
            if (off >= 18) {
              off -= 18;
              j3 += 1;
              this.words[j3] |= w3 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r3 = 0;
        var b3 = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r3 *= mul;
          if (c3 >= 49) {
            b3 = c3 - 49 + 10;
          } else if (c3 >= 17) {
            b3 = c3 - 17 + 10;
          } else {
            b3 = c3;
          }
          assert(c3 >= 0 && b3 < mul, "Invalid character");
          r3 += b3;
        }
        return r3;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i3 = start; i3 < end; i3 += limbLen) {
          word = parseBase(number, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i3, number.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r3 = new BN(null);
        this.copy(r3);
        return r3;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e3) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w3 = this.words[i3];
            var word = ((w3 << off | carry) & 16777215).toString(16);
            carry = w3 >>> 24 - off & 16777215;
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r3 = c3.modrn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer) {
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer, endian, length);
        };
      }
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i3 = 0, shift = 0; i3 < this.length; i3++) {
          var word = this.words[i3] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i3 = 0, shift = 0; i3 < this.length; i3++) {
          var word = this.words[i3] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w3) {
          return 32 - Math.clz32(w3);
        };
      } else {
        BN.prototype._countBits = function _countBits(w3) {
          var t3 = w3;
          var r3 = 0;
          if (t3 >= 4096) {
            r3 += 13;
            t3 >>>= 13;
          }
          if (t3 >= 64) {
            r3 += 7;
            t3 >>>= 7;
          }
          if (t3 >= 8) {
            r3 += 4;
            t3 >>>= 4;
          }
          if (t3 >= 2) {
            r3 += 2;
            t3 >>>= 2;
          }
          return r3 + t3;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w3) {
        if (w3 === 0)
          return 26;
        var t3 = w3;
        var r3 = 0;
        if ((t3 & 8191) === 0) {
          r3 += 13;
          t3 >>>= 13;
        }
        if ((t3 & 127) === 0) {
          r3 += 7;
          t3 >>>= 7;
        }
        if ((t3 & 15) === 0) {
          r3 += 4;
          t3 >>>= 4;
        }
        if ((t3 & 3) === 0) {
          r3 += 2;
          t3 >>>= 2;
        }
        if ((t3 & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN.prototype.bitLength = function bitLength() {
        var w3 = this.words[this.length - 1];
        var hi = this._countBits(w3);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w3 = new Array(num.bitLength());
        for (var bit = 0; bit < w3.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w3[bit] = num.words[off] >>> wbit & 1;
        }
        return w3;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r3 = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b3 = this._zeroBits(this.words[i3]);
          r3 += b3;
          if (b3 !== 26)
            break;
        }
        return r3;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i3 = 0; i3 < b3.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b3.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a3;
        var b3;
        if (this.length > num.length) {
          a3 = this;
          b3 = num;
        } else {
          a3 = num;
          b3 = this;
        }
        for (var i3 = 0; i3 < b3.length; i3++) {
          this.words[i3] = a3.words[i3] ^ b3.words[i3];
        }
        if (this !== a3) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = a3.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a3, b3;
        if (this.length > num.length) {
          a3 = this;
          b3 = num;
        } else {
          a3 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b3.length; i3++) {
          r3 = (a3.words[i3] | 0) + (b3.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r3 = (a3.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a3.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a3, b3;
        if (cmp > 0) {
          a3 = this;
          b3 = num;
        } else {
          a3 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b3.length; i3++) {
          r3 = (a3.words[i3] | 0) - (b3.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r3 = (a3.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        if (carry === 0 && i3 < a3.length && a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a3 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a3 = self.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r3 = a3 * b3;
        var lo = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo;
        for (var k3 = 1; k3 < len; k3++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j3 = Math.max(0, k3 - self.length + 1); j3 <= maxJ; j3++) {
            var i3 = k3 - j3 | 0;
            a3 = self.words[i3] | 0;
            b3 = num.words[j3] | 0;
            r3 = a3 * b3 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k3] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k3] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self, num, out) {
        var a3 = self.words;
        var b3 = num.words;
        var o3 = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a3[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a3[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a3[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a3[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a4 = a3[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a3[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a3[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a3[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a3[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a3[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b3[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b3[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b3[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o3[0] = w0;
        o3[1] = w1;
        o3[2] = w22;
        o3[3] = w3;
        o3[4] = w4;
        o3[5] = w5;
        o3[6] = w6;
        o3[7] = w7;
        o3[8] = w8;
        o3[9] = w9;
        o3[10] = w10;
        o3[11] = w11;
        o3[12] = w12;
        o3[13] = w13;
        o3[14] = w14;
        o3[15] = w15;
        o3[16] = w16;
        o3[17] = w17;
        o3[18] = w18;
        if (c3 !== 0) {
          o3[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k3 = 0; k3 < out.length - 1; k3++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j3 = Math.max(0, k3 - self.length + 1); j3 <= maxJ; j3++) {
            var i3 = k3 - j3;
            var a3 = self.words[i3] | 0;
            var b3 = num.words[j3] | 0;
            var r3 = a3 * b3;
            var lo = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k3] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k3] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self, num, out) {
        return bigMulTo(self, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x3, y3) {
        this.x = x3;
        this.y = y3;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t3 = new Array(N2);
        var l3 = BN.prototype._countBits(N2) - 1;
        for (var i3 = 0; i3 < N2; i3++) {
          t3[i3] = this.revBin(i3, l3, N2);
        }
        return t3;
      };
      FFTM.prototype.revBin = function revBin(x3, l3, N2) {
        if (x3 === 0 || x3 === N2 - 1)
          return x3;
        var rb = 0;
        for (var i3 = 0; i3 < l3; i3++) {
          rb |= (x3 & 1) << l3 - i3 - 1;
          x3 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i3 = 0; i3 < N2; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s3 = 1; s3 < N2; s3 <<= 1) {
          var l3 = s3 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l3);
          var itwdf = Math.sin(2 * Math.PI / l3);
          for (var p3 = 0; p3 < N2; p3 += l3) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j3 = 0; j3 < s3; j3++) {
              var re = rtws[p3 + j3];
              var ie = itws[p3 + j3];
              var ro = rtws[p3 + j3 + s3];
              var io = itws[p3 + j3 + s3];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p3 + j3] = re + ro;
              itws[p3 + j3] = ie + io;
              rtws[p3 + j3 + s3] = re - ro;
              itws[p3 + j3 + s3] = ie - io;
              if (j3 !== l3) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m3) {
        var N2 = Math.max(m3, n2) | 1;
        var odd = N2 & 1;
        var i3 = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1)
          return;
        for (var i3 = 0; i3 < N2 / 2; i3++) {
          var t3 = rws[i3];
          rws[i3] = rws[N2 - i3 - 1];
          rws[N2 - i3 - 1] = t3;
          t3 = iws[i3];
          iws[i3] = -iws[N2 - i3 - 1];
          iws[N2 - i3 - 1] = -t3;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i3 = 0; i3 < N2 / 2; i3++) {
          var w3 = Math.round(ws[2 * i3 + 1] / N2) * 8192 + Math.round(ws[2 * i3] / N2) + carry;
          ws[i3] = w3 & 67108863;
          if (w3 < 67108864) {
            carry = 0;
          } else {
            carry = w3 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N2; ++i3) {
          rws[i3] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i3 = 0; i3 < N2; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x3, y3, out) {
        var N2 = 2 * this.guessLen13b(x3.length, y3.length);
        var rbt = this.makeRBT(N2);
        var _3 = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x3.words, x3.length, rws, N2);
        this.convert13b(y3.words, y3.length, nrws, N2);
        this.transform(rws, _3, rwst, iwst, N2, rbt);
        this.transform(nrws, _3, nrwst, niwst, N2, rbt);
        for (var i3 = 0; i3 < N2; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _3, N2, rbt);
        this.conjugate(rmws, _3, N2);
        this.normalize13b(rmws, N2);
        out.negative = x3.negative ^ y3.negative;
        out.length = x3.length + y3.length;
        return out._strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w3 = (this.words[i3] | 0) * num;
          var lo = (w3 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w3 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w3 = toBitArray(num);
        if (w3.length === 0)
          return new BN(1);
        var res = this;
        for (var i3 = 0; i3 < w3.length; i3++, res = res.sqr()) {
          if (w3[i3] !== 0)
            break;
        }
        if (++i3 < w3.length) {
          for (var q3 = res.sqr(); i3 < w3.length; i3++, q3 = q3.sqr()) {
            if (w3[i3] === 0)
              continue;
            res = res.mul(q3);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s3 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i3;
        if (r3 !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c3 = (this.words[i3] | 0) - newCarry << r3;
            this.words[i3] = c3 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s3 !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s3] = this.words[i3];
          }
          for (i3 = 0; i3 < s3; i3++) {
            this.words[i3] = 0;
          }
          this.length += s3;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r3 = bits % 26;
        var s3 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h3 -= s3;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i3 = 0; i3 < s3; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s3;
        }
        if (s3 === 0) {
        } else if (this.length > s3) {
          this.length -= s3;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s3];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h3); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s3 = (bit - r3) / 26;
        var q3 = 1 << r3;
        if (this.length <= s3)
          return false;
        var w3 = this.words[s3];
        return !!(w3 & q3);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s3 = (bits - r3) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s3) {
          return this;
        }
        if (r3 !== 0) {
          s3++;
        }
        this.length = Math.min(s3, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i3;
        this._expand(len);
        var w3;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w3 = (this.words[i3 + shift] | 0) + carry;
          var right = (num.words[i3] | 0) * mul;
          w3 -= right & 67108863;
          carry = (w3 >> 26) - (right / 67108864 | 0);
          this.words[i3 + shift] = w3 & 67108863;
        }
        for (; i3 < this.length - shift; i3++) {
          w3 = (this.words[i3 + shift] | 0) + carry;
          carry = w3 >> 26;
          this.words[i3 + shift] = w3 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w3 = -(this.words[i3] | 0) + carry;
          carry = w3 >> 26;
          this.words[i3] = w3 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a3 = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a3.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m3 = a3.length - b3.length;
        var q3;
        if (mode !== "mod") {
          q3 = new BN(null);
          q3.length = m3 + 1;
          q3.words = new Array(q3.length);
          for (var i3 = 0; i3 < q3.length; i3++) {
            q3.words[i3] = 0;
          }
        }
        var diff = a3.clone()._ishlnsubmul(b3, 1, m3);
        if (diff.negative === 0) {
          a3 = diff;
          if (q3) {
            q3.words[m3] = 1;
          }
        }
        for (var j3 = m3 - 1; j3 >= 0; j3--) {
          var qj = (a3.words[b3.length + j3] | 0) * 67108864 + (a3.words[b3.length + j3 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a3._ishlnsubmul(b3, qj, j3);
          while (a3.negative !== 0) {
            qj--;
            a3.negative = 0;
            a3._ishlnsubmul(b3, 1, j3);
            if (!a3.isZero()) {
              a3.negative ^= 1;
            }
          }
          if (q3) {
            q3.words[j3] = qj;
          }
        }
        if (q3) {
          q3._strip();
        }
        a3._strip();
        if (mode !== "div" && shift !== 0) {
          a3.iushrn(shift);
        }
        return {
          div: q3 || null,
          mod: a3
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p3 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p3 * acc + (this.words[i3] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w3 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w3 / num | 0;
          carry = w3 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p3) {
        assert(p3.negative === 0);
        assert(!p3.isZero());
        var x3 = this;
        var y3 = p3.clone();
        if (x3.negative !== 0) {
          x3 = x3.umod(p3);
        } else {
          x3 = x3.clone();
        }
        var A3 = new BN(1);
        var B2 = new BN(0);
        var C2 = new BN(0);
        var D2 = new BN(1);
        var g3 = 0;
        while (x3.isEven() && y3.isEven()) {
          x3.iushrn(1);
          y3.iushrn(1);
          ++g3;
        }
        var yp = y3.clone();
        var xp = x3.clone();
        while (!x3.isZero()) {
          for (var i3 = 0, im = 1; (x3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x3.iushrn(i3);
            while (i3-- > 0) {
              if (A3.isOdd() || B2.isOdd()) {
                A3.iadd(yp);
                B2.isub(xp);
              }
              A3.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1; (y3.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            y3.iushrn(j3);
            while (j3-- > 0) {
              if (C2.isOdd() || D2.isOdd()) {
                C2.iadd(yp);
                D2.isub(xp);
              }
              C2.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x3.cmp(y3) >= 0) {
            x3.isub(y3);
            A3.isub(C2);
            B2.isub(D2);
          } else {
            y3.isub(x3);
            C2.isub(A3);
            D2.isub(B2);
          }
        }
        return {
          a: C2,
          b: D2,
          gcd: y3.iushln(g3)
        };
      };
      BN.prototype._invmp = function _invmp(p3) {
        assert(p3.negative === 0);
        assert(!p3.isZero());
        var a3 = this;
        var b3 = p3.clone();
        if (a3.negative !== 0) {
          a3 = a3.umod(p3);
        } else {
          a3 = a3.clone();
        }
        var x1 = new BN(1);
        var x22 = new BN(0);
        var delta = b3.clone();
        while (a3.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a3.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1; (b3.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            b3.iushrn(j3);
            while (j3-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a3.cmp(b3) >= 0) {
            a3.isub(b3);
            x1.isub(x22);
          } else {
            b3.isub(a3);
            x22.isub(x1);
          }
        }
        var res;
        if (a3.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p3);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a3 = this.clone();
        var b3 = num.clone();
        a3.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a3.isEven() && b3.isEven(); shift++) {
          a3.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a3.isEven()) {
            a3.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r3 = a3.cmp(b3);
          if (r3 < 0) {
            var t3 = a3;
            a3 = b3;
            b3 = t3;
          } else if (r3 === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a3.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r3 = bit % 26;
        var s3 = (bit - r3) / 26;
        var q3 = 1 << r3;
        if (this.length <= s3) {
          this._expand(s3 + 1);
          this.words[s3] |= q3;
          return this;
        }
        var carry = q3;
        for (var i3 = s3; carry !== 0 && i3 < this.length; i3++) {
          var w3 = this.words[i3] | 0;
          w3 += carry;
          carry = w3 >>> 26;
          w3 &= 67108863;
          this.words[i3] = w3;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w3 = this.words[0] | 0;
          res = w3 === num ? 0 : w3 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a3 = this.words[i3] | 0;
          var b3 = num.words[i3] | 0;
          if (a3 === b3)
            continue;
          if (a3 < b3) {
            res = -1;
          } else if (a3 > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p3) {
        this.name = name;
        this.p = new BN(p3, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next = input.words[i3] | 0;
          input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w3 = num.words[i3] | 0;
          lo += w3 * 977;
          num.words[i3] = lo & 67108863;
          lo = w3 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m3) {
        if (typeof m3 === "string") {
          var prime = BN._prime(m3);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m3.gtn(1), "modulus must be greater than 1");
          this.m = m3;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a3) {
        assert(a3.negative === 0, "red works only with positives");
        assert(a3.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a3, b3) {
        assert((a3.negative | b3.negative) === 0, "red works only with positives");
        assert(a3.red && a3.red === b3.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a3) {
        if (this.prime)
          return this.prime.ireduce(a3)._forceRed(this);
        move(a3, a3.umod(this.m)._forceRed(this));
        return a3;
      };
      Red.prototype.neg = function neg(a3) {
        if (a3.isZero()) {
          return a3.clone();
        }
        return this.m.sub(a3)._forceRed(this);
      };
      Red.prototype.add = function add(a3, b3) {
        this._verify2(a3, b3);
        var res = a3.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a3, b3) {
        this._verify2(a3, b3);
        var res = a3.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a3, b3) {
        this._verify2(a3, b3);
        var res = a3.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a3, b3) {
        this._verify2(a3, b3);
        var res = a3.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a3, num) {
        this._verify1(a3);
        return this.imod(a3.ushln(num));
      };
      Red.prototype.imul = function imul(a3, b3) {
        this._verify2(a3, b3);
        return this.imod(a3.imul(b3));
      };
      Red.prototype.mul = function mul(a3, b3) {
        this._verify2(a3, b3);
        return this.imod(a3.mul(b3));
      };
      Red.prototype.isqr = function isqr(a3) {
        return this.imul(a3, a3.clone());
      };
      Red.prototype.sqr = function sqr(a3) {
        return this.mul(a3, a3);
      };
      Red.prototype.sqrt = function sqrt(a3) {
        if (a3.isZero())
          return a3.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a3, pow);
        }
        var q3 = this.m.subn(1);
        var s3 = 0;
        while (!q3.isZero() && q3.andln(1) === 0) {
          s3++;
          q3.iushrn(1);
        }
        assert(!q3.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c3 = this.pow(z2, q3);
        var r3 = this.pow(a3, q3.addn(1).iushrn(1));
        var t3 = this.pow(a3, q3);
        var m3 = s3;
        while (t3.cmp(one) !== 0) {
          var tmp = t3;
          for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert(i3 < m3);
          var b3 = this.pow(c3, new BN(1).iushln(m3 - i3 - 1));
          r3 = r3.redMul(b3);
          c3 = b3.redSqr();
          t3 = t3.redMul(c3);
          m3 = i3;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a3) {
        var inv = a3._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a3, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a3.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a3;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a3);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j3 = start - 1; j3 >= 0; j3--) {
            var bit = word >> j3 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j3 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m3) {
        Red.call(this, m3);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a3, b3) {
        if (a3.isZero() || b3.isZero()) {
          a3.words[0] = 0;
          a3.length = 1;
          return a3;
        }
        var t3 = a3.imul(b3);
        var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t3.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a3, b3) {
        if (a3.isZero() || b3.isZero())
          return new BN(0)._forceRed(this);
        var t3 = a3.mul(b3);
        var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t3.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a3) {
        var res = this.imod(a3._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/walletlink/node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/walletlink/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_3, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/walletlink/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/walletlink/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/walletlink/node_modules/eth-rpc-errors/dist/utils.js
var require_utils = __commonJS({
  "node_modules/walletlink/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/walletlink/node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/walletlink/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_1 = require_utils();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/walletlink/node_modules/eth-rpc-errors/dist/index.js
var require_dist = __commonJS({
  "node_modules/walletlink/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/walletlink/dist/connection/WalletLinkAnalytics.js
var require_WalletLinkAnalytics = __commonJS({
  "node_modules/walletlink/dist/connection/WalletLinkAnalytics.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkAnalytics = void 0;
    var WalletLinkAnalytics = class {
      sendEvent(_eventType, _eventProperties) {
      }
    };
    exports.WalletLinkAnalytics = WalletLinkAnalytics;
  }
});

// node_modules/walletlink/dist/init/events.js
var require_events = __commonJS({
  "node_modules/walletlink/dist/init/events.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EVENTS = void 0;
    exports.EVENTS = {
      REQUEST_CHILD_ETHEREUM_ACCOUNTS_START: "walletlink_sdk.request_child_ethereum_accounts.start",
      REQUEST_CHILD_ETHEREUM_ACCOUNTS_RESPONSE: "walletlink_sdk.request_child_ethereum_accounts.response",
      STARTED_CONNECTING: "walletlink_sdk.started.connecting",
      CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
      DISCONNECTED: "walletlink_sdk.disconnected",
      METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
      LINKED: "walletlink_sdk.linked",
      FAILURE: "walletlink_sdk.generic_failure",
      SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
      ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
      SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
      UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
      SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
      GENERAL_ERROR: "walletlink_sdk.general_error",
      WEB3_REQUEST: "walletlink_sdk.web3.request",
      WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
      WEB3_RESPONSE: "walletlink_sdk.web3.response",
      UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
    };
  }
});

// node_modules/walletlink/dist/init/WalletLinkAnalyticsAbstract.js
var require_WalletLinkAnalyticsAbstract = __commonJS({
  "node_modules/walletlink/dist/init/WalletLinkAnalyticsAbstract.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkAnalyticsAbstract = void 0;
    var WalletLinkAnalyticsAbstract = class {
    };
    exports.WalletLinkAnalyticsAbstract = WalletLinkAnalyticsAbstract;
  }
});

// node_modules/walletlink/dist/init/index.js
var require_init = __commonJS({
  "node_modules/walletlink/dist/init/index.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
          __createBinding(exports2, m3, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_events(), exports);
    __exportStar(require_WalletLinkAnalyticsAbstract(), exports);
  }
});

// node_modules/walletlink/dist/types.js
var require_types = __commonJS({
  "node_modules/walletlink/dist/types.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RegExpString = exports.IntNumber = exports.BigIntString = exports.AddressString = exports.HexString = exports.OpaqueType = void 0;
    function OpaqueType() {
      return (value) => value;
    }
    exports.OpaqueType = OpaqueType;
    exports.HexString = OpaqueType();
    exports.AddressString = OpaqueType();
    exports.BigIntString = OpaqueType();
    function IntNumber(num) {
      return Math.floor(num);
    }
    exports.IntNumber = IntNumber;
    exports.RegExpString = OpaqueType();
  }
});

// node_modules/walletlink/dist/util.js
var require_util = __commonJS({
  "node_modules/walletlink/dist/util.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFavicon = exports.range = exports.isBigNumber = exports.ensureParsedJSONObject = exports.ensureBN = exports.ensureRegExpString = exports.ensureIntNumber = exports.ensureBuffer = exports.ensureAddressString = exports.ensureEvenLengthHexString = exports.ensureHexString = exports.isHexString = exports.prepend0x = exports.strip0x = exports.has0xPrefix = exports.hexStringFromIntNumber = exports.intNumberFromHexString = exports.bigIntStringFromBN = exports.hexStringFromBuffer = exports.hexStringToUint8Array = exports.uint8ArrayToHex = exports.randomBytesHex = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var types_1 = require_types();
    var INT_STRING_REGEX = /^[0-9]*$/;
    var HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
    function randomBytesHex(length) {
      return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));
    }
    exports.randomBytesHex = randomBytesHex;
    function uint8ArrayToHex(value) {
      return [...value].map((b3) => b3.toString(16).padStart(2, "0")).join("");
    }
    exports.uint8ArrayToHex = uint8ArrayToHex;
    function hexStringToUint8Array(hexString) {
      return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
    }
    exports.hexStringToUint8Array = hexStringToUint8Array;
    function hexStringFromBuffer(buf, includePrefix = false) {
      const hex = buf.toString("hex");
      return (0, types_1.HexString)(includePrefix ? "0x" + hex : hex);
    }
    exports.hexStringFromBuffer = hexStringFromBuffer;
    function bigIntStringFromBN(bn) {
      return (0, types_1.BigIntString)(bn.toString(10));
    }
    exports.bigIntStringFromBN = bigIntStringFromBN;
    function intNumberFromHexString(hex) {
      return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(hex, false), 16).toNumber());
    }
    exports.intNumberFromHexString = intNumberFromHexString;
    function hexStringFromIntNumber(num) {
      return (0, types_1.HexString)("0x" + new bn_js_1.default(num).toString(16));
    }
    exports.hexStringFromIntNumber = hexStringFromIntNumber;
    function has0xPrefix(str) {
      return str.startsWith("0x") || str.startsWith("0X");
    }
    exports.has0xPrefix = has0xPrefix;
    function strip0x(hex) {
      if (has0xPrefix(hex)) {
        return hex.slice(2);
      }
      return hex;
    }
    exports.strip0x = strip0x;
    function prepend0x(hex) {
      if (has0xPrefix(hex)) {
        return "0x" + hex.slice(2);
      }
      return "0x" + hex;
    }
    exports.prepend0x = prepend0x;
    function isHexString(hex) {
      if (typeof hex !== "string") {
        return false;
      }
      const s3 = strip0x(hex).toLowerCase();
      return HEXADECIMAL_STRING_REGEX.test(s3);
    }
    exports.isHexString = isHexString;
    function ensureHexString(hex, includePrefix = false) {
      if (typeof hex === "string") {
        const s3 = strip0x(hex).toLowerCase();
        if (HEXADECIMAL_STRING_REGEX.test(s3)) {
          return (0, types_1.HexString)(includePrefix ? "0x" + s3 : s3);
        }
      }
      throw new Error(`"${String(hex)}" is not a hexadecimal string`);
    }
    exports.ensureHexString = ensureHexString;
    function ensureEvenLengthHexString(hex, includePrefix = false) {
      let h3 = ensureHexString(hex, false);
      if (h3.length % 2 === 1) {
        h3 = (0, types_1.HexString)("0" + h3);
      }
      return includePrefix ? (0, types_1.HexString)("0x" + h3) : h3;
    }
    exports.ensureEvenLengthHexString = ensureEvenLengthHexString;
    function ensureAddressString(str) {
      if (typeof str === "string") {
        const s3 = strip0x(str).toLowerCase();
        if (isHexString(s3) && s3.length === 40) {
          return (0, types_1.AddressString)(prepend0x(s3));
        }
      }
      throw new Error(`Invalid Ethereum address: ${String(str)}`);
    }
    exports.ensureAddressString = ensureAddressString;
    function ensureBuffer(str) {
      if (Buffer.isBuffer(str)) {
        return str;
      }
      if (typeof str === "string") {
        if (isHexString(str)) {
          const s3 = ensureEvenLengthHexString(str, false);
          return Buffer.from(s3, "hex");
        } else {
          return Buffer.from(str, "utf8");
        }
      }
      throw new Error(`Not binary data: ${String(str)}`);
    }
    exports.ensureBuffer = ensureBuffer;
    function ensureIntNumber(num) {
      if (typeof num === "number" && Number.isInteger(num)) {
        return (0, types_1.IntNumber)(num);
      }
      if (typeof num === "string") {
        if (INT_STRING_REGEX.test(num)) {
          return (0, types_1.IntNumber)(Number(num));
        }
        if (isHexString(num)) {
          return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(num, false), 16).toNumber());
        }
      }
      throw new Error(`Not an integer: ${String(num)}`);
    }
    exports.ensureIntNumber = ensureIntNumber;
    function ensureRegExpString(regExp) {
      if (regExp instanceof RegExp) {
        return (0, types_1.RegExpString)(regExp.toString());
      }
      throw new Error(`Not a RegExp: ${String(regExp)}`);
    }
    exports.ensureRegExpString = ensureRegExpString;
    function ensureBN(val) {
      if (val !== null && (bn_js_1.default.isBN(val) || isBigNumber(val))) {
        return new bn_js_1.default(val.toString(10), 10);
      }
      if (typeof val === "number") {
        return new bn_js_1.default(ensureIntNumber(val));
      }
      if (typeof val === "string") {
        if (INT_STRING_REGEX.test(val)) {
          return new bn_js_1.default(val, 10);
        }
        if (isHexString(val)) {
          return new bn_js_1.default(ensureEvenLengthHexString(val, false), 16);
        }
      }
      throw new Error(`Not an integer: ${String(val)}`);
    }
    exports.ensureBN = ensureBN;
    function ensureParsedJSONObject(val) {
      if (typeof val === "string") {
        return JSON.parse(val);
      }
      if (typeof val === "object") {
        return val;
      }
      throw new Error(`Not a JSON string or an object: ${String(val)}`);
    }
    exports.ensureParsedJSONObject = ensureParsedJSONObject;
    function isBigNumber(val) {
      if (val == null || typeof val.constructor !== "function") {
        return false;
      }
      const { constructor } = val;
      return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
    }
    exports.isBigNumber = isBigNumber;
    function range(start, stop) {
      return Array.from({ length: stop - start }, (_3, i3) => start + i3);
    }
    exports.range = range;
    function getFavicon() {
      const el = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
      const { protocol, host } = document.location;
      const href = el ? el.getAttribute("href") : null;
      if (!href || href.startsWith("javascript:")) {
        return null;
      }
      if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
        return href;
      }
      if (href.startsWith("//")) {
        return protocol + href;
      }
      return `${protocol}//${host}${href}`;
    }
    exports.getFavicon = getFavicon;
  }
});

// node_modules/walletlink/dist/relay/Session.js
var require_Session = __commonJS({
  "node_modules/walletlink/dist/relay/Session.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Session = void 0;
    var js_sha256_1 = require_sha256();
    var rxjs_1 = (init_esm5(), esm5_exports);
    var operators_1 = (init_operators(), operators_exports);
    var util_1 = require_util();
    var STORAGE_KEY_SESSION_ID = "session:id";
    var STORAGE_KEY_SESSION_SECRET = "session:secret";
    var STORAGE_KEY_SESSION_LINKED = "session:linked";
    var Session = class {
      constructor(storage, id, secret, linked) {
        this._storage = storage;
        this._id = id || (0, util_1.randomBytesHex)(16);
        this._secret = secret || (0, util_1.randomBytesHex)(32);
        const hash = js_sha256_1.sha256.create();
        hash.update(`${this._id}, ${this._secret} WalletLink`);
        this._key = hash.hex();
        this._linked = !!linked;
      }
      static load(storage) {
        const id = storage.getItem(STORAGE_KEY_SESSION_ID);
        const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);
        const secret = storage.getItem(STORAGE_KEY_SESSION_SECRET);
        if (id && secret) {
          return new Session(storage, id, secret, linked === "1");
        }
        return null;
      }
      static get persistedSessionIdChange$() {
        return (0, rxjs_1.fromEvent)(window, "storage").pipe((0, operators_1.filter)((evt) => evt.key === STORAGE_KEY_SESSION_ID), (0, operators_1.map)((evt) => ({
          oldValue: evt.oldValue || null,
          newValue: evt.newValue || null
        })));
      }
      static hash(sessionId) {
        const hash = js_sha256_1.sha256.create();
        return hash.update(sessionId).hex();
      }
      get id() {
        return this._id;
      }
      get secret() {
        return this._secret;
      }
      get key() {
        return this._key;
      }
      get linked() {
        return this._linked;
      }
      set linked(val) {
        this._linked = val;
        this.persistLinked();
      }
      save() {
        this._storage.setItem(STORAGE_KEY_SESSION_ID, this._id);
        this._storage.setItem(STORAGE_KEY_SESSION_SECRET, this._secret);
        this.persistLinked();
        return this;
      }
      persistLinked() {
        this._storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
      }
    };
    exports.Session = Session;
  }
});

// node_modules/walletlink/dist/relay/WalletLinkRelayAbstract.js
var require_WalletLinkRelayAbstract = __commonJS({
  "node_modules/walletlink/dist/relay/WalletLinkRelayAbstract.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkRelayAbstract = exports.APP_VERSION_KEY = exports.LOCAL_STORAGE_ADDRESSES_KEY = exports.WALLET_USER_NAME_KEY = void 0;
    var eth_rpc_errors_1 = require_dist();
    exports.WALLET_USER_NAME_KEY = "walletUsername";
    exports.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
    exports.APP_VERSION_KEY = "AppVersion";
    var WalletLinkRelayAbstract = class {
      async makeEthereumJSONRPCRequest(request, jsonRpcUrl) {
        if (!jsonRpcUrl)
          throw new Error("Error: No jsonRpcUrl provided");
        return window.fetch(jsonRpcUrl, {
          method: "POST",
          body: JSON.stringify(request),
          mode: "cors",
          headers: { "Content-Type": "application/json" }
        }).then((res) => res.json()).then((json) => {
          if (!json) {
            throw eth_rpc_errors_1.ethErrors.rpc.parse({});
          }
          const response = json;
          const { error } = response;
          if (error) {
            throw (0, eth_rpc_errors_1.serializeError)(error);
          }
          return response;
        });
      }
    };
    exports.WalletLinkRelayAbstract = WalletLinkRelayAbstract;
  }
});

// node_modules/walletlink/dist/vendor-js/eth-eip712-util/util.js
var require_util2 = __commonJS({
  "node_modules/walletlink/dist/vendor-js/eth-eip712-util/util.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var createKeccakHash = require_js();
    var BN = require_bn();
    function zeros(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    }
    function setLength(msg, length, right) {
      const buf = zeros(length);
      msg = toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    }
    function setLengthRight(msg, length) {
      return setLength(msg, length, true);
    }
    function toBuffer(v3) {
      if (!Buffer.isBuffer(v3)) {
        if (Array.isArray(v3)) {
          v3 = Buffer.from(v3);
        } else if (typeof v3 === "string") {
          if (isHexString(v3)) {
            v3 = Buffer.from(padToEven(stripHexPrefix(v3)), "hex");
          } else {
            v3 = Buffer.from(v3);
          }
        } else if (typeof v3 === "number") {
          v3 = intToBuffer(v3);
        } else if (v3 === null || v3 === void 0) {
          v3 = Buffer.allocUnsafe(0);
        } else if (BN.isBN(v3)) {
          v3 = v3.toArrayLike(Buffer);
        } else if (v3.toArray) {
          v3 = Buffer.from(v3.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v3;
    }
    function bufferToHex(buf) {
      buf = toBuffer(buf);
      return "0x" + buf.toString("hex");
    }
    function keccak(a3, bits) {
      a3 = toBuffer(a3);
      if (!bits)
        bits = 256;
      return createKeccakHash("keccak" + bits).update(a3).digest();
    }
    function padToEven(str) {
      return str.length % 2 ? "0" + str : str;
    }
    function isHexString(str) {
      return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
    }
    function stripHexPrefix(str) {
      if (typeof str === "string" && str.startsWith("0x")) {
        return str.slice(2);
      }
      return str;
    }
    module.exports = {
      zeros,
      setLength,
      setLengthRight,
      isHexString,
      stripHexPrefix,
      toBuffer,
      bufferToHex,
      keccak
    };
  }
});

// node_modules/walletlink/dist/vendor-js/eth-eip712-util/abi.js
var require_abi = __commonJS({
  "node_modules/walletlink/dist/vendor-js/eth-eip712-util/abi.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var util = require_util2();
    var BN = require_bn();
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    function parseTypeN(type) {
      return parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
    }
    function parseTypeNxM(type) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type) {
      var tmp = type.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type = typeof arg;
      if (type === "string") {
        if (util.isHexString(arg)) {
          return new BN(util.stripHexPrefix(arg), 16);
        } else {
          return new BN(arg, 10);
        }
      } else if (type === "number") {
        return new BN(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function encodeSingle(type, arg) {
      var size, num, ret, i3;
      if (type === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type === "string") {
        return encodeSingle("bytes", new Buffer(arg, "utf8"));
      } else if (isArray(type)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i3 in arg) {
          ret.push(encodeSingle(type, arg[i3]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type === "bytes") {
        arg = new Buffer(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, util.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return util.setLengthRight(arg, 32);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("ufixed")) {
        size = parseTypeNxM(type);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN(2).pow(new BN(size[1]))));
      } else if (type.startsWith("fixed")) {
        size = parseTypeNxM(type);
        return encodeSingle("int256", parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type);
    }
    function isDynamic(type) {
      return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
    }
    function isArray(type) {
      return type.lastIndexOf("]") === type.length - 1;
    }
    function rawEncode(types, values) {
      var output = [];
      var data = [];
      var headLength = 32 * types.length;
      for (var i3 in types) {
        var type = elementaryName(types[i3]);
        var value = values[i3];
        var cur = encodeSingle(type, value);
        if (isDynamic(type)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    }
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var size, num;
      var ret = [];
      for (var i3 = 0; i3 < types.length; i3++) {
        var type = elementaryName(types[i3]);
        var value = values[i3];
        if (type === "bytes") {
          ret.push(value);
        } else if (type === "string") {
          ret.push(new Buffer(value, "utf8"));
        } else if (type === "bool") {
          ret.push(new Buffer(value ? "01" : "00", "hex"));
        } else if (type === "address") {
          ret.push(util.setLength(value, 20));
        } else if (type.startsWith("bytes")) {
          size = parseTypeN(type);
          if (size < 1 || size > 32) {
            throw new Error("Invalid bytes<N> width: " + size);
          }
          ret.push(util.setLengthRight(value, size));
        } else if (type.startsWith("uint")) {
          size = parseTypeN(type);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid uint<N> width: " + size);
          }
          num = parseNumber(value);
          if (num.bitLength() > size) {
            throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
          }
          ret.push(num.toArrayLike(Buffer, "be", size / 8));
        } else if (type.startsWith("int")) {
          size = parseTypeN(type);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid int<N> width: " + size);
          }
          num = parseNumber(value);
          if (num.bitLength() > size) {
            throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
          }
          ret.push(num.toTwos(size).toArrayLike(Buffer, "be", size / 8));
        } else {
          throw new Error("Unsupported or invalid type: " + type);
        }
      }
      return Buffer.concat(ret);
    }
    function soliditySHA3(types, values) {
      return util.keccak(solidityPack(types, values));
    }
    module.exports = {
      rawEncode,
      solidityPack,
      soliditySHA3
    };
  }
});

// node_modules/walletlink/dist/vendor-js/eth-eip712-util/index.js
var require_eth_eip712_util = __commonJS({
  "node_modules/walletlink/dist/vendor-js/eth-eip712-util/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var util = require_util2();
    var abi = require_abi();
    var TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    var TypedDataUtils = {
      encodeData(primaryType, data, types, useV4 = true) {
        const encodedTypes = ["bytes32"];
        const encodedValues = [this.hashType(primaryType, types)];
        if (useV4) {
          const encodeField = (name, type, value) => {
            if (types[type] !== void 0) {
              return ["bytes32", value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util.keccak(this.encodeData(type, value, types, useV4))];
            }
            if (value === void 0)
              throw new Error(`missing value for field ${name} of type ${type}`);
            if (type === "bytes") {
              return ["bytes32", util.keccak(value)];
            }
            if (type === "string") {
              if (typeof value === "string") {
                value = Buffer.from(value, "utf8");
              }
              return ["bytes32", util.keccak(value)];
            }
            if (type.lastIndexOf("]") === type.length - 1) {
              const parsedType = type.slice(0, type.lastIndexOf("["));
              const typeValuePairs = value.map((item) => encodeField(name, parsedType, item));
              return ["bytes32", util.keccak(abi.rawEncode(typeValuePairs.map(([type2]) => type2), typeValuePairs.map(([, value2]) => value2)))];
            }
            return [type, value];
          };
          for (const field of types[primaryType]) {
            const [type, value] = encodeField(field.name, field.type, data[field.name]);
            encodedTypes.push(type);
            encodedValues.push(value);
          }
        } else {
          for (const field of types[primaryType]) {
            let value = data[field.name];
            if (value !== void 0) {
              if (field.type === "bytes") {
                encodedTypes.push("bytes32");
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (field.type === "string") {
                encodedTypes.push("bytes32");
                if (typeof value === "string") {
                  value = Buffer.from(value, "utf8");
                }
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (types[field.type] !== void 0) {
                encodedTypes.push("bytes32");
                value = util.keccak(this.encodeData(field.type, value, types, useV4));
                encodedValues.push(value);
              } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
                throw new Error("Arrays currently unimplemented in encodeData");
              } else {
                encodedTypes.push(field.type);
                encodedValues.push(value);
              }
            }
          }
        }
        return abi.rawEncode(encodedTypes, encodedValues);
      },
      encodeType(primaryType, types) {
        let result = "";
        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type of deps) {
          const children = types[type];
          if (!children) {
            throw new Error("No type definition specified: " + type);
          }
          result += type + "(" + types[type].map(({ name, type: type2 }) => type2 + " " + name).join(",") + ")";
        }
        return result;
      },
      findTypeDependencies(primaryType, types, results = []) {
        primaryType = primaryType.match(/^\w*/)[0];
        if (results.includes(primaryType) || types[primaryType] === void 0) {
          return results;
        }
        results.push(primaryType);
        for (const field of types[primaryType]) {
          for (const dep of this.findTypeDependencies(field.type, types, results)) {
            !results.includes(dep) && results.push(dep);
          }
        }
        return results;
      },
      hashStruct(primaryType, data, types, useV4 = true) {
        return util.keccak(this.encodeData(primaryType, data, types, useV4));
      },
      hashType(primaryType, types) {
        return util.keccak(this.encodeType(primaryType, types));
      },
      sanitizeData(data) {
        const sanitizedData = {};
        for (const key in TYPED_MESSAGE_SCHEMA.properties) {
          data[key] && (sanitizedData[key] = data[key]);
        }
        if (sanitizedData.types) {
          sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
      },
      hash(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts = [Buffer.from("1901", "hex")];
        parts.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== "EIP712Domain") {
          parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return util.keccak(Buffer.concat(parts));
      }
    };
    module.exports = {
      TYPED_MESSAGE_SCHEMA,
      TypedDataUtils,
      hashForSignTypedDataLegacy: function(msgParams) {
        return typedSignatureHashLegacy(msgParams.data);
      },
      hashForSignTypedData_v3: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data, false);
      },
      hashForSignTypedData_v4: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data);
      }
    };
    function typedSignatureHashLegacy(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length)
        throw error;
      const data = typedData.map(function(e3) {
        return e3.type === "bytes" ? util.toBuffer(e3.value) : e3.value;
      });
      const types = typedData.map(function(e3) {
        return e3.type;
      });
      const schema = typedData.map(function(e3) {
        if (!e3.name)
          throw error;
        return e3.type + " " + e3.name;
      });
      return abi.soliditySHA3(["bytes32", "bytes32"], [
        abi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
        abi.soliditySHA3(types, data)
      ]);
    }
  }
});

// node_modules/walletlink/dist/provider/FilterPolyfill.js
var require_FilterPolyfill = __commonJS({
  "node_modules/walletlink/dist/provider/FilterPolyfill.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterFromParam = exports.FilterPolyfill = void 0;
    var types_1 = require_types();
    var util_1 = require_util();
    var TIMEOUT = 5 * 60 * 1e3;
    var JSONRPC_TEMPLATE = {
      jsonrpc: "2.0",
      id: 0
    };
    var FilterPolyfill = class {
      constructor(provider) {
        this.logFilters = new Map();
        this.blockFilters = new Set();
        this.pendingTransactionFilters = new Set();
        this.cursors = new Map();
        this.timeouts = new Map();
        this.nextFilterId = (0, types_1.IntNumber)(1);
        this.provider = provider;
      }
      async newFilter(param) {
        const filter = filterFromParam(param);
        const id = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id, filter.fromBlock);
        console.log(`Installing new log filter(${id}):`, filter, "initial cursor position:", cursor);
        this.logFilters.set(id, filter);
        this.setFilterTimeout(id);
        return (0, util_1.hexStringFromIntNumber)(id);
      }
      async newBlockFilter() {
        const id = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id, "latest");
        console.log(`Installing new block filter (${id}) with initial cursor position:`, cursor);
        this.blockFilters.add(id);
        this.setFilterTimeout(id);
        return (0, util_1.hexStringFromIntNumber)(id);
      }
      async newPendingTransactionFilter() {
        const id = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id, "latest");
        console.log(`Installing new block filter (${id}) with initial cursor position:`, cursor);
        this.pendingTransactionFilters.add(id);
        this.setFilterTimeout(id);
        return (0, util_1.hexStringFromIntNumber)(id);
      }
      uninstallFilter(filterId) {
        const id = (0, util_1.intNumberFromHexString)(filterId);
        console.log(`Uninstalling filter (${id})`);
        this.deleteFilter(id);
        return true;
      }
      getFilterChanges(filterId) {
        const id = (0, util_1.intNumberFromHexString)(filterId);
        if (this.timeouts.has(id)) {
          this.setFilterTimeout(id);
        }
        if (this.logFilters.has(id)) {
          return this.getLogFilterChanges(id);
        } else if (this.blockFilters.has(id)) {
          return this.getBlockFilterChanges(id);
        } else if (this.pendingTransactionFilters.has(id)) {
          return this.getPendingTransactionFilterChanges(id);
        }
        return Promise.resolve(filterNotFoundError());
      }
      async getFilterLogs(filterId) {
        const id = (0, util_1.intNumberFromHexString)(filterId);
        const filter = this.logFilters.get(id);
        if (!filter) {
          return filterNotFoundError();
        }
        return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [paramFromFilter(filter)] }));
      }
      makeFilterId() {
        return (0, types_1.IntNumber)(++this.nextFilterId);
      }
      sendAsyncPromise(request) {
        return new Promise((resolve, reject) => {
          this.provider.sendAsync(request, (err, response) => {
            if (err) {
              return reject(err);
            }
            if (Array.isArray(response) || response == null) {
              return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));
            }
            resolve(response);
          });
        });
      }
      deleteFilter(id) {
        console.log(`Deleting filter (${id})`);
        this.logFilters.delete(id);
        this.blockFilters.delete(id);
        this.pendingTransactionFilters.delete(id);
        this.cursors.delete(id);
        this.timeouts.delete(id);
      }
      async getLogFilterChanges(id) {
        const filter = this.logFilters.get(id);
        const cursorPosition = this.cursors.get(id);
        if (!cursorPosition || !filter) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const toBlock = filter.toBlock === "latest" ? currentBlockHeight : filter.toBlock;
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        if (cursorPosition > filter.toBlock) {
          return emptyResult();
        }
        console.log(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id}`);
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [
          paramFromFilter(Object.assign(Object.assign({}, filter), { fromBlock: cursorPosition, toBlock }))
        ] }));
        if (Array.isArray(response.result)) {
          const blocks = response.result.map((log) => (0, util_1.intNumberFromHexString)(log.blockNumber || "0x0"));
          const highestBlock = Math.max(...blocks);
          if (highestBlock && highestBlock > cursorPosition) {
            const newCursorPosition = (0, types_1.IntNumber)(highestBlock + 1);
            console.log(`Moving cursor position for filter (${id}) from ${cursorPosition} to ${newCursorPosition}`);
            this.cursors.set(id, newCursorPosition);
          }
        }
        return response;
      }
      async getBlockFilterChanges(id) {
        const cursorPosition = this.cursors.get(id);
        if (!cursorPosition) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        console.log(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id})`);
        const blocks = (await Promise.all((0, util_1.range)(cursorPosition, currentBlockHeight + 1).map((i3) => this.getBlockHashByNumber((0, types_1.IntNumber)(i3))))).filter((hash) => !!hash);
        const newCursorPosition = (0, types_1.IntNumber)(cursorPosition + blocks.length);
        console.log(`Moving cursor position for filter (${id}) from ${cursorPosition} to ${newCursorPosition}`);
        this.cursors.set(id, newCursorPosition);
        return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: blocks });
      }
      async getPendingTransactionFilterChanges(_id) {
        return Promise.resolve(emptyResult());
      }
      async setInitialCursorPosition(id, startBlock) {
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const initialCursorPosition = typeof startBlock === "number" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;
        this.cursors.set(id, initialCursorPosition);
        return initialCursorPosition;
      }
      setFilterTimeout(id) {
        const existing = this.timeouts.get(id);
        if (existing) {
          window.clearTimeout(existing);
        }
        const timeout = window.setTimeout(() => {
          console.log(`Filter (${id}) timed out`);
          this.deleteFilter(id);
        }, TIMEOUT);
        this.timeouts.set(id, timeout);
      }
      async getCurrentBlockHeight() {
        const { result } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_blockNumber", params: [] }));
        return (0, util_1.intNumberFromHexString)((0, util_1.ensureHexString)(result));
      }
      async getBlockHashByNumber(blockNumber) {
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getBlockByNumber", params: [(0, util_1.hexStringFromIntNumber)(blockNumber), false] }));
        if (response.result && typeof response.result.hash === "string") {
          return (0, util_1.ensureHexString)(response.result.hash);
        }
        return null;
      }
    };
    exports.FilterPolyfill = FilterPolyfill;
    function filterFromParam(param) {
      return {
        fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),
        toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),
        addresses: param.address === void 0 ? null : Array.isArray(param.address) ? param.address : [param.address],
        topics: param.topics || []
      };
    }
    exports.filterFromParam = filterFromParam;
    function paramFromFilter(filter) {
      const param = {
        fromBlock: hexBlockHeightFromIntBlockHeight(filter.fromBlock),
        toBlock: hexBlockHeightFromIntBlockHeight(filter.toBlock),
        topics: filter.topics
      };
      if (filter.addresses !== null) {
        param.address = filter.addresses;
      }
      return param;
    }
    function intBlockHeightFromHexBlockHeight(value) {
      if (value === void 0 || value === "latest" || value === "pending") {
        return "latest";
      } else if (value === "earliest") {
        return (0, types_1.IntNumber)(0);
      } else if ((0, util_1.isHexString)(value)) {
        return (0, util_1.intNumberFromHexString)(value);
      }
      throw new Error(`Invalid block option: ${String(value)}`);
    }
    function hexBlockHeightFromIntBlockHeight(value) {
      if (value === "latest") {
        return value;
      }
      return (0, util_1.hexStringFromIntNumber)(value);
    }
    function filterNotFoundError() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { error: { code: -32e3, message: "filter not found" } });
    }
    function emptyResult() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: [] });
    }
  }
});

// node_modules/walletlink/dist/provider/JSONRPC.js
var require_JSONRPC = __commonJS({
  "node_modules/walletlink/dist/provider/JSONRPC.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONRPCMethod = void 0;
    var JSONRPCMethod;
    (function(JSONRPCMethod2) {
      JSONRPCMethod2["eth_accounts"] = "eth_accounts";
      JSONRPCMethod2["eth_coinbase"] = "eth_coinbase";
      JSONRPCMethod2["net_version"] = "net_version";
      JSONRPCMethod2["eth_chainId"] = "eth_chainId";
      JSONRPCMethod2["eth_uninstallFilter"] = "eth_uninstallFilter";
      JSONRPCMethod2["eth_requestAccounts"] = "eth_requestAccounts";
      JSONRPCMethod2["eth_sign"] = "eth_sign";
      JSONRPCMethod2["eth_ecRecover"] = "eth_ecRecover";
      JSONRPCMethod2["personal_sign"] = "personal_sign";
      JSONRPCMethod2["personal_ecRecover"] = "personal_ecRecover";
      JSONRPCMethod2["eth_signTransaction"] = "eth_signTransaction";
      JSONRPCMethod2["eth_sendRawTransaction"] = "eth_sendRawTransaction";
      JSONRPCMethod2["eth_sendTransaction"] = "eth_sendTransaction";
      JSONRPCMethod2["eth_signTypedData_v1"] = "eth_signTypedData_v1";
      JSONRPCMethod2["eth_signTypedData_v2"] = "eth_signTypedData_v2";
      JSONRPCMethod2["eth_signTypedData_v3"] = "eth_signTypedData_v3";
      JSONRPCMethod2["eth_signTypedData_v4"] = "eth_signTypedData_v4";
      JSONRPCMethod2["eth_signTypedData"] = "eth_signTypedData";
      JSONRPCMethod2["walletlink_arbitrary"] = "walletlink_arbitrary";
      JSONRPCMethod2["wallet_addEthereumChain"] = "wallet_addEthereumChain";
      JSONRPCMethod2["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
      JSONRPCMethod2["wallet_watchAsset"] = "wallet_watchAsset";
      JSONRPCMethod2["eth_subscribe"] = "eth_subscribe";
      JSONRPCMethod2["eth_unsubscribe"] = "eth_unsubscribe";
      JSONRPCMethod2["eth_newFilter"] = "eth_newFilter";
      JSONRPCMethod2["eth_newBlockFilter"] = "eth_newBlockFilter";
      JSONRPCMethod2["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
      JSONRPCMethod2["eth_getFilterChanges"] = "eth_getFilterChanges";
      JSONRPCMethod2["eth_getFilterLogs"] = "eth_getFilterLogs";
    })(JSONRPCMethod = exports.JSONRPCMethod || (exports.JSONRPCMethod = {}));
  }
});

// node_modules/walletlink/node_modules/eth-block-tracker/src/base.js
var require_base = __commonJS({
  "node_modules/walletlink/node_modules/eth-block-tracker/src/base.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var EthQuery = require_eth_query();
    var pify = require_pify();
    var SafeEventEmitter = require_safe_event_emitter2();
    var sec = 1e3;
    var calculateSum = (accumulator, currentValue) => accumulator + currentValue;
    var blockTrackerEvents = ["sync", "latest"];
    var BaseBlockTracker = class extends SafeEventEmitter {
      constructor(opts = {}) {
        super();
        this._blockResetDuration = opts.blockResetDuration || 20 * sec;
        this._blockResetTimeout;
        this._currentBlock = null;
        this._isRunning = false;
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        this._setupInternalEvents();
      }
      isRunning() {
        return this._isRunning;
      }
      getCurrentBlock() {
        return this._currentBlock;
      }
      async getLatestBlock() {
        if (this._currentBlock)
          return this._currentBlock;
        const latestBlock = await new Promise((resolve) => this.once("latest", resolve));
        return latestBlock;
      }
      removeAllListeners(eventName) {
        if (eventName) {
          super.removeAllListeners(eventName);
        } else {
          super.removeAllListeners();
        }
        this._setupInternalEvents();
        this._onRemoveListener();
      }
      _start() {
      }
      _end() {
      }
      _setupInternalEvents() {
        this.removeListener("newListener", this._onNewListener);
        this.removeListener("removeListener", this._onRemoveListener);
        this.on("newListener", this._onNewListener);
        this.on("removeListener", this._onRemoveListener);
      }
      _onNewListener(eventName, handler) {
        if (!blockTrackerEvents.includes(eventName))
          return;
        this._maybeStart();
      }
      _onRemoveListener(eventName, handler) {
        if (this._getBlockTrackerEventCount() > 0)
          return;
        this._maybeEnd();
      }
      _maybeStart() {
        if (this._isRunning)
          return;
        this._isRunning = true;
        this._cancelBlockResetTimeout();
        this._start();
      }
      _maybeEnd() {
        if (!this._isRunning)
          return;
        this._isRunning = false;
        this._setupBlockResetTimeout();
        this._end();
      }
      _getBlockTrackerEventCount() {
        return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
      }
      _newPotentialLatest(newBlock) {
        const currentBlock = this._currentBlock;
        if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock))
          return;
        this._setCurrentBlock(newBlock);
      }
      _setCurrentBlock(newBlock) {
        const oldBlock = this._currentBlock;
        this._currentBlock = newBlock;
        this.emit("latest", newBlock);
        this.emit("sync", { oldBlock, newBlock });
      }
      _setupBlockResetTimeout() {
        this._cancelBlockResetTimeout();
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
        if (this._blockResetTimeout.unref) {
          this._blockResetTimeout.unref();
        }
      }
      _cancelBlockResetTimeout() {
        clearTimeout(this._blockResetTimeout);
      }
      _resetCurrentBlock() {
        this._currentBlock = null;
      }
    };
    module.exports = BaseBlockTracker;
    function hexToInt(hexInt) {
      return Number.parseInt(hexInt, 16);
    }
  }
});

// node_modules/walletlink/node_modules/eth-block-tracker/src/polling.js
var require_polling = __commonJS({
  "node_modules/walletlink/node_modules/eth-block-tracker/src/polling.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var pify = require_pify();
    var BaseBlockTracker = require_base();
    var sec = 1e3;
    var PollingBlockTracker = class extends BaseBlockTracker {
      constructor(opts = {}) {
        if (!opts.provider)
          throw new Error("PollingBlockTracker - no provider specified.");
        const pollingInterval = opts.pollingInterval || 20 * sec;
        const retryTimeout = opts.retryTimeout || pollingInterval / 10;
        const keepEventLoopActive = opts.keepEventLoopActive !== void 0 ? opts.keepEventLoopActive : true;
        const setSkipCacheFlag = opts.setSkipCacheFlag || false;
        super(Object.assign({
          blockResetDuration: pollingInterval
        }, opts));
        this._provider = opts.provider;
        this._pollingInterval = pollingInterval;
        this._retryTimeout = retryTimeout;
        this._keepEventLoopActive = keepEventLoopActive;
        this._setSkipCacheFlag = setSkipCacheFlag;
      }
      async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
      }
      _start() {
        this._performSync().catch((err) => this.emit("error", err));
      }
      async _performSync() {
        while (this._isRunning) {
          try {
            await this._updateLatestBlock();
            await timeout(this._pollingInterval, !this._keepEventLoopActive);
          } catch (err) {
            const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${err.stack}`);
            try {
              this.emit("error", newErr);
            } catch (emitErr) {
              console.error(newErr);
            }
            await timeout(this._retryTimeout, !this._keepEventLoopActive);
          }
        }
      }
      async _updateLatestBlock() {
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
      }
      async _fetchLatestBlock() {
        const req = { jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] };
        if (this._setSkipCacheFlag)
          req.skipCache = true;
        const res = await pify((cb) => this._provider.sendAsync(req, cb))();
        if (res.error)
          throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error}`);
        return res.result;
      }
    };
    module.exports = PollingBlockTracker;
    function timeout(duration, unref) {
      return new Promise((resolve) => {
        const timoutRef = setTimeout(resolve, duration);
        if (timoutRef.unref && unref) {
          timoutRef.unref();
        }
      });
    }
  }
});

// node_modules/walletlink/dist/provider/SubscriptionManager.js
var require_SubscriptionManager = __commonJS({
  "node_modules/walletlink/dist/provider/SubscriptionManager.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionManager = void 0;
    var PollingBlockTracker = require_polling();
    var createSubscriptionManager = require_subscriptionManager();
    var noop = () => {
    };
    var SubscriptionManager = class {
      constructor(provider) {
        const blockTracker = new PollingBlockTracker({
          provider,
          pollingInterval: 15 * 1e3,
          setSkipCacheFlag: true
        });
        const { events, middleware } = createSubscriptionManager({
          blockTracker,
          provider
        });
        this.events = events;
        this.subscriptionMiddleware = middleware;
      }
      async handleRequest(request) {
        const result = {};
        await this.subscriptionMiddleware(request, result, noop, noop);
        return result;
      }
      destroy() {
        this.subscriptionMiddleware.destroy();
      }
    };
    exports.SubscriptionManager = SubscriptionManager;
  }
});

// node_modules/walletlink/dist/provider/WalletLinkProvider.js
var require_WalletLinkProvider = __commonJS({
  "node_modules/walletlink/dist/provider/WalletLinkProvider.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkProvider = void 0;
    var safe_event_emitter_1 = __importDefault(require_safe_event_emitter());
    var bn_js_1 = __importDefault(require_bn());
    var eth_rpc_errors_1 = require_dist();
    var WalletLinkAnalytics_1 = require_WalletLinkAnalytics();
    var init_1 = require_init();
    var Session_1 = require_Session();
    var WalletLinkRelayAbstract_1 = require_WalletLinkRelayAbstract();
    var util_1 = require_util();
    var eth_eip712_util_1 = __importDefault(require_eth_eip712_util());
    var FilterPolyfill_1 = require_FilterPolyfill();
    var JSONRPC_1 = require_JSONRPC();
    var SubscriptionManager_1 = require_SubscriptionManager();
    var DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
    var DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
    var HAS_CHAIN_BEEN_SWITCHED_KEY = "HasChainBeenSwitched";
    var HAS_CHAIN_OVERRIDDEN_FROM_RELAY = "HasChainOverriddenFromRelay";
    var WalletLinkProvider = class extends safe_event_emitter_1.default {
      constructor(options) {
        var _a;
        super();
        this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);
        this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
        this._relay = null;
        this._addresses = [];
        this.hasMadeFirstChainChangedEmission = false;
        this._send = this.send.bind(this);
        this._sendAsync = this.sendAsync.bind(this);
        this.setProviderInfo = this.setProviderInfo.bind(this);
        this.updateProviderInfo = this.updateProviderInfo.bind(this);
        this.getChainId = this.getChainId.bind(this);
        this.setAppInfo = this.setAppInfo.bind(this);
        this.enable = this.enable.bind(this);
        this.close = this.close.bind(this);
        this.send = this.send.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        this.request = this.request.bind(this);
        this._setAddresses = this._setAddresses.bind(this);
        this.scanQRCode = this.scanQRCode.bind(this);
        this.genericRequest = this.genericRequest.bind(this);
        this._jsonRpcUrlFromOpts = options.jsonRpcUrl;
        this._overrideIsMetaMask = options.overrideIsMetaMask;
        this._relayProvider = options.relayProvider;
        this._storage = options.storage;
        this._relayEventManager = options.relayEventManager;
        this._walletLinkAnalytics = options.walletLinkAnalytics ? options.walletLinkAnalytics : new WalletLinkAnalytics_1.WalletLinkAnalytics();
        this.isCoinbaseWallet = (_a = options.overrideIsCoinbaseWallet) !== null && _a !== void 0 ? _a : true;
        const chainId = this.getChainId();
        const chainIdStr = (0, util_1.prepend0x)(chainId.toString(16));
        this.emit("connect", { chainIdStr });
        const cachedAddresses = this._storage.getItem(WalletLinkRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
        if (cachedAddresses) {
          const addresses = cachedAddresses.split(" ");
          if (addresses[0] !== "") {
            this._addresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
            this.emit("accountsChanged", addresses);
          }
        }
        this._subscriptionManager.events.on("notification", (notification) => {
          this.emit("message", {
            type: notification.method,
            data: notification.params
          });
        });
        if (this._addresses.length > 0) {
          void this.initializeRelay();
        }
        window.addEventListener("message", (event) => {
          var _a2;
          if (event.data.type !== "walletLinkMessage")
            return;
          if (event.data.data.action === "defaultChainChanged") {
            const _chainId = event.data.data.chainId;
            const jsonRpcUrl = (_a2 = event.data.data.jsonRpcUrl) !== null && _a2 !== void 0 ? _a2 : this.jsonRpcUrl;
            this.updateProviderInfo(jsonRpcUrl, Number(_chainId), true);
          }
        });
      }
      get selectedAddress() {
        return this._addresses[0] || void 0;
      }
      get networkVersion() {
        return this.getChainId().toString(10);
      }
      get chainId() {
        return (0, util_1.prepend0x)(this.getChainId().toString(16));
      }
      get isWalletLink() {
        return true;
      }
      get isMetaMask() {
        return this._overrideIsMetaMask;
      }
      get host() {
        return this.jsonRpcUrl;
      }
      get connected() {
        return true;
      }
      isConnected() {
        return true;
      }
      get jsonRpcUrl() {
        var _a;
        return (_a = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a !== void 0 ? _a : this._jsonRpcUrlFromOpts;
      }
      set jsonRpcUrl(value) {
        this._storage.setItem(DEFAULT_JSON_RPC_URL, value);
      }
      get isChainOverridden() {
        return this._storage.getItem(HAS_CHAIN_OVERRIDDEN_FROM_RELAY) === "true";
      }
      set isChainOverridden(value) {
        this._storage.setItem(HAS_CHAIN_OVERRIDDEN_FROM_RELAY, value.toString());
      }
      setProviderInfo(jsonRpcUrl, chainId) {
        if (this.isChainOverridden)
          return;
        this.updateProviderInfo(jsonRpcUrl, this.getChainId(), false);
      }
      updateProviderInfo(jsonRpcUrl, chainId, fromRelay) {
        const hasChainSwitched = this._storage.getItem(HAS_CHAIN_BEEN_SWITCHED_KEY) === "true";
        if (hasChainSwitched && fromRelay)
          return;
        if (fromRelay) {
          this.isChainOverridden = true;
        }
        this.jsonRpcUrl = jsonRpcUrl;
        const originalChainId = this.getChainId();
        this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
        const chainChanged = (0, util_1.ensureIntNumber)(chainId) !== originalChainId;
        if (chainChanged || !this.hasMadeFirstChainChangedEmission) {
          this.emit("chainChanged", this.getChainId());
          this.hasMadeFirstChainChangedEmission = true;
        }
      }
      async watchAsset(type, address, symbol, decimals, image) {
        const relay = await this.initializeRelay();
        const result = await relay.watchAsset(type, address, symbol, decimals, image).promise;
        return !!result.result;
      }
      async addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
        var _a, _b;
        if ((0, util_1.ensureIntNumber)(chainId) === this.getChainId()) {
          return false;
        }
        const relay = await this.initializeRelay();
        const res = await relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;
        if (((_a = res.result) === null || _a === void 0 ? void 0 : _a.isApproved) === true) {
          this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
          this.updateProviderInfo(rpcUrls[0], chainId, false);
        }
        return ((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true;
      }
      async switchEthereumChain(chainId) {
        if ((0, util_1.ensureIntNumber)(chainId) === this.getChainId()) {
          return;
        }
        const relay = await this.initializeRelay();
        const res = await relay.switchEthereumChain(chainId.toString(10)).promise;
        if (res.errorCode) {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: res.errorCode
          });
        }
        const switchResponse = res.result;
        if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
          this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
          this.updateProviderInfo(switchResponse.rpcUrl, chainId, false);
        }
      }
      setAppInfo(appName, appLogoUrl) {
        void this.initializeRelay().then((relay) => relay.setAppInfo(appName, appLogoUrl));
      }
      async enable() {
        this._walletLinkAnalytics.sendEvent(init_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::enable",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : null
        });
        if (this._addresses.length > 0) {
          return [...this._addresses];
        }
        return await this._send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);
      }
      close() {
        void this.initializeRelay().then((relay) => relay.resetAndReload());
      }
      send(requestOrMethod, callbackOrParams) {
        if (typeof requestOrMethod === "string") {
          const method = requestOrMethod;
          const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== void 0 ? [callbackOrParams] : [];
          const request = {
            jsonrpc: "2.0",
            id: 0,
            method,
            params
          };
          return this._sendRequestAsync(request).then((res) => res.result);
        }
        if (typeof callbackOrParams === "function") {
          const request = requestOrMethod;
          const callback = callbackOrParams;
          return this._sendAsync(request, callback);
        }
        if (Array.isArray(requestOrMethod)) {
          const requests = requestOrMethod;
          return requests.map((r3) => this._sendRequest(r3));
        }
        const req = requestOrMethod;
        return this._sendRequest(req);
      }
      sendAsync(request, callback) {
        if (typeof callback !== "function") {
          throw new Error("callback is required");
        }
        if (Array.isArray(request)) {
          const arrayCb = callback;
          this._sendMultipleRequestsAsync(request).then((responses) => arrayCb(null, responses)).catch((err) => arrayCb(err, null));
          return;
        }
        const cb = callback;
        this._sendRequestAsync(request).then((response) => cb(null, response)).catch((err) => cb(err, null));
      }
      async request(args) {
        if (!args || typeof args !== "object" || Array.isArray(args)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "Expected a single, non-array, object argument.",
            data: args
          });
        }
        const { method, params } = args;
        if (typeof method !== "string" || method.length === 0) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "'args.method' must be a non-empty string.",
            data: args
          });
        }
        if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: "'args.params' must be an object or array if provided.",
            data: args
          });
        }
        const newParams = params === void 0 ? [] : params;
        const id = this._relayEventManager.makeRequestId();
        const result = await this._sendRequestAsync({
          method,
          params: newParams,
          jsonrpc: "2.0",
          id
        });
        return result.result;
      }
      async scanQRCode(match) {
        const relay = await this.initializeRelay();
        const res = await relay.scanQRCode((0, util_1.ensureRegExpString)(match)).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      async genericRequest(data, action) {
        const relay = await this.initializeRelay();
        const res = await relay.genericRequest(data, action).promise;
        if (typeof res.result !== "string") {
          throw new Error("result was not a string");
        }
        return res.result;
      }
      supportsSubscriptions() {
        return false;
      }
      subscribe() {
        throw new Error("Subscriptions are not supported");
      }
      unsubscribe() {
        throw new Error("Subscriptions are not supported");
      }
      disconnect() {
        return true;
      }
      _sendRequest(request) {
        const response = {
          jsonrpc: "2.0",
          id: request.id
        };
        const { method } = request;
        response.result = this._handleSynchronousMethods(request);
        if (response.result === void 0) {
          throw new Error(`WalletLink does not support calling ${method} synchronously without a callback. Please provide a callback parameter to call ${method} asynchronously.`);
        }
        return response;
      }
      _setAddresses(addresses) {
        if (!Array.isArray(addresses)) {
          throw new Error("addresses is not an array");
        }
        const newAddresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
        if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
          return;
        }
        this._addresses = newAddresses;
        this.emit("accountsChanged", this._addresses);
        this._storage.setItem(WalletLinkRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
        window.dispatchEvent(new CustomEvent("walletlink:addresses", { detail: this._addresses }));
      }
      _sendRequestAsync(request) {
        return new Promise((resolve, reject) => {
          try {
            const syncResult = this._handleSynchronousMethods(request);
            if (syncResult !== void 0) {
              return resolve({
                jsonrpc: "2.0",
                id: request.id,
                result: syncResult
              });
            }
            const filterPromise = this._handleAsynchronousFilterMethods(request);
            if (filterPromise !== void 0) {
              filterPromise.then((res) => resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
              return;
            }
            const subscriptionPromise = this._handleSubscriptionMethods(request);
            if (subscriptionPromise !== void 0) {
              subscriptionPromise.then((res) => resolve({
                jsonrpc: "2.0",
                id: request.id,
                result: res.result
              })).catch((err) => reject(err));
              return;
            }
          } catch (err) {
            return reject(err);
          }
          this._handleAsynchronousMethods(request).then((res) => res && resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
        });
      }
      _sendMultipleRequestsAsync(requests) {
        return Promise.all(requests.map((r3) => this._sendRequestAsync(r3)));
      }
      _handleSynchronousMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_accounts:
            return this._eth_accounts();
          case JSONRPC_1.JSONRPCMethod.eth_coinbase:
            return this._eth_coinbase();
          case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:
            return this._eth_uninstallFilter(params);
          case JSONRPC_1.JSONRPCMethod.net_version:
            return this._net_version();
          case JSONRPC_1.JSONRPCMethod.eth_chainId:
            return this._eth_chainId();
          default:
            return void 0;
        }
      }
      async _handleAsynchronousMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:
            return this._eth_requestAccounts();
          case JSONRPC_1.JSONRPCMethod.eth_sign:
            return this._eth_sign(params);
          case JSONRPC_1.JSONRPCMethod.eth_ecRecover:
            return this._eth_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.personal_sign:
            return this._personal_sign(params);
          case JSONRPC_1.JSONRPCMethod.personal_ecRecover:
            return this._personal_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTransaction:
            return this._eth_signTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:
            return this._eth_sendRawTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:
            return this._eth_sendTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:
            return this._eth_signTypedData_v1(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:
            return this._throwUnsupportedMethodError();
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:
            return this._eth_signTypedData_v3(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData:
            return this._eth_signTypedData_v4(params);
          case JSONRPC_1.JSONRPCMethod.walletlink_arbitrary:
            return this._walletlink_arbitrary(params);
          case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:
            return this._wallet_addEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:
            return this._wallet_switchEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_watchAsset:
            return this._wallet_watchAsset(params);
        }
        const relay = await this.initializeRelay();
        return relay.makeEthereumJSONRPCRequest(request, this.jsonRpcUrl);
      }
      _handleAsynchronousFilterMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_newFilter:
            return this._eth_newFilter(params);
          case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:
            return this._eth_newBlockFilter();
          case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:
            return this._eth_newPendingTransactionFilter();
          case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:
            return this._eth_getFilterChanges(params);
          case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:
            return this._eth_getFilterLogs(params);
        }
        return void 0;
      }
      _handleSubscriptionMethods(request) {
        switch (request.method) {
          case JSONRPC_1.JSONRPCMethod.eth_subscribe:
          case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:
            return this._subscriptionManager.handleRequest(request);
        }
        return void 0;
      }
      _isKnownAddress(addressString) {
        try {
          const address = (0, util_1.ensureAddressString)(addressString);
          const lowercaseAddresses = this._addresses.map((address2) => (0, util_1.ensureAddressString)(address2));
          return lowercaseAddresses.includes(address);
        } catch (_a) {
        }
        return false;
      }
      _ensureKnownAddress(addressString) {
        if (!this._isKnownAddress(addressString)) {
          this._walletLinkAnalytics.sendEvent(init_1.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED);
          throw new Error("Unknown Ethereum address");
        }
      }
      _prepareTransactionParams(tx) {
        const fromAddress = tx.from ? (0, util_1.ensureAddressString)(tx.from) : this.selectedAddress;
        if (!fromAddress) {
          throw new Error("Ethereum address is unavailable");
        }
        this._ensureKnownAddress(fromAddress);
        const toAddress = tx.to ? (0, util_1.ensureAddressString)(tx.to) : null;
        const weiValue = tx.value != null ? (0, util_1.ensureBN)(tx.value) : new bn_js_1.default(0);
        const data = tx.data ? (0, util_1.ensureBuffer)(tx.data) : Buffer.alloc(0);
        const nonce = tx.nonce != null ? (0, util_1.ensureIntNumber)(tx.nonce) : null;
        const gasPriceInWei = tx.gasPrice != null ? (0, util_1.ensureBN)(tx.gasPrice) : null;
        const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1.ensureBN)(tx.maxFeePerGas) : null;
        const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1.ensureBN)(tx.maxPriorityFeePerGas) : null;
        const gasLimit = tx.gas != null ? (0, util_1.ensureBN)(tx.gas) : null;
        const chainId = this.getChainId();
        return {
          fromAddress,
          toAddress,
          weiValue,
          data,
          nonce,
          gasPriceInWei,
          maxFeePerGas,
          maxPriorityFeePerGas,
          gasLimit,
          chainId
        };
      }
      _requireAuthorization() {
        if (this._addresses.length === 0) {
          throw eth_rpc_errors_1.ethErrors.provider.unauthorized({});
        }
      }
      _throwUnsupportedMethodError() {
        throw eth_rpc_errors_1.ethErrors.provider.unsupportedMethod({});
      }
      async _signEthereumMessage(message, address, addPrefix, typedDataJson) {
        this._ensureKnownAddress(address);
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied message signature");
          }
          throw err;
        }
      }
      async _ethereumAddressFromSignedMessage(message, signature, addPrefix) {
        const relay = await this.initializeRelay();
        const res = await relay.ethereumAddressFromSignedMessage(message, signature, addPrefix).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      _eth_accounts() {
        return [...this._addresses];
      }
      _eth_coinbase() {
        return this.selectedAddress || null;
      }
      _net_version() {
        return this.getChainId().toString(10);
      }
      _eth_chainId() {
        return (0, util_1.hexStringFromIntNumber)(this.getChainId());
      }
      getChainId() {
        const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY) || "1";
        const chainId = parseInt(chainIdStr, 10);
        return (0, util_1.ensureIntNumber)(chainId);
      }
      async _eth_requestAccounts() {
        this._walletLinkAnalytics.sendEvent(init_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::_eth_requestAccounts",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : null
        });
        if (this._addresses.length > 0) {
          return Promise.resolve({
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
          });
        }
        let res;
        try {
          const relay = await this.initializeRelay();
          res = await relay.requestEthereumAccounts().promise;
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied account authorization");
          }
          throw err;
        }
        if (!res.result) {
          throw new Error("accounts received is empty");
        }
        this._setAddresses(res.result);
        return { jsonrpc: "2.0", id: 0, result: this._addresses };
      }
      _eth_sign(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const message = (0, util_1.ensureBuffer)(params[1]);
        return this._signEthereumMessage(message, address, false);
      }
      _eth_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature, false);
      }
      _personal_sign(params) {
        this._requireAuthorization();
        const message = (0, util_1.ensureBuffer)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        return this._signEthereumMessage(message, address, true);
      }
      _personal_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature, true);
      }
      async _eth_signTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_sendRawTransaction(params) {
        const signedTransaction = (0, util_1.ensureBuffer)(params[0]);
        const relay = await this.initializeRelay();
        const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId()).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      async _eth_sendTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signAndSubmitEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_signTypedData_v1(params) {
        this._requireAuthorization();
        const typedData = (0, util_1.ensureParsedJSONObject)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v3(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v3({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v4(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v4({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _walletlink_arbitrary(params) {
        const action = params[0];
        const data = params[1];
        if (typeof data !== "string") {
          throw new Error("parameter must be a string");
        }
        if (typeof action !== "object" || action === null) {
          throw new Error("parameter must be an object");
        }
        const result = await this.genericRequest(action, data);
        return { jsonrpc: "2.0", id: 0, result };
      }
      async _wallet_addEthereumChain(params) {
        var _a, _b, _c, _d;
        const request = params[0];
        if (((_a = request.rpcUrls) === null || _a === void 0 ? void 0 : _a.length) === 0) {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `please pass in at least 1 rpcUrl` }
          };
        }
        if (!request.chainName || request.chainName.trim() === "") {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: 0,
            message: "chainName is a required field"
          });
        }
        if (!request.nativeCurrency) {
          throw eth_rpc_errors_1.ethErrors.provider.custom({
            code: 0,
            message: "nativeCurrency is a required field"
          });
        }
        const chainIdNumber = parseInt(request.chainId, 16);
        const success = await this.addEthereumChain(chainIdNumber, (_b = request.rpcUrls) !== null && _b !== void 0 ? _b : [], (_c = request.blockExplorerUrls) !== null && _c !== void 0 ? _c : [], request.chainName, (_d = request.iconUrls) !== null && _d !== void 0 ? _d : [], request.nativeCurrency);
        if (success) {
          return { jsonrpc: "2.0", id: 0, result: null };
        } else {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `unable to add ethereum chain` }
          };
        }
      }
      async _wallet_switchEthereumChain(params) {
        const request = params[0];
        await this.switchEthereumChain(parseInt(request.chainId, 16));
        return { jsonrpc: "2.0", id: 0, result: null };
      }
      async _wallet_watchAsset(params) {
        var _a;
        const request = Array.isArray(params) ? params[0] : params;
        if (((_a = request.type) === null || _a === void 0 ? void 0 : _a.length) === 0) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "type is a required field"
          });
        }
        if (request.type !== "ERC20") {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Asset of type '${request.type}' not supported`
          });
        }
        if (!(request === null || request === void 0 ? void 0 : request.options)) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "options is a required field"
          });
        }
        if (!request.options.address) {
          throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: "option address is a required option"
          });
        }
        const { address, symbol, image, decimals } = request.options;
        const res = await this.watchAsset(request.type, address, symbol, decimals, image);
        return { jsonrpc: "2.0", id: 0, result: res };
      }
      _eth_uninstallFilter(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.uninstallFilter(filterId);
      }
      async _eth_newFilter(params) {
        const param = params[0];
        const filterId = await this._filterPolyfill.newFilter(param);
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newBlockFilter() {
        const filterId = await this._filterPolyfill.newBlockFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newPendingTransactionFilter() {
        const filterId = await this._filterPolyfill.newPendingTransactionFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      _eth_getFilterChanges(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterChanges(filterId);
      }
      _eth_getFilterLogs(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterLogs(filterId);
      }
      initializeRelay() {
        if (this._relay) {
          return Promise.resolve(this._relay);
        }
        return this._relayProvider().then((relay) => {
          relay.setAccountsCallback((accounts) => this._setAddresses(accounts));
          relay.setChainCallback((chainId, jsonRpcUrl) => {
            this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10), true);
          });
          this._relay = relay;
          return relay;
        });
      }
    };
    exports.WalletLinkProvider = WalletLinkProvider;
  }
});

// node_modules/walletlink/dist/lib/ScopedLocalStorage.js
var require_ScopedLocalStorage = __commonJS({
  "node_modules/walletlink/dist/lib/ScopedLocalStorage.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopedLocalStorage = void 0;
    var ScopedLocalStorage = class {
      constructor(scope) {
        this.scope = scope;
      }
      setItem(key, value) {
        localStorage.setItem(this.scopedKey(key), value);
      }
      getItem(key) {
        return localStorage.getItem(this.scopedKey(key));
      }
      removeItem(key) {
        localStorage.removeItem(this.scopedKey(key));
      }
      clear() {
        const prefix = this.scopedKey("");
        const keysToRemove = [];
        for (let i3 = 0; i3 < localStorage.length; i3++) {
          const key = localStorage.key(i3);
          if (typeof key === "string" && key.startsWith(prefix)) {
            keysToRemove.push(key);
          }
        }
        keysToRemove.forEach((key) => localStorage.removeItem(key));
      }
      scopedKey(key) {
        return `${this.scope}:${key}`;
      }
    };
    exports.ScopedLocalStorage = ScopedLocalStorage;
  }
});

// node_modules/walletlink/node_modules/preact/dist/preact.module.js
var preact_module_exports = {};
__export(preact_module_exports, {
  Component: () => _,
  Fragment: () => d,
  cloneElement: () => B,
  createContext: () => D,
  createElement: () => v,
  createRef: () => p,
  h: () => v,
  hydrate: () => q,
  isValidElement: () => i,
  options: () => l,
  render: () => S,
  toChildArray: () => A
});
function a(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function h(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function v(l3, u3, i3) {
  var t3, o3, r3, f3 = {};
  for (r3 in u3)
    r3 == "key" ? t3 = u3[r3] : r3 == "ref" ? o3 = u3[r3] : f3[r3] = u3[r3];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), typeof l3 == "function" && l3.defaultProps != null)
    for (r3 in l3.defaultProps)
      f3[r3] === void 0 && (f3[r3] = l3.defaultProps[r3]);
  return y(l3, f3, t3, o3, null);
}
function y(n2, i3, t3, o3, r3) {
  var f3 = { type: n2, props: i3, key: t3, ref: o3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: r3 == null ? ++u : r3 };
  return r3 == null && l.vnode != null && l.vnode(f3), f3;
}
function p() {
  return { current: null };
}
function d(n2) {
  return n2.children;
}
function _(n2, l3) {
  this.props = n2, this.context = l3;
}
function k(n2, l3) {
  if (l3 == null)
    return n2.__ ? k(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if ((u3 = n2.__k[l3]) != null && u3.__e != null)
      return u3.__e;
  return typeof n2.type == "function" ? k(n2) : null;
}
function b(n2) {
  var l3, u3;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if ((u3 = n2.__k[l3]) != null && u3.__e != null) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return b(n2);
  }
}
function m(n2) {
  (!n2.__d && (n2.__d = true) && t.push(n2) && !g.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(g);
}
function g() {
  for (var n2; g.__r = t.length; )
    n2 = t.sort(function(n3, l3) {
      return n3.__v.__b - l3.__v.__b;
    }), t = [], n2.some(function(n3) {
      var l3, u3, i3, t3, o3, r3;
      n3.__d && (o3 = (t3 = (l3 = n3).__v).__e, (r3 = l3.__P) && (u3 = [], (i3 = a({}, t3)).__v = t3.__v + 1, j(r3, t3, i3, l3.__n, r3.ownerSVGElement !== void 0, t3.__h != null ? [o3] : null, u3, o3 == null ? k(t3) : o3, t3.__h), z(u3, t3), t3.__e != o3 && b(t3)));
    });
}
function w(n2, l3, u3, i3, t3, o3, r3, f3, s3, a3) {
  var h3, v3, p3, _3, b3, m3, g3, w3 = i3 && i3.__k || c, A3 = w3.length;
  for (u3.__k = [], h3 = 0; h3 < l3.length; h3++)
    if ((_3 = u3.__k[h3] = (_3 = l3[h3]) == null || typeof _3 == "boolean" ? null : typeof _3 == "string" || typeof _3 == "number" || typeof _3 == "bigint" ? y(null, _3, null, null, _3) : Array.isArray(_3) ? y(d, { children: _3 }, null, null, null) : _3.__b > 0 ? y(_3.type, _3.props, _3.key, null, _3.__v) : _3) != null) {
      if (_3.__ = u3, _3.__b = u3.__b + 1, (p3 = w3[h3]) === null || p3 && _3.key == p3.key && _3.type === p3.type)
        w3[h3] = void 0;
      else
        for (v3 = 0; v3 < A3; v3++) {
          if ((p3 = w3[v3]) && _3.key == p3.key && _3.type === p3.type) {
            w3[v3] = void 0;
            break;
          }
          p3 = null;
        }
      j(n2, _3, p3 = p3 || e, t3, o3, r3, f3, s3, a3), b3 = _3.__e, (v3 = _3.ref) && p3.ref != v3 && (g3 || (g3 = []), p3.ref && g3.push(p3.ref, null, _3), g3.push(v3, _3.__c || b3, _3)), b3 != null ? (m3 == null && (m3 = b3), typeof _3.type == "function" && _3.__k === p3.__k ? _3.__d = s3 = x(_3, s3, n2) : s3 = P(n2, _3, p3, w3, b3, s3), typeof u3.type == "function" && (u3.__d = s3)) : s3 && p3.__e == s3 && s3.parentNode != n2 && (s3 = k(p3));
    }
  for (u3.__e = m3, h3 = A3; h3--; )
    w3[h3] != null && (typeof u3.type == "function" && w3[h3].__e != null && w3[h3].__e == u3.__d && (u3.__d = k(i3, h3 + 1)), N(w3[h3], w3[h3]));
  if (g3)
    for (h3 = 0; h3 < g3.length; h3++)
      M(g3[h3], g3[++h3], g3[++h3]);
}
function x(n2, l3, u3) {
  for (var i3, t3 = n2.__k, o3 = 0; t3 && o3 < t3.length; o3++)
    (i3 = t3[o3]) && (i3.__ = n2, l3 = typeof i3.type == "function" ? x(i3, l3, u3) : P(u3, i3, i3, t3, i3.__e, l3));
  return l3;
}
function A(n2, l3) {
  return l3 = l3 || [], n2 == null || typeof n2 == "boolean" || (Array.isArray(n2) ? n2.some(function(n3) {
    A(n3, l3);
  }) : l3.push(n2)), l3;
}
function P(n2, l3, u3, i3, t3, o3) {
  var r3, f3, e3;
  if (l3.__d !== void 0)
    r3 = l3.__d, l3.__d = void 0;
  else if (u3 == null || t3 != o3 || t3.parentNode == null)
    n:
      if (o3 == null || o3.parentNode !== n2)
        n2.appendChild(t3), r3 = null;
      else {
        for (f3 = o3, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 2)
          if (f3 == t3)
            break n;
        n2.insertBefore(t3, o3), r3 = o3;
      }
  return r3 !== void 0 ? r3 : t3.nextSibling;
}
function C(n2, l3, u3, i3, t3) {
  var o3;
  for (o3 in u3)
    o3 === "children" || o3 === "key" || o3 in l3 || H(n2, o3, null, u3[o3], i3);
  for (o3 in l3)
    t3 && typeof l3[o3] != "function" || o3 === "children" || o3 === "key" || o3 === "value" || o3 === "checked" || u3[o3] === l3[o3] || H(n2, o3, l3[o3], u3[o3], i3);
}
function $(n2, l3, u3) {
  l3[0] === "-" ? n2.setProperty(l3, u3) : n2[l3] = u3 == null ? "" : typeof u3 != "number" || s.test(l3) ? u3 : u3 + "px";
}
function H(n2, l3, u3, i3, t3) {
  var o3;
  n:
    if (l3 === "style")
      if (typeof u3 == "string")
        n2.style.cssText = u3;
      else {
        if (typeof i3 == "string" && (n2.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || $(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || $(n2.style, l3, u3[l3]);
      }
    else if (l3[0] === "o" && l3[1] === "n")
      o3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + o3] = u3, u3 ? i3 || n2.addEventListener(l3, o3 ? T : I, o3) : n2.removeEventListener(l3, o3 ? T : I, o3);
    else if (l3 !== "dangerouslySetInnerHTML") {
      if (t3)
        l3 = l3.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
      else if (l3 !== "href" && l3 !== "list" && l3 !== "form" && l3 !== "tabIndex" && l3 !== "download" && l3 in n2)
        try {
          n2[l3] = u3 == null ? "" : u3;
          break n;
        } catch (n3) {
        }
      typeof u3 == "function" || (u3 != null && (u3 !== false || l3[0] === "a" && l3[1] === "r") ? n2.setAttribute(l3, u3) : n2.removeAttribute(l3));
    }
}
function I(n2) {
  this.l[n2.type + false](l.event ? l.event(n2) : n2);
}
function T(n2) {
  this.l[n2.type + true](l.event ? l.event(n2) : n2);
}
function j(n2, u3, i3, t3, o3, r3, f3, e3, c3) {
  var s3, h3, v3, y3, p3, k3, b3, m3, g3, x3, A3, P2 = u3.type;
  if (u3.constructor !== void 0)
    return null;
  i3.__h != null && (c3 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, r3 = [e3]), (s3 = l.__b) && s3(u3);
  try {
    n:
      if (typeof P2 == "function") {
        if (m3 = u3.props, g3 = (s3 = P2.contextType) && t3[s3.__c], x3 = s3 ? g3 ? g3.props.value : s3.__ : t3, i3.__c ? b3 = (h3 = u3.__c = i3.__c).__ = h3.__E : ("prototype" in P2 && P2.prototype.render ? u3.__c = h3 = new P2(m3, x3) : (u3.__c = h3 = new _(m3, x3), h3.constructor = P2, h3.render = O), g3 && g3.sub(h3), h3.props = m3, h3.state || (h3.state = {}), h3.context = x3, h3.__n = t3, v3 = h3.__d = true, h3.__h = []), h3.__s == null && (h3.__s = h3.state), P2.getDerivedStateFromProps != null && (h3.__s == h3.state && (h3.__s = a({}, h3.__s)), a(h3.__s, P2.getDerivedStateFromProps(m3, h3.__s))), y3 = h3.props, p3 = h3.state, v3)
          P2.getDerivedStateFromProps == null && h3.componentWillMount != null && h3.componentWillMount(), h3.componentDidMount != null && h3.__h.push(h3.componentDidMount);
        else {
          if (P2.getDerivedStateFromProps == null && m3 !== y3 && h3.componentWillReceiveProps != null && h3.componentWillReceiveProps(m3, x3), !h3.__e && h3.shouldComponentUpdate != null && h3.shouldComponentUpdate(m3, h3.__s, x3) === false || u3.__v === i3.__v) {
            h3.props = m3, h3.state = h3.__s, u3.__v !== i3.__v && (h3.__d = false), h3.__v = u3, u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), h3.__h.length && f3.push(h3);
            break n;
          }
          h3.componentWillUpdate != null && h3.componentWillUpdate(m3, h3.__s, x3), h3.componentDidUpdate != null && h3.__h.push(function() {
            h3.componentDidUpdate(y3, p3, k3);
          });
        }
        h3.context = x3, h3.props = m3, h3.state = h3.__s, (s3 = l.__r) && s3(u3), h3.__d = false, h3.__v = u3, h3.__P = n2, s3 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s, h3.getChildContext != null && (t3 = a(a({}, t3), h3.getChildContext())), v3 || h3.getSnapshotBeforeUpdate == null || (k3 = h3.getSnapshotBeforeUpdate(y3, p3)), A3 = s3 != null && s3.type === d && s3.key == null ? s3.props.children : s3, w(n2, Array.isArray(A3) ? A3 : [A3], u3, i3, t3, o3, r3, f3, e3, c3), h3.base = u3.__e, u3.__h = null, h3.__h.length && f3.push(h3), b3 && (h3.__E = h3.__ = null), h3.__e = false;
      } else
        r3 == null && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = L(i3.__e, u3, i3, t3, o3, r3, f3, c3);
    (s3 = l.diffed) && s3(u3);
  } catch (n3) {
    u3.__v = null, (c3 || r3 != null) && (u3.__e = e3, u3.__h = !!c3, r3[r3.indexOf(e3)] = null), l.__e(n3, u3, i3);
  }
}
function z(n2, u3) {
  l.__c && l.__c(u3, n2), n2.some(function(u4) {
    try {
      n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
        n3.call(u4);
      });
    } catch (n3) {
      l.__e(n3, u4.__v);
    }
  });
}
function L(l3, u3, i3, t3, o3, r3, f3, c3) {
  var s3, a3, v3, y3 = i3.props, p3 = u3.props, d3 = u3.type, _3 = 0;
  if (d3 === "svg" && (o3 = true), r3 != null) {
    for (; _3 < r3.length; _3++)
      if ((s3 = r3[_3]) && "setAttribute" in s3 == !!d3 && (d3 ? s3.localName === d3 : s3.nodeType === 3)) {
        l3 = s3, r3[_3] = null;
        break;
      }
  }
  if (l3 == null) {
    if (d3 === null)
      return document.createTextNode(p3);
    l3 = o3 ? document.createElementNS("http://www.w3.org/2000/svg", d3) : document.createElement(d3, p3.is && p3), r3 = null, c3 = false;
  }
  if (d3 === null)
    y3 === p3 || c3 && l3.data === p3 || (l3.data = p3);
  else {
    if (r3 = r3 && n.call(l3.childNodes), a3 = (y3 = i3.props || e).dangerouslySetInnerHTML, v3 = p3.dangerouslySetInnerHTML, !c3) {
      if (r3 != null)
        for (y3 = {}, _3 = 0; _3 < l3.attributes.length; _3++)
          y3[l3.attributes[_3].name] = l3.attributes[_3].value;
      (v3 || a3) && (v3 && (a3 && v3.__html == a3.__html || v3.__html === l3.innerHTML) || (l3.innerHTML = v3 && v3.__html || ""));
    }
    if (C(l3, p3, y3, o3, c3), v3)
      u3.__k = [];
    else if (_3 = u3.props.children, w(l3, Array.isArray(_3) ? _3 : [_3], u3, i3, t3, o3 && d3 !== "foreignObject", r3, f3, r3 ? r3[0] : i3.__k && k(i3, 0), c3), r3 != null)
      for (_3 = r3.length; _3--; )
        r3[_3] != null && h(r3[_3]);
    c3 || ("value" in p3 && (_3 = p3.value) !== void 0 && (_3 !== l3.value || d3 === "progress" && !_3 || d3 === "option" && _3 !== y3.value) && H(l3, "value", _3, y3.value, false), "checked" in p3 && (_3 = p3.checked) !== void 0 && _3 !== l3.checked && H(l3, "checked", _3, y3.checked, false));
  }
  return l3;
}
function M(n2, u3, i3) {
  try {
    typeof n2 == "function" ? n2(u3) : n2.current = u3;
  } catch (n3) {
    l.__e(n3, i3);
  }
}
function N(n2, u3, i3) {
  var t3, o3;
  if (l.unmount && l.unmount(n2), (t3 = n2.ref) && (t3.current && t3.current !== n2.__e || M(t3, null, u3)), (t3 = n2.__c) != null) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
    t3.base = t3.__P = null;
  }
  if (t3 = n2.__k)
    for (o3 = 0; o3 < t3.length; o3++)
      t3[o3] && N(t3[o3], u3, typeof n2.type != "function");
  i3 || n2.__e == null || h(n2.__e), n2.__e = n2.__d = void 0;
}
function O(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function S(u3, i3, t3) {
  var o3, r3, f3;
  l.__ && l.__(u3, i3), r3 = (o3 = typeof t3 == "function") ? null : t3 && t3.__k || i3.__k, f3 = [], j(i3, u3 = (!o3 && t3 || i3).__k = v(d, null, [u3]), r3 || e, e, i3.ownerSVGElement !== void 0, !o3 && t3 ? [t3] : r3 ? null : i3.firstChild ? n.call(i3.childNodes) : null, f3, !o3 && t3 ? t3 : r3 ? r3.__e : i3.firstChild, o3), z(f3, u3);
}
function q(n2, l3) {
  S(n2, l3, q);
}
function B(l3, u3, i3) {
  var t3, o3, r3, f3 = a({}, l3.props);
  for (r3 in u3)
    r3 == "key" ? t3 = u3[r3] : r3 == "ref" ? o3 = u3[r3] : f3[r3] = u3[r3];
  return arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), y(l3.type, f3, t3 || l3.key, o3 || l3.ref, null);
}
function D(n2, l3) {
  var u3 = { __c: l3 = "__cC" + f++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u4, i3;
    return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u4.some(m);
    }, this.sub = function(n4) {
      u4.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
var n, l, u, i, t, o, r, f, e, c, s;
var init_preact_module = __esm({
  "node_modules/walletlink/node_modules/preact/dist/preact.module.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    e = {};
    c = [];
    s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    n = c.slice, l = { __e: function(n2, l3) {
      for (var u3, i3, t3; l3 = l3.__; )
        if ((u3 = l3.__c) && !u3.__)
          try {
            if ((i3 = u3.constructor) && i3.getDerivedStateFromError != null && (u3.setState(i3.getDerivedStateFromError(n2)), t3 = u3.__d), u3.componentDidCatch != null && (u3.componentDidCatch(n2), t3 = u3.__d), t3)
              return u3.__E = u3;
          } catch (l4) {
            n2 = l4;
          }
      throw n2;
    } }, u = 0, i = function(n2) {
      return n2 != null && n2.constructor === void 0;
    }, _.prototype.setState = function(n2, l3) {
      var u3;
      u3 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), typeof n2 == "function" && (n2 = n2(a({}, u3), this.props)), n2 && a(u3, n2), n2 != null && this.__v && (l3 && this.__h.push(l3), m(this));
    }, _.prototype.forceUpdate = function(n2) {
      this.__v && (this.__e = true, n2 && this.__h.push(n2), m(this));
    }, _.prototype.render = d, t = [], o = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g.__r = 0, f = 0;
  }
});

// node_modules/walletlink/node_modules/preact/hooks/dist/hooks.module.js
var hooks_module_exports = {};
__export(hooks_module_exports, {
  useCallback: () => A2,
  useContext: () => F,
  useDebugValue: () => T2,
  useEffect: () => y2,
  useErrorBoundary: () => q2,
  useImperativeHandle: () => _2,
  useLayoutEffect: () => h2,
  useMemo: () => d2,
  useReducer: () => p2,
  useRef: () => s2,
  useState: () => l2
});
function m2(t3, r3) {
  l.__h && l.__h(u2, t3, o2 || r3), o2 = 0;
  var i3 = u2.__H || (u2.__H = { __: [], __h: [] });
  return t3 >= i3.__.length && i3.__.push({}), i3.__[t3];
}
function l2(n2) {
  return o2 = 1, p2(w2, n2);
}
function p2(n2, r3, o3) {
  var i3 = m2(t2++, 2);
  return i3.t = n2, i3.__c || (i3.__ = [o3 ? o3(r3) : w2(void 0, r3), function(n3) {
    var t3 = i3.t(i3.__[0], n3);
    i3.__[0] !== t3 && (i3.__ = [t3, i3.__[1]], i3.__c.setState({}));
  }], i3.__c = u2), i3.__;
}
function y2(r3, o3) {
  var i3 = m2(t2++, 3);
  !l.__s && k2(i3.__H, o3) && (i3.__ = r3, i3.__H = o3, u2.__H.__h.push(i3));
}
function h2(r3, o3) {
  var i3 = m2(t2++, 4);
  !l.__s && k2(i3.__H, o3) && (i3.__ = r3, i3.__H = o3, u2.__h.push(i3));
}
function s2(n2) {
  return o2 = 5, d2(function() {
    return { current: n2 };
  }, []);
}
function _2(n2, t3, u3) {
  o2 = 6, h2(function() {
    typeof n2 == "function" ? n2(t3()) : n2 && (n2.current = t3());
  }, u3 == null ? u3 : u3.concat(n2));
}
function d2(n2, u3) {
  var r3 = m2(t2++, 7);
  return k2(r3.__H, u3) && (r3.__ = n2(), r3.__H = u3, r3.__h = n2), r3.__;
}
function A2(n2, t3) {
  return o2 = 8, d2(function() {
    return n2;
  }, t3);
}
function F(n2) {
  var r3 = u2.context[n2.__c], o3 = m2(t2++, 9);
  return o3.c = n2, r3 ? (o3.__ == null && (o3.__ = true, r3.sub(u2)), r3.props.value) : n2.__;
}
function T2(t3, u3) {
  l.useDebugValue && l.useDebugValue(u3 ? u3(t3) : t3);
}
function q2(n2) {
  var r3 = m2(t2++, 10), o3 = l2();
  return r3.__ = n2, u2.componentDidCatch || (u2.componentDidCatch = function(n3) {
    r3.__ && r3.__(n3), o3[1](n3);
  }), [o3[0], function() {
    o3[1](void 0);
  }];
}
function x2() {
  for (var t3; t3 = i2.shift(); )
    if (t3.__P)
      try {
        t3.__H.__h.forEach(g2), t3.__H.__h.forEach(j2), t3.__H.__h = [];
      } catch (u3) {
        t3.__H.__h = [], l.__e(u3, t3.__v);
      }
}
function g2(n2) {
  var t3 = u2, r3 = n2.__c;
  typeof r3 == "function" && (n2.__c = void 0, r3()), u2 = t3;
}
function j2(n2) {
  var t3 = u2;
  n2.__c = n2.__(), u2 = t3;
}
function k2(n2, t3) {
  return !n2 || n2.length !== t3.length || t3.some(function(t4, u3) {
    return t4 !== n2[u3];
  });
}
function w2(n2, t3) {
  return typeof t3 == "function" ? t3(n2) : t3;
}
var t2, u2, r2, o2, i2, c2, f2, e2, a2, v2, b2;
var init_hooks_module = __esm({
  "node_modules/walletlink/node_modules/preact/hooks/dist/hooks.module.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_preact_module();
    o2 = 0;
    i2 = [];
    c2 = l.__b;
    f2 = l.__r;
    e2 = l.diffed;
    a2 = l.__c;
    v2 = l.unmount;
    l.__b = function(n2) {
      u2 = null, c2 && c2(n2);
    }, l.__r = function(n2) {
      f2 && f2(n2), t2 = 0;
      var r3 = (u2 = n2.__c).__H;
      r3 && (r3.__h.forEach(g2), r3.__h.forEach(j2), r3.__h = []);
    }, l.diffed = function(t3) {
      e2 && e2(t3);
      var o3 = t3.__c;
      o3 && o3.__H && o3.__H.__h.length && (i2.push(o3) !== 1 && r2 === l.requestAnimationFrame || ((r2 = l.requestAnimationFrame) || function(n2) {
        var t4, u3 = function() {
          clearTimeout(r3), b2 && cancelAnimationFrame(t4), setTimeout(n2);
        }, r3 = setTimeout(u3, 100);
        b2 && (t4 = requestAnimationFrame(u3));
      })(x2)), u2 = null;
    }, l.__c = function(t3, u3) {
      u3.some(function(t4) {
        try {
          t4.__h.forEach(g2), t4.__h = t4.__h.filter(function(n2) {
            return !n2.__ || j2(n2);
          });
        } catch (r3) {
          u3.some(function(n2) {
            n2.__h && (n2.__h = []);
          }), u3 = [], l.__e(r3, t4.__v);
        }
      }), a2 && a2(t3, u3);
    }, l.unmount = function(t3) {
      v2 && v2(t3);
      var u3, r3 = t3.__c;
      r3 && r3.__H && (r3.__H.__.forEach(function(n2) {
        try {
          g2(n2);
        } catch (n3) {
          u3 = n3;
        }
      }), u3 && l.__e(u3, r3.__v));
    };
    b2 = typeof requestAnimationFrame == "function";
  }
});

// node_modules/walletlink/dist/components/LinkDialog-css.js
var require_LinkDialog_css = __commonJS({
  "node_modules/walletlink/dist/components/LinkDialog-css.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-walletlink-css-reset .-walletlink-link-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-walletlink-css-reset .-walletlink-link-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;background-color:rgba(0,0,0,.33);transition:opacity .25s}.-walletlink-css-reset .-walletlink-link-dialog-backdrop-hidden{opacity:0}.-walletlink-css-reset .-walletlink-link-dialog-box{display:flex;position:relative;flex-direction:column;background-color:#f6f6f6;border-radius:16px;box-shadow:0px 16px 24px rgba(0,0,0,.1),0px 0px 8px rgba(0,0,0,.05);transform:scale(1);transition:opacity .25s,transform .25s;overflow:hidden}.-walletlink-css-reset .-walletlink-link-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-walletlink-css-reset .-walletlink-link-dialog-box-content{padding:24px;text-align:center}.-walletlink-css-reset .-walletlink-link-dialog-box-content h3{display:block;margin-bottom:24px;text-align:left;text-transform:uppercase;font-size:22px;font-weight:bold;line-height:1.2;color:#000}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode{position:relative;display:block;margin-bottom:24px;background-color:#f6f6f6;padding:16px;border-radius:16px;box-shadow:4px 4px 8px rgba(0,0,0,.15),-8px -8px 8px #fff;overflow:hidden}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-wrapper{display:block;width:232px;height:232px;padding:4px;border-radius:4px;background:#f4f4f4;margin-bottom:16px}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-wrapper img{display:block;width:224px;height:224px}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode>p{display:block;color:gray;font-weight:bold;font-size:12px;text-align:center}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-connecting{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(246,246,246,.98)}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-connecting p{margin-top:16px;color:#333;font-size:12px;font-weight:bold}.-walletlink-css-reset .-walletlink-link-dialog-box-content a{text-align:center;cursor:pointer;transition:color .1s;font-size:14px}.-walletlink-css-reset .-walletlink-link-dialog-box-content a,.-walletlink-css-reset .-walletlink-link-dialog-box-content a:link,.-walletlink-css-reset .-walletlink-link-dialog-box-content a:visited{color:#999}.-walletlink-css-reset .-walletlink-link-dialog-box-content a:hover,.-walletlink-css-reset .-walletlink-link-dialog-box-content a:active{color:#666;text-decoration:underline}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel{position:absolute;-webkit-appearance:none;display:flex;align-items:center;justify-content:center;top:24px;right:24px;width:24px;height:24px;border-radius:12px;background-color:#e7e7e7;cursor:pointer}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x{position:relative;display:block}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::after{content:"";position:absolute;display:block;top:-1px;left:-7px;width:14px;height:2px;background-color:#999;transition:background-color .2s}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::before{transform:rotate(45deg)}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::after{transform:rotate(135deg)}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-a,.-walletlink-css-reset .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-b{background-color:#000}.-walletlink-css-reset .-walletlink-link-dialog-container{display:block}.-walletlink-css-reset .-walletlink-link-dialog-container-hidden{display:none}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box{background-color:#2a2a2a}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content h3{color:#ccc}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode{background-color:#2a2a2a;box-shadow:4px 4px 8px rgba(0,0,0,.5),-8px -8px 8px #343434}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode>p{color:#999}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode-connecting{background:rgba(42,42,42,.98)}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode-connecting p{color:#ddd}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:link,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:visited{color:#888}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:hover,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:active{color:#aaa}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel{background-color:#333}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel-x::after{background-color:#aaa}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x::after{background-color:#eee}`;
  }
});

// node_modules/walletlink/dist/vendor-js/qrcode-svg/index.js
var require_qrcode_svg = __commonJS({
  "node_modules/walletlink/dist/vendor-js/qrcode-svg/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    function QR8bitByte(data) {
      this.mode = QRMode.MODE_8BIT_BYTE;
      this.data = data;
      this.parsedData = [];
      for (var i4 = 0, l3 = this.data.length; i4 < l3; i4++) {
        var byteArray = [];
        var code = this.data.charCodeAt(i4);
        if (code > 65536) {
          byteArray[0] = 240 | (code & 1835008) >>> 18;
          byteArray[1] = 128 | (code & 258048) >>> 12;
          byteArray[2] = 128 | (code & 4032) >>> 6;
          byteArray[3] = 128 | code & 63;
        } else if (code > 2048) {
          byteArray[0] = 224 | (code & 61440) >>> 12;
          byteArray[1] = 128 | (code & 4032) >>> 6;
          byteArray[2] = 128 | code & 63;
        } else if (code > 128) {
          byteArray[0] = 192 | (code & 1984) >>> 6;
          byteArray[1] = 128 | code & 63;
        } else {
          byteArray[0] = code;
        }
        this.parsedData.push(byteArray);
      }
      this.parsedData = Array.prototype.concat.apply([], this.parsedData);
      if (this.parsedData.length != this.data.length) {
        this.parsedData.unshift(191);
        this.parsedData.unshift(187);
        this.parsedData.unshift(239);
      }
    }
    QR8bitByte.prototype = {
      getLength: function(buffer) {
        return this.parsedData.length;
      },
      write: function(buffer) {
        for (var i4 = 0, l3 = this.parsedData.length; i4 < l3; i4++) {
          buffer.put(this.parsedData[i4], 8);
        }
      }
    };
    function QRCodeModel(typeNumber, errorCorrectLevel) {
      this.typeNumber = typeNumber;
      this.errorCorrectLevel = errorCorrectLevel;
      this.modules = null;
      this.moduleCount = 0;
      this.dataCache = null;
      this.dataList = [];
    }
    QRCodeModel.prototype = { addData: function(data) {
      var newData = new QR8bitByte(data);
      this.dataList.push(newData);
      this.dataCache = null;
    }, isDark: function(row, col) {
      if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
        throw new Error(row + "," + col);
      }
      return this.modules[row][col];
    }, getModuleCount: function() {
      return this.moduleCount;
    }, make: function() {
      this.makeImpl(false, this.getBestMaskPattern());
    }, makeImpl: function(test, maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (var row = 0; row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
        for (var col = 0; col < this.moduleCount; col++) {
          this.modules[row][col] = null;
        }
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(test, maskPattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(test);
      }
      if (this.dataCache == null) {
        this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      }
      this.mapData(this.dataCache, maskPattern);
    }, setupPositionProbePattern: function(row, col) {
      for (var r3 = -1; r3 <= 7; r3++) {
        if (row + r3 <= -1 || this.moduleCount <= row + r3)
          continue;
        for (var c3 = -1; c3 <= 7; c3++) {
          if (col + c3 <= -1 || this.moduleCount <= col + c3)
            continue;
          if (0 <= r3 && r3 <= 6 && (c3 == 0 || c3 == 6) || 0 <= c3 && c3 <= 6 && (r3 == 0 || r3 == 6) || 2 <= r3 && r3 <= 4 && 2 <= c3 && c3 <= 4) {
            this.modules[row + r3][col + c3] = true;
          } else {
            this.modules[row + r3][col + c3] = false;
          }
        }
      }
    }, getBestMaskPattern: function() {
      var minLostPoint = 0;
      var pattern = 0;
      for (var i4 = 0; i4 < 8; i4++) {
        this.makeImpl(true, i4);
        var lostPoint = QRUtil.getLostPoint(this);
        if (i4 == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i4;
        }
      }
      return pattern;
    }, createMovieClip: function(target_mc, instance_name, depth) {
      var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
      var cs = 1;
      this.make();
      for (var row = 0; row < this.modules.length; row++) {
        var y3 = row * cs;
        for (var col = 0; col < this.modules[row].length; col++) {
          var x3 = col * cs;
          var dark = this.modules[row][col];
          if (dark) {
            qr_mc.beginFill(0, 100);
            qr_mc.moveTo(x3, y3);
            qr_mc.lineTo(x3 + cs, y3);
            qr_mc.lineTo(x3 + cs, y3 + cs);
            qr_mc.lineTo(x3, y3 + cs);
            qr_mc.endFill();
          }
        }
      }
      return qr_mc;
    }, setupTimingPattern: function() {
      for (var r3 = 8; r3 < this.moduleCount - 8; r3++) {
        if (this.modules[r3][6] != null) {
          continue;
        }
        this.modules[r3][6] = r3 % 2 == 0;
      }
      for (var c3 = 8; c3 < this.moduleCount - 8; c3++) {
        if (this.modules[6][c3] != null) {
          continue;
        }
        this.modules[6][c3] = c3 % 2 == 0;
      }
    }, setupPositionAdjustPattern: function() {
      var pos = QRUtil.getPatternPosition(this.typeNumber);
      for (var i4 = 0; i4 < pos.length; i4++) {
        for (var j3 = 0; j3 < pos.length; j3++) {
          var row = pos[i4];
          var col = pos[j3];
          if (this.modules[row][col] != null) {
            continue;
          }
          for (var r3 = -2; r3 <= 2; r3++) {
            for (var c3 = -2; c3 <= 2; c3++) {
              if (r3 == -2 || r3 == 2 || c3 == -2 || c3 == 2 || r3 == 0 && c3 == 0) {
                this.modules[row + r3][col + c3] = true;
              } else {
                this.modules[row + r3][col + c3] = false;
              }
            }
          }
        }
      }
    }, setupTypeNumber: function(test) {
      var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
      for (var i4 = 0; i4 < 18; i4++) {
        var mod = !test && (bits >> i4 & 1) == 1;
        this.modules[Math.floor(i4 / 3)][i4 % 3 + this.moduleCount - 8 - 3] = mod;
      }
      for (var i4 = 0; i4 < 18; i4++) {
        var mod = !test && (bits >> i4 & 1) == 1;
        this.modules[i4 % 3 + this.moduleCount - 8 - 3][Math.floor(i4 / 3)] = mod;
      }
    }, setupTypeInfo: function(test, maskPattern) {
      var data = this.errorCorrectLevel << 3 | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);
      for (var i4 = 0; i4 < 15; i4++) {
        var mod = !test && (bits >> i4 & 1) == 1;
        if (i4 < 6) {
          this.modules[i4][8] = mod;
        } else if (i4 < 8) {
          this.modules[i4 + 1][8] = mod;
        } else {
          this.modules[this.moduleCount - 15 + i4][8] = mod;
        }
      }
      for (var i4 = 0; i4 < 15; i4++) {
        var mod = !test && (bits >> i4 & 1) == 1;
        if (i4 < 8) {
          this.modules[8][this.moduleCount - i4 - 1] = mod;
        } else if (i4 < 9) {
          this.modules[8][15 - i4 - 1 + 1] = mod;
        } else {
          this.modules[8][15 - i4 - 1] = mod;
        }
      }
      this.modules[this.moduleCount - 8][8] = !test;
    }, mapData: function(data, maskPattern) {
      var inc = -1;
      var row = this.moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = this.moduleCount - 1; col > 0; col -= 2) {
        if (col == 6)
          col--;
        while (true) {
          for (var c3 = 0; c3 < 2; c3++) {
            if (this.modules[row][col - c3] == null) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) == 1;
              }
              var mask = QRUtil.getMask(maskPattern, row, col - c3);
              if (mask) {
                dark = !dark;
              }
              this.modules[row][col - c3] = dark;
              bitIndex--;
              if (bitIndex == -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    } };
    QRCodeModel.PAD0 = 236;
    QRCodeModel.PAD1 = 17;
    QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
      var buffer = new QRBitBuffer();
      for (var i4 = 0; i4 < dataList.length; i4++) {
        var data = dataList[i4];
        buffer.put(data.mode, 4);
        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
        data.write(buffer);
      }
      var totalDataCount = 0;
      for (var i4 = 0; i4 < rsBlocks.length; i4++) {
        totalDataCount += rsBlocks[i4].dataCount;
      }
      if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
      }
      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 != 0) {
        buffer.putBit(false);
      }
      while (true) {
        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(QRCodeModel.PAD0, 8);
        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(QRCodeModel.PAD1, 8);
      }
      return QRCodeModel.createBytes(buffer, rsBlocks);
    };
    QRCodeModel.createBytes = function(buffer, rsBlocks) {
      var offset = 0;
      var maxDcCount = 0;
      var maxEcCount = 0;
      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);
      for (var r3 = 0; r3 < rsBlocks.length; r3++) {
        var dcCount = rsBlocks[r3].dataCount;
        var ecCount = rsBlocks[r3].totalCount - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcdata[r3] = new Array(dcCount);
        for (var i4 = 0; i4 < dcdata[r3].length; i4++) {
          dcdata[r3][i4] = 255 & buffer.buffer[i4 + offset];
        }
        offset += dcCount;
        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = new QRPolynomial(dcdata[r3], rsPoly.getLength() - 1);
        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r3] = new Array(rsPoly.getLength() - 1);
        for (var i4 = 0; i4 < ecdata[r3].length; i4++) {
          var modIndex = i4 + modPoly.getLength() - ecdata[r3].length;
          ecdata[r3][i4] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
        }
      }
      var totalCodeCount = 0;
      for (var i4 = 0; i4 < rsBlocks.length; i4++) {
        totalCodeCount += rsBlocks[i4].totalCount;
      }
      var data = new Array(totalCodeCount);
      var index = 0;
      for (var i4 = 0; i4 < maxDcCount; i4++) {
        for (var r3 = 0; r3 < rsBlocks.length; r3++) {
          if (i4 < dcdata[r3].length) {
            data[index++] = dcdata[r3][i4];
          }
        }
      }
      for (var i4 = 0; i4 < maxEcCount; i4++) {
        for (var r3 = 0; r3 < rsBlocks.length; r3++) {
          if (i4 < ecdata[r3].length) {
            data[index++] = ecdata[r3][i4];
          }
        }
      }
      return data;
    };
    var QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
    var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
    var QRMaskPattern = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
    var QRUtil = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, getBCHTypeInfo: function(data) {
      var d3 = data << 10;
      while (QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d3 ^= QRUtil.G15 << QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G15);
      }
      return (data << 10 | d3) ^ QRUtil.G15_MASK;
    }, getBCHTypeNumber: function(data) {
      var d3 = data << 12;
      while (QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d3 ^= QRUtil.G18 << QRUtil.getBCHDigit(d3) - QRUtil.getBCHDigit(QRUtil.G18);
      }
      return data << 12 | d3;
    }, getBCHDigit: function(data) {
      var digit = 0;
      while (data != 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    }, getPatternPosition: function(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    }, getMask: function(maskPattern, i4, j3) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i4 + j3) % 2 == 0;
        case QRMaskPattern.PATTERN001:
          return i4 % 2 == 0;
        case QRMaskPattern.PATTERN010:
          return j3 % 3 == 0;
        case QRMaskPattern.PATTERN011:
          return (i4 + j3) % 3 == 0;
        case QRMaskPattern.PATTERN100:
          return (Math.floor(i4 / 2) + Math.floor(j3 / 3)) % 2 == 0;
        case QRMaskPattern.PATTERN101:
          return i4 * j3 % 2 + i4 * j3 % 3 == 0;
        case QRMaskPattern.PATTERN110:
          return (i4 * j3 % 2 + i4 * j3 % 3) % 2 == 0;
        case QRMaskPattern.PATTERN111:
          return (i4 * j3 % 3 + (i4 + j3) % 2) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }, getErrorCorrectPolynomial: function(errorCorrectLength) {
      var a3 = new QRPolynomial([1], 0);
      for (var i4 = 0; i4 < errorCorrectLength; i4++) {
        a3 = a3.multiply(new QRPolynomial([1, QRMath.gexp(i4)], 0));
      }
      return a3;
    }, getLengthInBits: function(mode, type) {
      if (1 <= type && type < 10) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 10;
          case QRMode.MODE_ALPHA_NUM:
            return 9;
          case QRMode.MODE_8BIT_BYTE:
            return 8;
          case QRMode.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 27) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 12;
          case QRMode.MODE_ALPHA_NUM:
            return 11;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 41) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 14;
          case QRMode.MODE_ALPHA_NUM:
            return 13;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + mode);
        }
      } else {
        throw new Error("type:" + type);
      }
    }, getLostPoint: function(qrCode) {
      var moduleCount = qrCode.getModuleCount();
      var lostPoint = 0;
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount; col++) {
          var sameCount = 0;
          var dark = qrCode.isDark(row, col);
          for (var r3 = -1; r3 <= 1; r3++) {
            if (row + r3 < 0 || moduleCount <= row + r3) {
              continue;
            }
            for (var c3 = -1; c3 <= 1; c3++) {
              if (col + c3 < 0 || moduleCount <= col + c3) {
                continue;
              }
              if (r3 == 0 && c3 == 0) {
                continue;
              }
              if (dark == qrCode.isDark(row + r3, col + c3)) {
                sameCount++;
              }
            }
          }
          if (sameCount > 5) {
            lostPoint += 3 + sameCount - 5;
          }
        }
      }
      for (var row = 0; row < moduleCount - 1; row++) {
        for (var col = 0; col < moduleCount - 1; col++) {
          var count = 0;
          if (qrCode.isDark(row, col))
            count++;
          if (qrCode.isDark(row + 1, col))
            count++;
          if (qrCode.isDark(row, col + 1))
            count++;
          if (qrCode.isDark(row + 1, col + 1))
            count++;
          if (count == 0 || count == 4) {
            lostPoint += 3;
          }
        }
      }
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
            lostPoint += 40;
          }
        }
      }
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
            lostPoint += 40;
          }
        }
      }
      var darkCount = 0;
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) {
            darkCount++;
          }
        }
      }
      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    } };
    var QRMath = { glog: function(n2) {
      if (n2 < 1) {
        throw new Error("glog(" + n2 + ")");
      }
      return QRMath.LOG_TABLE[n2];
    }, gexp: function(n2) {
      while (n2 < 0) {
        n2 += 255;
      }
      while (n2 >= 256) {
        n2 -= 255;
      }
      return QRMath.EXP_TABLE[n2];
    }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
    for (i3 = 0; i3 < 8; i3++) {
      QRMath.EXP_TABLE[i3] = 1 << i3;
    }
    var i3;
    for (i3 = 8; i3 < 256; i3++) {
      QRMath.EXP_TABLE[i3] = QRMath.EXP_TABLE[i3 - 4] ^ QRMath.EXP_TABLE[i3 - 5] ^ QRMath.EXP_TABLE[i3 - 6] ^ QRMath.EXP_TABLE[i3 - 8];
    }
    var i3;
    for (i3 = 0; i3 < 255; i3++) {
      QRMath.LOG_TABLE[QRMath.EXP_TABLE[i3]] = i3;
    }
    var i3;
    function QRPolynomial(num, shift) {
      if (num.length == void 0) {
        throw new Error(num.length + "/" + shift);
      }
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset++;
      }
      this.num = new Array(num.length - offset + shift);
      for (var i4 = 0; i4 < num.length - offset; i4++) {
        this.num[i4] = num[i4 + offset];
      }
    }
    QRPolynomial.prototype = { get: function(index) {
      return this.num[index];
    }, getLength: function() {
      return this.num.length;
    }, multiply: function(e3) {
      var num = new Array(this.getLength() + e3.getLength() - 1);
      for (var i4 = 0; i4 < this.getLength(); i4++) {
        for (var j3 = 0; j3 < e3.getLength(); j3++) {
          num[i4 + j3] ^= QRMath.gexp(QRMath.glog(this.get(i4)) + QRMath.glog(e3.get(j3)));
        }
      }
      return new QRPolynomial(num, 0);
    }, mod: function(e3) {
      if (this.getLength() - e3.getLength() < 0) {
        return this;
      }
      var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e3.get(0));
      var num = new Array(this.getLength());
      for (var i4 = 0; i4 < this.getLength(); i4++) {
        num[i4] = this.get(i4);
      }
      for (var i4 = 0; i4 < e3.getLength(); i4++) {
        num[i4] ^= QRMath.gexp(QRMath.glog(e3.get(i4)) + ratio);
      }
      return new QRPolynomial(num, 0).mod(e3);
    } };
    function QRRSBlock(totalCount, dataCount) {
      this.totalCount = totalCount;
      this.dataCount = dataCount;
    }
    QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
    QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
      var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
      if (rsBlock == void 0) {
        throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
      }
      var length = rsBlock.length / 3;
      var list = [];
      for (var i4 = 0; i4 < length; i4++) {
        var count = rsBlock[i4 * 3 + 0];
        var totalCount = rsBlock[i4 * 3 + 1];
        var dataCount = rsBlock[i4 * 3 + 2];
        for (var j3 = 0; j3 < count; j3++) {
          list.push(new QRRSBlock(totalCount, dataCount));
        }
      }
      return list;
    };
    QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
      switch (errorCorrectLevel) {
        case QRErrorCorrectLevel.L:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        case QRErrorCorrectLevel.M:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        case QRErrorCorrectLevel.Q:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        case QRErrorCorrectLevel.H:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    function QRBitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    QRBitBuffer.prototype = { get: function(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
    }, put: function(num, length) {
      for (var i4 = 0; i4 < length; i4++) {
        this.putBit((num >>> length - i4 - 1 & 1) == 1);
      }
    }, getLengthInBits: function() {
      return this.length;
    }, putBit: function(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    } };
    var QRCodeLimitLength = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
    function QRCode(options) {
      var instance = this;
      this.options = {
        padding: 4,
        width: 256,
        height: 256,
        typeNumber: 4,
        color: "#000000",
        background: "#ffffff",
        ecl: "M",
        image: {
          svg: "",
          width: 0,
          height: 0
        }
      };
      if (typeof options === "string") {
        options = {
          content: options
        };
      }
      if (options) {
        for (var i4 in options) {
          this.options[i4] = options[i4];
        }
      }
      if (typeof this.options.content !== "string") {
        throw new Error("Expected 'content' as string!");
      }
      if (this.options.content.length === 0) {
        throw new Error("Expected 'content' to be non-empty!");
      }
      if (!(this.options.padding >= 0)) {
        throw new Error("Expected 'padding' value to be non-negative!");
      }
      if (!(this.options.width > 0) || !(this.options.height > 0)) {
        throw new Error("Expected 'width' or 'height' value to be higher than zero!");
      }
      function _getErrorCorrectLevel(ecl2) {
        switch (ecl2) {
          case "L":
            return QRErrorCorrectLevel.L;
          case "M":
            return QRErrorCorrectLevel.M;
          case "Q":
            return QRErrorCorrectLevel.Q;
          case "H":
            return QRErrorCorrectLevel.H;
          default:
            throw new Error("Unknwon error correction level: " + ecl2);
        }
      }
      function _getTypeNumber(content2, ecl2) {
        var length = _getUTF8Length(content2);
        var type2 = 1;
        var limit = 0;
        for (var i5 = 0, len = QRCodeLimitLength.length; i5 <= len; i5++) {
          var table = QRCodeLimitLength[i5];
          if (!table) {
            throw new Error("Content too long: expected " + limit + " but got " + length);
          }
          switch (ecl2) {
            case "L":
              limit = table[0];
              break;
            case "M":
              limit = table[1];
              break;
            case "Q":
              limit = table[2];
              break;
            case "H":
              limit = table[3];
              break;
            default:
              throw new Error("Unknwon error correction level: " + ecl2);
          }
          if (length <= limit) {
            break;
          }
          type2++;
        }
        if (type2 > QRCodeLimitLength.length) {
          throw new Error("Content too long");
        }
        return type2;
      }
      function _getUTF8Length(content2) {
        var result = encodeURI(content2).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
        return result.length + (result.length != content2 ? 3 : 0);
      }
      var content = this.options.content;
      var type = _getTypeNumber(content, this.options.ecl);
      var ecl = _getErrorCorrectLevel(this.options.ecl);
      this.qrcode = new QRCodeModel(type, ecl);
      this.qrcode.addData(content);
      this.qrcode.make();
    }
    QRCode.prototype.svg = function(opt) {
      var options = this.options || {};
      var modules = this.qrcode.modules;
      if (typeof opt == "undefined") {
        opt = { container: options.container || "svg" };
      }
      var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;
      var indent = pretty ? "  " : "";
      var EOL = pretty ? "\r\n" : "";
      var width = options.width;
      var height = options.height;
      var length = modules.length;
      var xsize = width / (length + 2 * options.padding);
      var ysize = height / (length + 2 * options.padding);
      var join = typeof options.join != "undefined" ? !!options.join : false;
      var swap = typeof options.swap != "undefined" ? !!options.swap : false;
      var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;
      var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
      var defs = predefined ? indent + '<defs><path id="qrmodule" d="M0 0 h' + ysize + " v" + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : "";
      var bgrect = indent + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;
      var modrect = "";
      var pathdata = "";
      for (var y3 = 0; y3 < length; y3++) {
        for (var x3 = 0; x3 < length; x3++) {
          var module2 = modules[x3][y3];
          if (module2) {
            var px = x3 * xsize + options.padding * xsize;
            var py = y3 * ysize + options.padding * ysize;
            if (swap) {
              var t3 = px;
              px = py;
              py = t3;
            }
            if (join) {
              var w3 = xsize + px;
              var h3 = ysize + py;
              px = Number.isInteger(px) ? Number(px) : px.toFixed(2);
              py = Number.isInteger(py) ? Number(py) : py.toFixed(2);
              w3 = Number.isInteger(w3) ? Number(w3) : w3.toFixed(2);
              h3 = Number.isInteger(h3) ? Number(h3) : h3.toFixed(2);
              pathdata += "M" + px + "," + py + " V" + h3 + " H" + w3 + " V" + py + " H" + px + " Z ";
            } else if (predefined) {
              modrect += indent + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
            } else {
              modrect += indent + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
            }
          }
        }
      }
      if (join) {
        modrect = indent + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
      }
      let imgSvg = "";
      if (this.options.image !== void 0 && this.options.image.svg) {
        const imgWidth = width * this.options.image.width / 100;
        const imgHeight = height * this.options.image.height / 100;
        const imgX = width / 2 - imgWidth / 2;
        const imgY = height / 2 - imgHeight / 2;
        imgSvg += `<svg x="${imgX}" y="${imgY}" width="${imgWidth}" height="${imgHeight}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`;
        imgSvg += this.options.image.svg + EOL;
        imgSvg += "</svg>";
      }
      var svg = "";
      switch (opt.container) {
        case "svg":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "svg-viewbox":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + " " + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "g":
          svg += '<g width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</g>";
          break;
        default:
          svg += (defs + bgrect + modrect + imgSvg).replace(/^\s+/, "");
          break;
      }
      return svg;
    };
    module.exports = QRCode;
  }
});

// node_modules/walletlink/dist/components/QRCode.js
var require_QRCode = __commonJS({
  "node_modules/walletlink/dist/components/QRCode.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QRCode = void 0;
    var preact_1 = (init_preact_module(), preact_module_exports);
    var hooks_1 = (init_hooks_module(), hooks_module_exports);
    var qrcode_svg_1 = __importDefault(require_qrcode_svg());
    var QRCode = (props) => {
      const [svg, setSvg] = (0, hooks_1.useState)("");
      (0, hooks_1.useEffect)(() => {
        var _a, _b;
        const qrcode = new qrcode_svg_1.default({
          content: props.content,
          background: props.bgColor || "#ffffff",
          color: props.fgColor || "#000000",
          container: "svg",
          ecl: "M",
          width: (_a = props.width) !== null && _a !== void 0 ? _a : 256,
          height: (_b = props.height) !== null && _b !== void 0 ? _b : 256,
          padding: 0,
          image: props.image
        });
        const base64 = Buffer.from(qrcode.svg(), "utf8").toString("base64");
        setSvg(`data:image/svg+xml;base64,${base64}`);
      });
      return svg ? (0, preact_1.h)("img", { src: svg, alt: "QR Code" }) : null;
    };
    exports.QRCode = QRCode;
  }
});

// node_modules/walletlink/dist/components/Spinner-css.js
var require_Spinner_css = __commonJS({
  "node_modules/walletlink/dist/components/Spinner-css.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-walletlink-css-reset .-walletlink-spinner{display:inline-block}.-walletlink-css-reset .-walletlink-spinner svg{display:inline-block;animation:2s linear infinite -walletlink-spinner-svg}.-walletlink-css-reset .-walletlink-spinner svg circle{animation:1.9s ease-in-out infinite both -walletlink-spinner-circle;display:block;fill:transparent;stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -walletlink-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -walletlink-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}`;
  }
});

// node_modules/walletlink/dist/components/Spinner.js
var require_Spinner = __commonJS({
  "node_modules/walletlink/dist/components/Spinner.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Spinner = void 0;
    var preact_1 = (init_preact_module(), preact_module_exports);
    var Spinner_css_1 = __importDefault(require_Spinner_css());
    var Spinner = (props) => {
      var _a;
      const size = (_a = props.size) !== null && _a !== void 0 ? _a : 64;
      const color = props.color || "#000";
      return (0, preact_1.h)("div", { class: "-walletlink-spinner" }, (0, preact_1.h)("style", null, Spinner_css_1.default), (0, preact_1.h)("svg", { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: size, height: size } }, (0, preact_1.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: color } })));
    };
    exports.Spinner = Spinner;
  }
});

// node_modules/walletlink/dist/version.js
var require_version = __commonJS({
  "node_modules/walletlink/dist/version.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LIB_VERSION = void 0;
    exports.LIB_VERSION = "2.5.0";
  }
});

// node_modules/walletlink/dist/components/LinkDialog.js
var require_LinkDialog = __commonJS({
  "node_modules/walletlink/dist/components/LinkDialog.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkDialog = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), clsx_m_exports));
    var preact_1 = (init_preact_module(), preact_module_exports);
    var hooks_1 = (init_hooks_module(), hooks_module_exports);
    var LinkDialog_css_1 = __importDefault(require_LinkDialog_css());
    var QRCode_1 = require_QRCode();
    var Spinner_1 = require_Spinner();
    var version_1 = require_version();
    var LinkDialog = (props) => {
      const [isContainerHidden, setContainerHidden] = (0, hooks_1.useState)(!props.isOpen);
      const [isDialogHidden, setDialogHidden] = (0, hooks_1.useState)(!props.isOpen);
      (0, hooks_1.useEffect)(() => {
        const { isOpen } = props;
        const timers = [
          window.setTimeout(() => {
            setDialogHidden(!isOpen);
          }, 10)
        ];
        if (isOpen) {
          setContainerHidden(false);
        } else {
          timers.push(window.setTimeout(() => {
            setContainerHidden(true);
          }, 360));
        }
        return () => {
          timers.forEach(window.clearTimeout);
        };
      }, [props.isOpen]);
      return (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-link-dialog-container", props.darkMode && "-walletlink-link-dialog-container-dark", isContainerHidden && "-walletlink-link-dialog-container-hidden") }, (0, preact_1.h)("style", null, LinkDialog_css_1.default), (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-link-dialog-backdrop", isDialogHidden && "-walletlink-link-dialog-backdrop-hidden") }), (0, preact_1.h)("div", { class: "-walletlink-link-dialog" }, (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-link-dialog-box", isDialogHidden && "-walletlink-link-dialog-box-hidden") }, (0, preact_1.h)(ScanQRCode, { darkMode: props.darkMode, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, walletLinkUrl: props.walletLinkUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection }), props.onCancel && (0, preact_1.h)(CancelButton, { onClick: props.onCancel }))));
    };
    exports.LinkDialog = LinkDialog;
    var ScanQRCode = (props) => {
      const serverUrl = window.encodeURIComponent(props.walletLinkUrl);
      const sessionIdKey = props.isParentConnection ? "parent-id" : "id";
      const qrUrl = `${props.walletLinkUrl}/#/link?${sessionIdKey}=${props.sessionId}&secret=${props.sessionSecret}&server=${serverUrl}&v=1`;
      return (0, preact_1.h)("div", { class: "-walletlink-link-dialog-box-content" }, (0, preact_1.h)("h3", null, "Scan to", (0, preact_1.h)("br", null), " Connect"), (0, preact_1.h)("div", { class: "-walletlink-link-dialog-box-content-qrcode" }, (0, preact_1.h)("div", { class: "-walletlink-link-dialog-box-content-qrcode-wrapper" }, (0, preact_1.h)(QRCode_1.QRCode, { content: qrUrl, width: 224, height: 224, fgColor: "#000", bgColor: "transparent" })), (0, preact_1.h)("input", { type: "hidden", name: "walletlink-version", value: version_1.LIB_VERSION }), (0, preact_1.h)("input", { type: "hidden", value: qrUrl }), !props.isConnected && (0, preact_1.h)("div", { class: "-walletlink-link-dialog-box-content-qrcode-connecting" }, (0, preact_1.h)(Spinner_1.Spinner, { size: 128, color: props.darkMode ? "#fff" : "#000" }), (0, preact_1.h)("p", null, "Connecting...")), (0, preact_1.h)("p", { title: `WalletLink v${props.version}` }, "Powered by WalletLink")), (0, preact_1.h)("a", { href: `${props.walletLinkUrl}/#/wallets`, target: "_blank", rel: "noopener" }, "Don\u2019t have a wallet app?"));
    };
    var CancelButton = (props) => (0, preact_1.h)("button", { class: "-walletlink-link-dialog-box-cancel", onClick: props.onClick }, (0, preact_1.h)("div", { class: "-walletlink-link-dialog-box-cancel-x" }));
  }
});

// node_modules/walletlink/dist/components/icons/globe-icon-svg.js
var require_globe_icon_svg = __commonJS({
  "node_modules/walletlink/dist/components/icons/globe-icon-svg.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTggMEMzLjU4IDAgMCAzLjU4IDAgOHMzLjU4IDggOCA4IDgtMy41OCA4LTgtMy41OC04LTgtOFptNS45MSA3aC0xLjk0Yy0uMS0xLjU3LS40Mi0zLS45MS00LjE1IDEuNDguODggMi41NSAyLjM4IDIuODUgNC4xNVpNOCAxNGMtLjQ1IDAtMS43Mi0xLjc3LTEuOTUtNWgzLjljLS4yMyAzLjIzLTEuNSA1LTEuOTUgNVpNNi4wNSA3QzYuMjggMy43NyA3LjU1IDIgOCAyYy40NSAwIDEuNzIgMS43NyAxLjk1IDVoLTMuOVpNNC45NCAyLjg1QzQuNDYgNCA0LjEzIDUuNDMgNC4wMyA3SDIuMDljLjMtMS43NyAxLjM3LTMuMjcgMi44NS00LjE1Wk0yLjA5IDloMS45NGMuMSAxLjU3LjQyIDMgLjkxIDQuMTVBNS45OTggNS45OTggMCAwIDEgMi4wOSA5Wm04Ljk3IDQuMTVjLjQ4LTEuMTUuODEtMi41OC45MS00LjE1aDEuOTRhNS45OTggNS45OTggMCAwIDEtMi44NSA0LjE1WiIgZmlsbD0iIzE2NTJGMCIvPjwvc3ZnPg==`;
  }
});

// node_modules/walletlink/dist/components/icons/link-icon-svg.js
var require_link_icon_svg = __commonJS({
  "node_modules/walletlink/dist/components/icons/link-icon-svg.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE1LjYzNSAyLjExN2EzLjg4OSAzLjg4OSAwIDAgMC01LjUyMSAwTDYuODkgNS4zMzVBMy44OTQgMy44OTQgMCAwIDAgNS44IDguNzM5Yy4wODMuNTA2LjI2OCAxLjAxMS41NTMgMS40NjYuMTUxLjI1My4zMzYuNDcyLjUzNy42OTFsLjYyMS42MjQgMS4xNDEtMS4xNDYtLjYyLS42MjRhMi4xMDUgMi4xMDUgMCAwIDEtLjQ4Ny0uNzQxIDIuMzQgMi4zNCAwIDAgMSAuNTAzLTIuNTFsMy4yMDYtMy4yMmEyLjI5MyAyLjI5MyAwIDAgMSAzLjIzOSAwYy44OS44OTQuODkgMi4zNDMgMCAzLjI1M2wtMS41MjcgMS41MzNjLjIzNC42NC4zMzUgMS4zMzEuMzAyIDIuMDA1bDIuMzgzLTIuMzkyYzEuNTEtMS41MzQgMS40OTMtNC4wMjgtLjAxNy01LjU2MVoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBkPSJNMTEuMjcxIDcuNzQ1YTMuMTMgMy4xMyAwIDAgMC0uNTU0LS42OWwtLjYyLS42MjQtMS4xNDIgMS4xNDYuNjIxLjYyM2MuMjE4LjIyLjM4Ni40ODkuNDg3Ljc1OC4zMzUuODI2LjE2NyAxLjgyLS41MDQgMi40OTRsLTMuMjA1IDMuMjE5YTIuMjkzIDIuMjkzIDAgMCAxLTMuMjQgMCAyLjMxNiAyLjMxNiAwIDAgMSAwLTMuMjUybDEuNTI4LTEuNTM0YTQuODE1IDQuODE1IDAgMCAxLS4yODUtMi4wMDVsLTIuMzgzIDIuMzkzYTMuOTI3IDMuOTI3IDAgMCAwIDAgNS41NDQgMy45MDkgMy45MDkgMCAwIDAgNS41MzggMGwzLjIwNS0zLjIxOWEzLjk1OCAzLjk1OCAwIDAgMCAxLjA5MS0zLjQwNCA0LjIxMSA0LjIxMSAwIDAgMC0uNTM3LTEuNDQ5WiIgZmlsbD0iIzE2NTJGMCIvPjwvc3ZnPg==`;
  }
});

// node_modules/walletlink/dist/components/icons/lock-icon-svg.js
var require_lock_icon_svg = __commonJS({
  "node_modules/walletlink/dist/components/icons/lock-icon-svg.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEgN3Y5aDE0VjdIMVptNy41IDQuMzlWMTRoLTF2LTIuNjFjLS40NC0uMTktLjc1LS42My0uNzUtMS4xNGExLjI1IDEuMjUgMCAwIDEgMi41IDBjMCAuNTEtLjMxLjk1LS43NSAxLjE0Wk01LjY3IDZWNC4zM0M1LjY3IDMuMDUgNi43MSAyIDggMnMyLjMzIDEuMDUgMi4zMyAyLjMzVjZoMlY0LjMzQzEyLjMzIDEuOTQgMTAuMzkgMCA4IDBTMy42NyAxLjk0IDMuNjcgNC4zM1Y2aDJaIiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
  }
});

// node_modules/walletlink/dist/components/icons/QRLogo.js
var require_QRLogo = __commonJS({
  "node_modules/walletlink/dist/components/icons/QRLogo.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `<svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="50" cy="50" r="50" fill="white"/>
<circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
<circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
</svg>

`;
  }
});

// node_modules/walletlink/dist/components/TryExtensionLinkDialog-css.js
var require_TryExtensionLinkDialog_css = __commonJS({
  "node_modules/walletlink/dist/components/TryExtensionLinkDialog-css.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-walletlink-css-reset .-walletlink-extension-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-walletlink-css-reset .-walletlink-extension-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);transition:opacity .25s}.-walletlink-css-reset .-walletlink-extension-dialog-backdrop-hidden{opacity:0}.-walletlink-css-reset .-walletlink-extension-dialog-box{display:flex;position:relative;max-width:500px;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-walletlink-css-reset .-walletlink-extension-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-walletlink-css-reset .-walletlink-extension-dialog-box-top{display:flex;flex-direction:row;background-color:#fff;border-radius:8px;overflow:hidden;min-height:300px}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-install-region{display:flex;flex-basis:50%;flex-direction:column;justify-content:center;padding:32px}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-install-region button{display:block;border-radius:8px;background-color:#1652f0;color:#fff;width:90%;min-width:fit-content;height:44px;margin-top:16px;font-size:16px;padding-left:16px;padding-right:16px;cursor:pointer;font-weight:500;text-align:center}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-info-region{display:flex;flex-basis:50%;flex-direction:column;justify-content:center;background-color:#fafbfc}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description{display:flex;flex-direction:row;align-items:center;padding-top:14px;padding-bottom:14px;padding-left:24px;padding-right:32px}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description-icon-wrapper{display:block;position:relative;width:40px;height:40px;flex-shrink:0;flex-grow:0;border-radius:20px;background-color:#fff;box-shadow:0px 0px 8px rgba(0,0,0,.04),0px 16px 24px rgba(0,0,0,.06)}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description-icon-wrapper img{position:absolute;top:0;bottom:0;left:0;right:0;margin:auto}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description-text{margin-left:16px;flex-grow:1;font-size:13px;line-height:19px;color:#000;align-self:center}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom{display:flex;flex-direction:row;overflow:hidden;border-radius:8px;background-color:#fff;margin-top:8px}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-description-region{display:flex;flex-direction:column;justify-content:center;padding:32px;flex-grow:1}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-description{font-size:13px;line-height:19px;margin-top:12px;color:#aaa}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-description a{font-size:inherit;line-height:inherit;color:#1652f0;cursor:pointer}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-region{position:relative;flex-shrink:0;display:flex;flex-direction:column;justify-content:center;padding-left:24px;padding-right:24px;padding-top:16px;padding-bottom:16px}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-wrapper{position:relative;display:block;padding:8px;border-radius:8px;box-shadow:0px 4px 12px rgba(0,0,0,.1)}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-wrapper img{display:block}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background-color:rgba(255,255,255,.95)}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-connecting>p{font-size:12px;font-weight:bold;color:#000;margin-top:16px}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel{position:absolute;-webkit-appearance:none;display:flex;align-items:center;justify-content:center;top:16px;right:16px;width:24px;height:24px;border-radius:12px;background-color:#fafbfc;cursor:pointer}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x{position:relative;display:block;cursor:pointer}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::after{content:"";position:absolute;display:block;top:-1px;left:-7px;width:14px;height:1px;background-color:#000;transition:background-color .2s}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::before{transform:rotate(45deg)}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::after{transform:rotate(135deg)}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-a,.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-b{background-color:#000}.-walletlink-css-reset .-walletlink-extension-dialog-container{display:block}.-walletlink-css-reset .-walletlink-extension-dialog-container-hidden{display:none}.-walletlink-css-reset .-walletlink-extension-dialog h2{display:block;text-align:left;font-size:22px;font-weight:600;line-height:28px;color:#000}`;
  }
});

// node_modules/walletlink/dist/components/TryExtensionLinkDialog.js
var require_TryExtensionLinkDialog = __commonJS({
  "node_modules/walletlink/dist/components/TryExtensionLinkDialog.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TryExtensionLinkDialog = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), clsx_m_exports));
    var preact_1 = (init_preact_module(), preact_module_exports);
    var hooks_1 = (init_hooks_module(), hooks_module_exports);
    var globe_icon_svg_1 = __importDefault(require_globe_icon_svg());
    var link_icon_svg_1 = __importDefault(require_link_icon_svg());
    var lock_icon_svg_1 = __importDefault(require_lock_icon_svg());
    var QRLogo_1 = __importDefault(require_QRLogo());
    var QRCode_1 = require_QRCode();
    var Spinner_1 = require_Spinner();
    var TryExtensionLinkDialog_css_1 = __importDefault(require_TryExtensionLinkDialog_css());
    var version_1 = require_version();
    var TryExtensionLinkDialog = (props) => {
      const [isContainerHidden, setContainerHidden] = (0, hooks_1.useState)(!props.isOpen);
      const [isDialogHidden, setDialogHidden] = (0, hooks_1.useState)(!props.isOpen);
      (0, hooks_1.useEffect)(() => {
        const { isOpen } = props;
        const timers = [
          window.setTimeout(() => {
            setDialogHidden(!isOpen);
          }, 10)
        ];
        if (isOpen) {
          setContainerHidden(false);
        } else {
          timers.push(window.setTimeout(() => {
            setContainerHidden(true);
          }, 360));
        }
        return () => {
          timers.forEach(window.clearTimeout);
        };
      }, [props.isOpen]);
      return (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-extension-dialog-container", isContainerHidden && "-walletlink-extension-dialog-container-hidden") }, (0, preact_1.h)("style", null, TryExtensionLinkDialog_css_1.default), (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-extension-dialog-backdrop", isDialogHidden && "-walletlink-extension-dialog-backdrop-hidden") }), (0, preact_1.h)("div", { class: "-walletlink-extension-dialog" }, (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-extension-dialog-box", isDialogHidden && "-walletlink-extension-dialog-box-hidden") }, (0, preact_1.h)(TryExtensionBox, { onInstallClick: () => {
        window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
      } }), !props.connectDisabled ? (0, preact_1.h)(ScanQRBox, { darkMode: props.darkMode, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, walletLinkUrl: props.walletLinkUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection }) : null, props.onCancel && (0, preact_1.h)(CancelButton, { onClick: props.onCancel }))));
    };
    exports.TryExtensionLinkDialog = TryExtensionLinkDialog;
    var TryExtensionBox = (props) => {
      return (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-top" }, (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-top-install-region" }, (0, preact_1.h)("h2", null, "Try the Coinbase Wallet extension"), (0, preact_1.h)("button", { onClick: props.onInstallClick }, "Install")), (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-top-info-region" }, (0, preact_1.h)(DescriptionItem, { icon: link_icon_svg_1.default, text: "Connect to crypto apps with one click" }), (0, preact_1.h)(DescriptionItem, { icon: lock_icon_svg_1.default, text: "Your private key is stored securely" }), (0, preact_1.h)(DescriptionItem, { icon: globe_icon_svg_1.default, text: "Works with Ethereum, Polygon, and more" })));
    };
    var ScanQRBox = (props) => {
      const serverUrl = window.encodeURIComponent(props.walletLinkUrl);
      const sessionIdKey = props.isParentConnection ? "parent-id" : "id";
      const qrUrl = `${props.walletLinkUrl}/#/link?${sessionIdKey}=${props.sessionId}&secret=${props.sessionSecret}&server=${serverUrl}&v=1`;
      return (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-bottom" }, (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-bottom-description-region" }, (0, preact_1.h)("h2", null, "Or scan to connect"), (0, preact_1.h)("body", { class: "-walletlink-extension-dialog-box-bottom-description" }, "Open ", (0, preact_1.h)("a", { href: "https://wallet.coinbase.com/" }, "Coinbase Wallet"), " on your mobile phone and scan")), (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-bottom-qr-region" }, (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-bottom-qr-wrapper" }, (0, preact_1.h)(QRCode_1.QRCode, { content: qrUrl, width: 150, height: 150, fgColor: "#000", bgColor: "transparent", image: {
        svg: QRLogo_1.default,
        width: 34,
        height: 34
      } })), (0, preact_1.h)("input", { type: "hidden", name: "walletlink-version", value: version_1.LIB_VERSION }), (0, preact_1.h)("input", { type: "hidden", value: qrUrl }), !props.isConnected && (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-bottom-qr-connecting" }, (0, preact_1.h)(Spinner_1.Spinner, { size: 36, color: "#000" }), (0, preact_1.h)("p", null, "Connecting..."))));
    };
    var DescriptionItem = (props) => {
      return (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-top-description" }, (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-top-description-icon-wrapper" }, (0, preact_1.h)("img", { src: props.icon })), (0, preact_1.h)("body", { class: "-walletlink-extension-dialog-box-top-description-text" }, props.text));
    };
    var CancelButton = (props) => (0, preact_1.h)("button", { class: "-walletlink-extension-dialog-box-cancel", onClick: props.onClick }, (0, preact_1.h)("div", { class: "-walletlink-extension-dialog-box-cancel-x" }));
  }
});

// node_modules/walletlink/dist/components/LinkFlow.js
var require_LinkFlow = __commonJS({
  "node_modules/walletlink/dist/components/LinkFlow.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkFlow = void 0;
    var preact_1 = (init_preact_module(), preact_module_exports);
    var rxjs_1 = (init_esm5(), esm5_exports);
    var operators_1 = (init_operators(), operators_exports);
    var LinkDialog_1 = require_LinkDialog();
    var TryExtensionLinkDialog_1 = require_TryExtensionLinkDialog();
    var LinkFlow = class {
      constructor(options) {
        this.extensionUI$ = new rxjs_1.BehaviorSubject({});
        this.subscriptions = new rxjs_1.Subscription();
        this.isConnected = false;
        this.isOpen = false;
        this.onCancel = null;
        this.root = null;
        this.connectDisabled = false;
        this.darkMode = options.darkMode;
        this.version = options.version;
        this.sessionId = options.sessionId;
        this.sessionSecret = options.sessionSecret;
        this.walletLinkUrl = options.walletLinkUrl;
        this.isParentConnection = options.isParentConnection;
        this.connected$ = options.connected$;
        fetch("https://api.wallet.coinbase.com/rpc/v2/getFeatureFlags").then((res) => res.json()).then((json) => {
          const enabled = json.result.desktop.extension_ui;
          if (typeof enabled === "undefined") {
            this.extensionUI$.next({ value: false });
          } else {
            this.extensionUI$.next({ value: enabled });
          }
        }).catch((err) => {
          console.error("Couldn't fetch feature flags - ", err);
          this.extensionUI$.next({ value: false });
        });
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-walletlink-link-flow-root";
        el.appendChild(this.root);
        this.render();
        this.subscriptions.add(this.connected$.subscribe((v3) => {
          if (this.isConnected !== v3) {
            this.isConnected = v3;
            this.render();
          }
        }));
      }
      detach() {
        var _a;
        if (!this.root) {
          return;
        }
        this.subscriptions.unsubscribe();
        (0, preact_1.render)(null, this.root);
        (_a = this.root.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this.root);
      }
      setConnectDisabled(connectDisabled) {
        this.connectDisabled = connectDisabled;
      }
      open(options) {
        this.isOpen = true;
        this.onCancel = options.onCancel;
        this.render();
      }
      close() {
        this.isOpen = false;
        this.onCancel = null;
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        const subscription = this.extensionUI$.pipe((0, operators_1.first)((enabled) => enabled.value !== void 0)).subscribe((enabled) => {
          if (!this.root) {
            return;
          }
          (0, preact_1.render)(enabled.value ? (0, preact_1.h)(TryExtensionLinkDialog_1.TryExtensionLinkDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, walletLinkUrl: this.walletLinkUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, onCancel: this.onCancel, connectDisabled: this.connectDisabled }) : (0, preact_1.h)(LinkDialog_1.LinkDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, walletLinkUrl: this.walletLinkUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, onCancel: this.onCancel }), this.root);
        });
        this.subscriptions.add(subscription);
      }
    };
    exports.LinkFlow = LinkFlow;
  }
});

// node_modules/walletlink/dist/components/Snackbar-css.js
var require_Snackbar_css = __commonJS({
  "node_modules/walletlink/dist/components/Snackbar-css.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-walletlink-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-walletlink-css-reset .-gear-container *{user-select:none}.-walletlink-css-reset .-gear-container svg{opacity:0;position:absolute}.-walletlink-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-walletlink-css-reset .-walletlink-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-walletlink-css-reset .-walletlink-snackbar *{user-select:none}.-walletlink-css-reset .-walletlink-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-walletlink-css-reset .-walletlink-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-walletlink-css-reset .-walletlink-snackbar-instance-header *{cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-walletlink-css-reset .-walletlink-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-walletlink-css-reset .-walletlink-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-walletlink-css-reset .-walletlink-snackbar-instance-expanded .-walletlink-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`;
  }
});

// node_modules/walletlink/dist/components/Snackbar.js
var require_Snackbar = __commonJS({
  "node_modules/walletlink/dist/components/Snackbar.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Snackbar = void 0;
    var clsx_1 = __importDefault((init_clsx_m(), clsx_m_exports));
    var preact_1 = (init_preact_module(), preact_module_exports);
    var hooks_1 = (init_hooks_module(), hooks_module_exports);
    var Snackbar_css_1 = __importDefault(require_Snackbar_css());
    var cblogo = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
    var gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
    var Snackbar = class {
      constructor(options) {
        this.items = new Map();
        this.nextItemKey = 0;
        this.root = null;
        this.darkMode = options.darkMode;
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-walletlink-snackbar-root";
        el.appendChild(this.root);
        this.render();
      }
      presentItem(itemProps) {
        const key = this.nextItemKey++;
        this.items.set(key, itemProps);
        this.render();
        return () => {
          this.items.delete(key);
          this.render();
        };
      }
      clear() {
        this.items.clear();
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        (0, preact_1.render)((0, preact_1.h)("div", null, (0, preact_1.h)(SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key, itemProps]) => (0, preact_1.h)(SnackbarInstance, Object.assign({}, itemProps, { key }))))), this.root);
      }
    };
    exports.Snackbar = Snackbar;
    var SnackbarContainer = (props) => (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-snackbar-container") }, (0, preact_1.h)("style", null, Snackbar_css_1.default), (0, preact_1.h)("div", { class: "-walletlink-snackbar" }, props.children));
    var SnackbarInstance = ({ autoExpand, message, menuItems }) => {
      const [hidden, setHidden] = (0, hooks_1.useState)(true);
      const [expanded, setExpanded] = (0, hooks_1.useState)(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
      (0, hooks_1.useEffect)(() => {
        const timers = [
          window.setTimeout(() => {
            setHidden(false);
          }, 1),
          window.setTimeout(() => {
            setExpanded(true);
          }, 1e4)
        ];
        return () => {
          timers.forEach(window.clearTimeout);
        };
      });
      const toggleExpanded = () => {
        setExpanded(!expanded);
      };
      return (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-snackbar-instance", hidden && "-walletlink-snackbar-instance-hidden", expanded && "-walletlink-snackbar-instance-expanded") }, (0, preact_1.h)("div", { class: "-walletlink-snackbar-instance-header", onClick: toggleExpanded }, (0, preact_1.h)("img", { src: cblogo, class: "-walletlink-snackbar-instance-header-cblogo" }), (0, preact_1.h)("div", { class: "-walletlink-snackbar-instance-header-message" }, message), (0, preact_1.h)("div", { class: "-gear-container" }, !expanded && (0, preact_1.h)("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, (0, preact_1.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })), (0, preact_1.h)("img", { src: gearIcon, class: "-gear-icon", title: "Expand" }))), menuItems && menuItems.length > 0 && (0, preact_1.h)("div", { class: "-walletlink-snackbar-instance-menu" }, menuItems.map((action, i3) => (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-snackbar-instance-menu-item", action.isRed && "-walletlink-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i3 }, (0, preact_1.h)("svg", { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, (0, preact_1.h)("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })), (0, preact_1.h)("span", { class: (0, clsx_1.default)("-walletlink-snackbar-instance-menu-item-info", action.isRed && "-walletlink-snackbar-instance-menu-item-info-is-red") }, action.info)))));
    };
  }
});

// node_modules/walletlink/dist/lib/cssReset-css.js
var require_cssReset_css = __commonJS({
  "node_modules/walletlink/dist/lib/cssReset-css.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `@namespace svg "http://www.w3.org/2000/svg";.-walletlink-css-reset,.-walletlink-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;bottom:auto;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;content:normal;counter-increment:none;counter-reset:none;cursor:auto;direction:ltr;display:block;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;left:auto;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;max-height:none;max-width:none;min-height:0;min-width:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";right:auto;tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;top:auto;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;width:auto;word-spacing:normal;z-index:auto}.-walletlink-css-reset *{box-sizing:border-box;display:initial;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-walletlink-css-reset [class*=container]{margin:0;padding:0}.-walletlink-css-reset style{display:none}`;
  }
});

// node_modules/walletlink/dist/lib/cssReset.js
var require_cssReset = __commonJS({
  "node_modules/walletlink/dist/lib/cssReset.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.injectCssReset = void 0;
    var cssReset_css_1 = __importDefault(require_cssReset_css());
    function injectCssReset() {
      const styleEl = document.createElement("style");
      styleEl.type = "text/css";
      styleEl.appendChild(document.createTextNode(cssReset_css_1.default));
      document.documentElement.appendChild(styleEl);
    }
    exports.injectCssReset = injectCssReset;
  }
});

// node_modules/walletlink/dist/provider/WalletLinkUI.js
var require_WalletLinkUI = __commonJS({
  "node_modules/walletlink/dist/provider/WalletLinkUI.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkUI = void 0;
    var WalletLinkUI = class {
      constructor(_3) {
      }
      setConnectDisabled(_3) {
      }
    };
    exports.WalletLinkUI = WalletLinkUI;
  }
});

// node_modules/walletlink/dist/provider/WalletLinkSdkUI.js
var require_WalletLinkSdkUI = __commonJS({
  "node_modules/walletlink/dist/provider/WalletLinkSdkUI.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkSdkUI = void 0;
    var LinkFlow_1 = require_LinkFlow();
    var Snackbar_1 = require_Snackbar();
    var cssReset_1 = require_cssReset();
    var WalletLinkUI_1 = require_WalletLinkUI();
    var WalletLinkSdkUI = class extends WalletLinkUI_1.WalletLinkUI {
      constructor(options) {
        super(options);
        this.attached = false;
        this.snackbar = new Snackbar_1.Snackbar({
          darkMode: options.darkMode
        });
        this.linkFlow = new LinkFlow_1.LinkFlow({
          darkMode: options.darkMode,
          version: options.version,
          sessionId: options.session.id,
          sessionSecret: options.session.secret,
          walletLinkUrl: options.walletLinkUrl,
          connected$: options.connected$,
          isParentConnection: false
        });
      }
      attach() {
        if (this.attached) {
          throw new Error("WalletLinkUI is already attached");
        }
        const el = document.documentElement;
        const container = document.createElement("div");
        container.className = "-walletlink-css-reset";
        el.appendChild(container);
        this.linkFlow.attach(container);
        this.snackbar.attach(container);
        this.attached = true;
        (0, cssReset_1.injectCssReset)();
      }
      setConnectDisabled(connectDisabled) {
        this.linkFlow.setConnectDisabled(connectDisabled);
      }
      addEthereumChain(options) {
      }
      watchAsset(options) {
      }
      switchEthereumChain(options) {
      }
      requestEthereumAccounts(options) {
        this.linkFlow.open({ onCancel: options.onCancel });
      }
      hideRequestEthereumAccounts() {
        this.linkFlow.close();
      }
      signEthereumMessage(_3) {
      }
      signEthereumTransaction(_3) {
      }
      submitEthereumTransaction(_3) {
      }
      ethereumAddressFromSignedMessage(_3) {
      }
      showConnecting(options) {
        let snackbarProps;
        if (options.isUnlinkedErrorState) {
          snackbarProps = {
            autoExpand: true,
            message: "Connection lost",
            menuItems: [
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        } else {
          snackbarProps = {
            message: "Confirm on phone",
            menuItems: [
              {
                isRed: true,
                info: "Cancel transaction",
                svgWidth: "11",
                svgHeight: "11",
                path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
                defaultFillRule: "inherit",
                defaultClipRule: "inherit",
                onClick: options.onCancel
              },
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        }
        return this.snackbar.presentItem(snackbarProps);
      }
      reloadUI() {
        document.location.reload();
      }
      inlineAccountsResponse() {
        return false;
      }
      inlineAddEthereumChain(chainId) {
        return false;
      }
      inlineWatchAsset() {
        return false;
      }
      inlineSwitchEthereumChain() {
        return false;
      }
      isStandalone() {
        return false;
      }
    };
    exports.WalletLinkSdkUI = WalletLinkSdkUI;
  }
});

// node_modules/walletlink/dist/connection/ClientMessage.js
var require_ClientMessage = __commonJS({
  "node_modules/walletlink/dist/connection/ClientMessage.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientMessagePublishEvent = exports.ClientMessageSetSessionConfig = exports.ClientMessageGetSessionConfig = exports.ClientMessageIsLinked = exports.ClientMessageHostSession = void 0;
    function ClientMessageHostSession(params) {
      return Object.assign({ type: "HostSession" }, params);
    }
    exports.ClientMessageHostSession = ClientMessageHostSession;
    function ClientMessageIsLinked(params) {
      return Object.assign({ type: "IsLinked" }, params);
    }
    exports.ClientMessageIsLinked = ClientMessageIsLinked;
    function ClientMessageGetSessionConfig(params) {
      return Object.assign({ type: "GetSessionConfig" }, params);
    }
    exports.ClientMessageGetSessionConfig = ClientMessageGetSessionConfig;
    function ClientMessageSetSessionConfig(params) {
      return Object.assign({ type: "SetSessionConfig" }, params);
    }
    exports.ClientMessageSetSessionConfig = ClientMessageSetSessionConfig;
    function ClientMessagePublishEvent(params) {
      return Object.assign({ type: "PublishEvent" }, params);
    }
    exports.ClientMessagePublishEvent = ClientMessagePublishEvent;
  }
});

// node_modules/walletlink/dist/connection/RxWebSocket.js
var require_RxWebSocket = __commonJS({
  "node_modules/walletlink/dist/connection/RxWebSocket.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RxWebSocket = exports.ConnectionState = void 0;
    var rxjs_1 = (init_esm5(), esm5_exports);
    var operators_1 = (init_operators(), operators_exports);
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
      ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
    })(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
    var RxWebSocket = class {
      constructor(url, WebSocketClass = WebSocket) {
        this.WebSocketClass = WebSocketClass;
        this.webSocket = null;
        this.connectionStateSubject = new rxjs_1.BehaviorSubject(ConnectionState.DISCONNECTED);
        this.incomingDataSubject = new rxjs_1.Subject();
        this.url = url.replace(/^http/, "ws");
      }
      connect() {
        if (this.webSocket) {
          return (0, rxjs_1.throwError)(new Error("webSocket object is not null"));
        }
        return new rxjs_1.Observable((obs) => {
          let webSocket;
          try {
            this.webSocket = webSocket = new this.WebSocketClass(this.url);
          } catch (err) {
            obs.error(err);
            return;
          }
          this.connectionStateSubject.next(ConnectionState.CONNECTING);
          webSocket.onclose = (evt) => {
            this.clearWebSocket();
            obs.error(new Error(`websocket error ${evt.code}: ${evt.reason}`));
            this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
          };
          webSocket.onopen = (_3) => {
            obs.next();
            obs.complete();
            this.connectionStateSubject.next(ConnectionState.CONNECTED);
          };
          webSocket.onmessage = (evt) => {
            this.incomingDataSubject.next(evt.data);
          };
        }).pipe((0, operators_1.take)(1));
      }
      disconnect() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.clearWebSocket();
        this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
        try {
          webSocket.close();
        } catch (_a) {
        }
      }
      get connectionState$() {
        return this.connectionStateSubject.asObservable();
      }
      get incomingData$() {
        return this.incomingDataSubject.asObservable();
      }
      get incomingJSONData$() {
        return this.incomingData$.pipe((0, operators_1.flatMap)((m3) => {
          let j3;
          try {
            j3 = JSON.parse(m3);
          } catch (err) {
            return (0, rxjs_1.empty)();
          }
          return (0, rxjs_1.of)(j3);
        }));
      }
      sendData(data) {
        const { webSocket } = this;
        if (!webSocket) {
          throw new Error("websocket is not connected");
        }
        webSocket.send(data);
      }
      clearWebSocket() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.webSocket = null;
        webSocket.onclose = null;
        webSocket.onerror = null;
        webSocket.onmessage = null;
        webSocket.onopen = null;
      }
    };
    exports.RxWebSocket = RxWebSocket;
  }
});

// node_modules/walletlink/dist/connection/ServerMessage.js
var require_ServerMessage = __commonJS({
  "node_modules/walletlink/dist/connection/ServerMessage.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isServerMessageFail = void 0;
    function isServerMessageFail(msg) {
      return msg && msg.type === "Fail" && typeof msg.id === "number" && typeof msg.sessionId === "string" && typeof msg.error === "string";
    }
    exports.isServerMessageFail = isServerMessageFail;
  }
});

// node_modules/walletlink/dist/connection/WalletLinkConnection.js
var require_WalletLinkConnection = __commonJS({
  "node_modules/walletlink/dist/connection/WalletLinkConnection.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkConnection = void 0;
    var rxjs_1 = (init_esm5(), esm5_exports);
    var operators_1 = (init_operators(), operators_exports);
    var init_1 = require_init();
    var Session_1 = require_Session();
    var types_1 = require_types();
    var ClientMessage_1 = require_ClientMessage();
    var RxWebSocket_1 = require_RxWebSocket();
    var ServerMessage_1 = require_ServerMessage();
    var HEARTBEAT_INTERVAL = 1e4;
    var REQUEST_TIMEOUT = 6e4;
    var WalletLinkConnection = class {
      constructor(sessionId, sessionKey, serverUrl, walletLinkAnalytics, WebSocketClass = WebSocket) {
        this.sessionId = sessionId;
        this.sessionKey = sessionKey;
        this.subscriptions = new rxjs_1.Subscription();
        this.destroyed = false;
        this.lastHeartbeatResponse = 0;
        this.nextReqId = (0, types_1.IntNumber)(1);
        this.connectedSubject = new rxjs_1.BehaviorSubject(false);
        this.linkedSubject = new rxjs_1.BehaviorSubject(false);
        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);
        const ws = new RxWebSocket_1.RxWebSocket(serverUrl + "/rpc", WebSocketClass);
        this.ws = ws;
        this.walletLinkAnalytics = walletLinkAnalytics;
        this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.tap)((state) => this.walletLinkAnalytics.sendEvent(init_1.EVENTS.CONNECTED_STATE_CHANGE, {
          state,
          sessionIdHash: Session_1.Session.hash(sessionId)
        })), (0, operators_1.skip)(1), (0, operators_1.filter)((cs) => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), (0, operators_1.delay)(5e3), (0, operators_1.filter)((_3) => !this.destroyed), (0, operators_1.flatMap)((_3) => ws.connect()), (0, operators_1.retry)()).subscribe());
        this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.skip)(2), (0, operators_1.switchMap)((cs) => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, this.authenticate().pipe((0, operators_1.tap)((_3) => this.sendIsLinked()), (0, operators_1.tap)((_3) => this.sendGetSessionConfig()), (0, operators_1.map)((_3) => true)), (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)((_3) => (0, rxjs_1.of)(false))).subscribe((connected) => this.connectedSubject.next(connected)));
        this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.skip)(1), (0, operators_1.switchMap)((cs) => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)))).subscribe((i3) => i3 === 0 ? this.updateLastHeartbeat() : this.heartbeat()));
        this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)((m3) => m3 === "h")).subscribe((_3) => this.updateLastHeartbeat()));
        this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)((m3) => ["IsLinkedOK", "Linked"].includes(m3.type))).subscribe((m3) => {
          const msg = m3;
          this.walletLinkAnalytics.sendEvent(init_1.EVENTS.LINKED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            linked: msg.linked,
            type: m3.type,
            onlineGuests: msg.onlineGuests
          });
          this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);
        }));
        this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)((m3) => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(m3.type))).subscribe((m3) => {
          const msg = m3;
          this.walletLinkAnalytics.sendEvent(init_1.EVENTS.SESSION_CONFIG_RECEIVED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : void 0
          });
          this.sessionConfigSubject.next({
            webhookId: msg.webhookId,
            webhookUrl: msg.webhookUrl,
            metadata: msg.metadata
          });
        }));
      }
      connect() {
        if (this.destroyed) {
          throw new Error("instance is destroyed");
        }
        this.walletLinkAnalytics.sendEvent(init_1.EVENTS.STARTED_CONNECTING, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.ws.connect().subscribe();
      }
      destroy() {
        this.subscriptions.unsubscribe();
        this.ws.disconnect();
        this.walletLinkAnalytics.sendEvent(init_1.EVENTS.DISCONNECTED, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.destroyed = true;
      }
      get isDestroyed() {
        return this.destroyed;
      }
      get connected$() {
        return this.connectedSubject.asObservable();
      }
      get onceConnected$() {
        return this.connected$.pipe((0, operators_1.filter)((v3) => v3), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      get linked$() {
        return this.linkedSubject.asObservable();
      }
      get onceLinked$() {
        return this.linked$.pipe((0, operators_1.filter)((v3) => v3), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      get sessionConfig$() {
        return this.sessionConfigSubject.asObservable();
      }
      get incomingEvent$() {
        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)((m3) => {
          if (m3.type !== "Event") {
            return false;
          }
          const sme = m3;
          return typeof sme.sessionId === "string" && typeof sme.eventId === "string" && typeof sme.event === "string" && typeof sme.data === "string";
        }), (0, operators_1.map)((m3) => m3));
      }
      setSessionMetadata(key, value) {
        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          metadata: { [key]: value }
        });
        return this.onceConnected$.pipe((0, operators_1.flatMap)((_3) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to set session metadata");
          }
        }));
      }
      publishEvent(event, data, callWebhook = false) {
        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          event,
          data,
          callWebhook
        });
        return this.onceLinked$.pipe((0, operators_1.flatMap)((_3) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to publish event");
          }
          return res.eventId;
        }));
      }
      sendData(message) {
        this.ws.sendData(JSON.stringify(message));
      }
      updateLastHeartbeat() {
        this.lastHeartbeatResponse = Date.now();
      }
      heartbeat() {
        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
          this.ws.disconnect();
          return;
        }
        try {
          this.ws.sendData("h");
        } catch (_a) {
        }
      }
      makeRequest(message, timeout = REQUEST_TIMEOUT) {
        const reqId = message.id;
        try {
          this.sendData(message);
        } catch (err) {
          return (0, rxjs_1.throwError)(err);
        }
        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)((m3) => m3.id === reqId), (0, operators_1.take)(1));
      }
      authenticate() {
        const msg = (0, ClientMessage_1.ClientMessageHostSession)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          sessionKey: this.sessionKey
        });
        return this.makeRequest(msg).pipe((0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to authentcate");
          }
        }));
      }
      sendIsLinked() {
        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
      sendGetSessionConfig() {
        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
    };
    exports.WalletLinkConnection = WalletLinkConnection;
  }
});

// node_modules/walletlink/dist/relay/aes256gcm.js
var require_aes256gcm = __commonJS({
  "node_modules/walletlink/dist/relay/aes256gcm.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = void 0;
    var rxjs_1 = (init_esm5(), esm5_exports);
    var util_1 = require_util();
    async function encrypt(plainText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      const ivBytes = crypto.getRandomValues(new Uint8Array(12));
      const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { "name": "aes-gcm" }, false, ["encrypt", "decrypt"]);
      const enc = new TextEncoder();
      const encryptedResult = await window.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: ivBytes
      }, secretKey, enc.encode(plainText));
      const tagLength = 16;
      const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
      const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
      const authTagBytes = new Uint8Array(authTag);
      const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
      const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);
      return (0, util_1.uint8ArrayToHex)(concatted);
    }
    exports.encrypt = encrypt;
    function decrypt(cipherText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      return new rxjs_1.Observable((subscriber) => {
        void async function() {
          const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { "name": "aes-gcm" }, false, ["encrypt", "decrypt"]);
          const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);
          const ivBytes = encrypted.slice(0, 12);
          const authTagBytes = encrypted.slice(12, 28);
          const encryptedPlaintextBytes = encrypted.slice(28);
          const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);
          const algo = {
            name: "AES-GCM",
            iv: new Uint8Array(ivBytes)
          };
          try {
            const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
            const decoder = new TextDecoder();
            subscriber.next(decoder.decode(decrypted));
            subscriber.complete();
          } catch (err) {
            subscriber.error(err);
          }
        }();
      });
    }
    exports.decrypt = decrypt;
  }
});

// node_modules/walletlink/dist/relay/Web3Method.js
var require_Web3Method = __commonJS({
  "node_modules/walletlink/dist/relay/Web3Method.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3Method = void 0;
    var Web3Method;
    (function(Web3Method2) {
      Web3Method2["requestEthereumAccounts"] = "requestEthereumAccounts";
      Web3Method2["signEthereumMessage"] = "signEthereumMessage";
      Web3Method2["signEthereumTransaction"] = "signEthereumTransaction";
      Web3Method2["submitEthereumTransaction"] = "submitEthereumTransaction";
      Web3Method2["ethereumAddressFromSignedMessage"] = "ethereumAddressFromSignedMessage";
      Web3Method2["scanQRCode"] = "scanQRCode";
      Web3Method2["generic"] = "generic";
      Web3Method2["childRequestEthereumAccounts"] = "childRequestEthereumAccounts";
      Web3Method2["addEthereumChain"] = "addEthereumChain";
      Web3Method2["switchEthereumChain"] = "switchEthereumChain";
      Web3Method2["makeEthereumJSONRPCRequest"] = "makeEthereumJSONRPCRequest";
      Web3Method2["watchAsset"] = "watchAsset";
    })(Web3Method = exports.Web3Method || (exports.Web3Method = {}));
  }
});

// node_modules/walletlink/dist/relay/RelayMessage.js
var require_RelayMessage = __commonJS({
  "node_modules/walletlink/dist/relay/RelayMessage.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelayMessageType = void 0;
    var RelayMessageType;
    (function(RelayMessageType2) {
      RelayMessageType2["SESSION_ID_REQUEST"] = "SESSION_ID_REQUEST";
      RelayMessageType2["SESSION_ID_RESPONSE"] = "SESSION_ID_RESPONSE";
      RelayMessageType2["LINKED"] = "LINKED";
      RelayMessageType2["UNLINKED"] = "UNLINKED";
      RelayMessageType2["WEB3_REQUEST"] = "WEB3_REQUEST";
      RelayMessageType2["WEB3_REQUEST_CANCELED"] = "WEB3_REQUEST_CANCELED";
      RelayMessageType2["WEB3_RESPONSE"] = "WEB3_RESPONSE";
    })(RelayMessageType = exports.RelayMessageType || (exports.RelayMessageType = {}));
  }
});

// node_modules/walletlink/dist/relay/Web3RequestCanceledMessage.js
var require_Web3RequestCanceledMessage = __commonJS({
  "node_modules/walletlink/dist/relay/Web3RequestCanceledMessage.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3RequestCanceledMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestCanceledMessage(id) {
      return { type: RelayMessage_1.RelayMessageType.WEB3_REQUEST_CANCELED, id };
    }
    exports.Web3RequestCanceledMessage = Web3RequestCanceledMessage;
  }
});

// node_modules/walletlink/dist/relay/Web3RequestMessage.js
var require_Web3RequestMessage = __commonJS({
  "node_modules/walletlink/dist/relay/Web3RequestMessage.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3RequestMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_REQUEST }, params);
    }
    exports.Web3RequestMessage = Web3RequestMessage;
  }
});

// node_modules/walletlink/dist/relay/Web3Response.js
var require_Web3Response = __commonJS({
  "node_modules/walletlink/dist/relay/Web3Response.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumAddressFromSignedMessageResponse = exports.SubmitEthereumTransactionResponse = exports.SignEthereumTransactionResponse = exports.SignEthereumMessageResponse = exports.isRequestEthereumAccountsResponse = exports.WatchAssetReponse = exports.RequestEthereumAccountsResponse = exports.SwitchEthereumChainResponse = exports.AddEthereumChainResponse = exports.ErrorResponse = void 0;
    var Web3Method_1 = require_Web3Method();
    function ErrorResponse(method, errorMessage, errorCode) {
      return { method, errorMessage, errorCode };
    }
    exports.ErrorResponse = ErrorResponse;
    function AddEthereumChainResponse(addResponse) {
      return {
        method: Web3Method_1.Web3Method.addEthereumChain,
        result: addResponse
      };
    }
    exports.AddEthereumChainResponse = AddEthereumChainResponse;
    function SwitchEthereumChainResponse(switchResponse) {
      return {
        method: Web3Method_1.Web3Method.switchEthereumChain,
        result: switchResponse
      };
    }
    exports.SwitchEthereumChainResponse = SwitchEthereumChainResponse;
    function RequestEthereumAccountsResponse(addresses) {
      return { method: Web3Method_1.Web3Method.requestEthereumAccounts, result: addresses };
    }
    exports.RequestEthereumAccountsResponse = RequestEthereumAccountsResponse;
    function WatchAssetReponse(success) {
      return { method: Web3Method_1.Web3Method.watchAsset, result: success };
    }
    exports.WatchAssetReponse = WatchAssetReponse;
    function isRequestEthereumAccountsResponse(res) {
      return res && res.method === Web3Method_1.Web3Method.requestEthereumAccounts;
    }
    exports.isRequestEthereumAccountsResponse = isRequestEthereumAccountsResponse;
    function SignEthereumMessageResponse(signature) {
      return { method: Web3Method_1.Web3Method.signEthereumMessage, result: signature };
    }
    exports.SignEthereumMessageResponse = SignEthereumMessageResponse;
    function SignEthereumTransactionResponse(signedData) {
      return { method: Web3Method_1.Web3Method.signEthereumTransaction, result: signedData };
    }
    exports.SignEthereumTransactionResponse = SignEthereumTransactionResponse;
    function SubmitEthereumTransactionResponse(txHash) {
      return { method: Web3Method_1.Web3Method.submitEthereumTransaction, result: txHash };
    }
    exports.SubmitEthereumTransactionResponse = SubmitEthereumTransactionResponse;
    function EthereumAddressFromSignedMessageResponse(address) {
      return {
        method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
        result: address
      };
    }
    exports.EthereumAddressFromSignedMessageResponse = EthereumAddressFromSignedMessageResponse;
  }
});

// node_modules/walletlink/dist/relay/Web3ResponseMessage.js
var require_Web3ResponseMessage = __commonJS({
  "node_modules/walletlink/dist/relay/Web3ResponseMessage.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWeb3ResponseMessage = exports.Web3ResponseMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3ResponseMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_RESPONSE }, params);
    }
    exports.Web3ResponseMessage = Web3ResponseMessage;
    function isWeb3ResponseMessage(msg) {
      return msg && msg.type === RelayMessage_1.RelayMessageType.WEB3_RESPONSE;
    }
    exports.isWeb3ResponseMessage = isWeb3ResponseMessage;
  }
});

// node_modules/walletlink/dist/relay/WalletLinkRelay.js
var require_WalletLinkRelay = __commonJS({
  "node_modules/walletlink/dist/relay/WalletLinkRelay.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
    } : function(o3, v3) {
      o3["default"] = v3;
    });
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r3 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i3 = decorators.length - 1; i3 >= 0; i3--)
          if (d3 = decorators[i3])
            r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
      return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkRelay = void 0;
    var bind_decorator_1 = __importDefault(require_bind_decorator());
    var eth_rpc_errors_1 = require_dist();
    var rxjs_1 = (init_esm5(), esm5_exports);
    var operators_1 = (init_operators(), operators_exports);
    var WalletLinkAnalytics_1 = require_WalletLinkAnalytics();
    var WalletLinkConnection_1 = require_WalletLinkConnection();
    var init_1 = require_init();
    var util_1 = require_util();
    var aes256gcm = __importStar(require_aes256gcm());
    var Session_1 = require_Session();
    var WalletLinkRelayAbstract_1 = require_WalletLinkRelayAbstract();
    var Web3Method_1 = require_Web3Method();
    var Web3RequestCanceledMessage_1 = require_Web3RequestCanceledMessage();
    var Web3RequestMessage_1 = require_Web3RequestMessage();
    var Web3Response_1 = require_Web3Response();
    var Web3ResponseMessage_1 = require_Web3ResponseMessage();
    var WalletLinkRelay = class extends WalletLinkRelayAbstract_1.WalletLinkRelayAbstract {
      constructor(options) {
        super();
        this.accountsCallback = null;
        this.chainCallback = null;
        this.appName = "";
        this.appLogoUrl = null;
        this.subscriptions = new rxjs_1.Subscription();
        this.walletLinkUrl = options.walletLinkUrl;
        this.storage = options.storage;
        this._session = Session_1.Session.load(options.storage) || new Session_1.Session(options.storage).save();
        this.relayEventManager = options.relayEventManager;
        this.walletLinkAnalytics = options.walletLinkAnalytics ? options.walletLinkAnalytics : new WalletLinkAnalytics_1.WalletLinkAnalytics();
        this.connection = new WalletLinkConnection_1.WalletLinkConnection(this._session.id, this._session.key, this.walletLinkUrl, this.walletLinkAnalytics);
        this.subscriptions.add(this.connection.incomingEvent$.pipe((0, operators_1.filter)((m3) => m3.event === "Web3Response")).subscribe({ next: this.handleIncomingEvent }));
        this.subscriptions.add(this.connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)((linked) => {
          var _a;
          this.isLinked = linked;
          const cachedAddresses = this.storage.getItem(WalletLinkRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
          if (linked) {
            this.session.linked = linked;
          }
          this.isUnlinkedErrorState = false;
          if (cachedAddresses) {
            const addresses = cachedAddresses.split(" ");
            const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
            if (addresses[0] !== "" && !linked && this.session.linked && !wasConnectedViaStandalone) {
              this.isUnlinkedErrorState = true;
              const sessionIdHash = this.getSessionIdHash();
              (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.UNLINKED_ERROR_STATE, { sessionIdHash, origin: location.origin });
            }
          }
        })).subscribe());
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => !!c3.metadata && c3.metadata.__destroyed === "1")).subscribe(() => {
          var _a;
          const alreadyDestroyed = this.connection.isDestroyed;
          (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.METADATA_DESTROYED, {
            alreadyDestroyed,
            sessionIdHash: this.getSessionIdHash(),
            origin: location.origin
          });
          return this.resetAndReload();
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => c3.metadata && c3.metadata.WalletUsername !== void 0)).pipe((0, operators_1.mergeMap)((c3) => aes256gcm.decrypt(c3.metadata.WalletUsername, this._session.secret))).subscribe({
          next: (walletUsername) => {
            this.storage.setItem(WalletLinkRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);
          },
          error: () => {
            var _a;
            (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "username"
            });
          }
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => c3.metadata && c3.metadata.AppVersion !== void 0)).pipe((0, operators_1.mergeMap)((c3) => aes256gcm.decrypt(c3.metadata.AppVersion, this._session.secret))).subscribe({
          next: (appVersion) => {
            this.storage.setItem(WalletLinkRelayAbstract_1.APP_VERSION_KEY, appVersion);
          },
          error: () => {
            var _a;
            (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "appversion"
            });
          }
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => c3.metadata && c3.metadata.ChainId !== void 0 && c3.metadata.JsonRpcUrl !== void 0)).pipe((0, operators_1.mergeMap)((c3) => (0, rxjs_1.zip)(aes256gcm.decrypt(c3.metadata.ChainId, this._session.secret), aes256gcm.decrypt(c3.metadata.JsonRpcUrl, this._session.secret)))).pipe((0, operators_1.distinctUntilChanged)()).subscribe({
          next: ([chainId, jsonRpcUrl]) => {
            if (this.chainCallback) {
              this.chainCallback(chainId, jsonRpcUrl);
            }
          },
          error: () => {
            var _a;
            (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "chainId|jsonRpcUrl"
            });
          }
        }));
        this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c3) => c3.metadata && c3.metadata.EthereumAddress !== void 0)).pipe((0, operators_1.mergeMap)((c3) => aes256gcm.decrypt(c3.metadata.EthereumAddress, this._session.secret))).subscribe({
          next: (selectedAddress) => {
            if (this.accountsCallback) {
              this.accountsCallback([selectedAddress]);
            }
            if (WalletLinkRelay.accountRequestCallbackIds.size > 0) {
              Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id) => {
                const message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({
                  id,
                  response: (0, Web3Response_1.RequestEthereumAccountsResponse)([
                    selectedAddress
                  ])
                });
                this.invokeCallback(Object.assign(Object.assign({}, message), { id }));
              });
              WalletLinkRelay.accountRequestCallbackIds.clear();
            }
          },
          error: () => {
            var _a;
            (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "selectedAddress"
            });
          }
        }));
        this.ui = options.walletLinkUIConstructor({
          walletLinkUrl: options.walletLinkUrl,
          version: options.version,
          darkMode: options.darkMode,
          session: this._session,
          connected$: this.connection.connected$
        });
        this.connection.connect();
      }
      attachUI() {
        this.ui.attach();
      }
      resetAndReload() {
        this.connection.setSessionMetadata("__destroyed", "1").pipe((0, operators_1.timeout)(1e3), (0, operators_1.catchError)((_3) => (0, rxjs_1.of)(null))).subscribe((_3) => {
          var _a, _b, _c;
          try {
            this.subscriptions.unsubscribe();
          } catch (err) {
            (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
              message: "Had error unsubscribing"
            });
          }
          (_b = this.walletLinkAnalytics) === null || _b === void 0 ? void 0 : _b.sendEvent(init_1.EVENTS.SESSION_STATE_CHANGE, {
            method: "relay::resetAndReload",
            sessionMetadataChange: "__destroyed, 1",
            sessionIdHash: this.getSessionIdHash(),
            origin: location.origin
          });
          this.connection.destroy();
          const storedSession = Session_1.Session.load(this.storage);
          if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
            this.storage.clear();
          } else if (storedSession) {
            (_c = this.walletLinkAnalytics) === null || _c === void 0 ? void 0 : _c.sendEvent(init_1.EVENTS.SKIPPED_CLEARING_SESSION, {
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: Session_1.Session.hash(storedSession.id),
              origin: location.origin
            });
          }
          this.ui.reloadUI();
        }, (err) => {
          var _a;
          (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.FAILURE, {
            method: "relay::resetAndReload",
            message: `failed to reset and reload with ${err}`,
            sessionIdHash: this.getSessionIdHash()
          });
        });
      }
      setAppInfo(appName, appLogoUrl) {
        this.appName = appName;
        this.appLogoUrl = appLogoUrl;
      }
      getStorageItem(key) {
        return this.storage.getItem(key);
      }
      get session() {
        return this._session;
      }
      setStorageItem(key, value) {
        this.storage.setItem(key, value);
      }
      signEthereumMessage(message, address, addPrefix, typedDataJson) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            address,
            addPrefix,
            typedDataJson: typedDataJson || null
          }
        });
      }
      ethereumAddressFromSignedMessage(message, signature, addPrefix) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            signature: (0, util_1.hexStringFromBuffer)(signature, true),
            addPrefix
          }
        });
      }
      signEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: false
          }
        });
      }
      signAndSubmitEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.maxFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxFeePerGas) : null,
            maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: true
          }
        });
      }
      submitEthereumTransaction(signedTransaction, chainId) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.submitEthereumTransaction,
          params: {
            signedTransaction: (0, util_1.hexStringFromBuffer)(signedTransaction, true),
            chainId
          }
        });
      }
      scanQRCode(regExp) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.scanQRCode,
          params: { regExp }
        });
      }
      genericRequest(data, action) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.generic,
          params: {
            action,
            data
          }
        });
      }
      sendGenericMessage(request) {
        return this.sendRequest(request);
      }
      sendRequest(request) {
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = () => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          if (!this.ui.isStandalone()) {
            hideSnackbarItem = this.ui.showConnecting({
              isUnlinkedErrorState: this.isUnlinkedErrorState,
              onCancel: cancel,
              onResetConnection: this.resetAndReload
            });
          }
          this.relayEventManager.callbacks.set(id, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          if (this.ui.isStandalone()) {
            this.sendRequestStandalone(id, request);
          } else {
            this.publishWeb3RequestEvent(id, request);
          }
        });
        return { promise, cancel };
      }
      setConnectDisabled(disabled) {
        this.ui.setConnectDisabled(disabled);
      }
      setAccountsCallback(accountsCallback) {
        this.accountsCallback = accountsCallback;
      }
      setChainCallback(chainCallback) {
        this.chainCallback = chainCallback;
      }
      publishWeb3RequestEvent(id, request) {
        var _a;
        const message = (0, Web3RequestMessage_1.Web3RequestMessage)({ id, request });
        const storedSession = Session_1.Session.load(this.storage);
        (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.WEB3_REQUEST, {
          eventId: message.id,
          method: `relay::${message.request.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
          isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString(),
          origin: location.origin
        });
        this.subscriptions.add(this.publishEvent("Web3Request", message, true).subscribe({
          next: (_3) => {
            var _a2;
            (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.WEB3_REQUEST_PUBLISHED, {
              eventId: message.id,
              method: `relay::${message.request.method}`,
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
              isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString(),
              origin: location.origin
            });
          },
          error: (err) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: message.id,
              response: {
                method: message.request.method,
                errorMessage: err.message
              }
            }));
          }
        }));
      }
      publishWeb3RequestCanceledEvent(id) {
        const message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id);
        this.subscriptions.add(this.publishEvent("Web3RequestCanceled", message, false).subscribe());
      }
      publishEvent(event, message, callWebhook) {
        const secret = this.session.secret;
        return new rxjs_1.Observable((subscriber) => {
          void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), { origin: location.origin })), secret).then((encrypted) => {
            subscriber.next(encrypted);
            subscriber.complete();
          });
        }).pipe((0, operators_1.mergeMap)((encrypted) => {
          return this.connection.publishEvent(event, encrypted, callWebhook);
        }));
      }
      handleIncomingEvent(event) {
        try {
          this.subscriptions.add(aes256gcm.decrypt(event.data, this.session.secret).pipe((0, operators_1.map)((c3) => JSON.parse(c3))).subscribe({
            next: (json) => {
              const message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json) ? json : null;
              if (!message) {
                return;
              }
              this.handleWeb3ResponseMessage(message);
            },
            error: () => {
              var _a;
              (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
                message: "Had error decrypting",
                value: "incomingEvent"
              });
            }
          }));
        } catch (_a) {
          return;
        }
      }
      handleWeb3ResponseMessage(message) {
        var _a;
        const { response } = message;
        (_a = this.walletLinkAnalytics) === null || _a === void 0 ? void 0 : _a.sendEvent(init_1.EVENTS.WEB3_RESPONSE, {
          eventId: message.id,
          method: `relay::${response.method}`,
          sessionIdHash: this.getSessionIdHash(),
          origin: location.origin
        });
        if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {
          Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id) => this.invokeCallback(Object.assign(Object.assign({}, message), { id })));
          WalletLinkRelay.accountRequestCallbackIds.clear();
          return;
        }
        this.invokeCallback(message);
      }
      invokeCallback(message) {
        const callback = this.relayEventManager.callbacks.get(message.id);
        if (callback) {
          callback(message.response);
          this.relayEventManager.callbacks.delete(message.id);
        }
      }
      requestEthereumAccounts() {
        let request = {
          method: Web3Method_1.Web3Method.requestEthereumAccounts,
          params: {
            appName: this.appName,
            appLogoUrl: this.appLogoUrl || null
          }
        };
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = () => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          var _a;
          this.relayEventManager.callbacks.set(id, (response) => {
            this.ui.hideRequestEthereumAccounts();
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const userAgent = ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) || null;
          if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
            window.location.href = `https://go.cb-w.com/xoXnYwQimhb?cb_url=${encodeURIComponent(window.location.href)}`;
            return;
          }
          if (this.ui.inlineAccountsResponse()) {
            const onAccounts = (accounts) => {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id,
                response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)
              }));
            };
            this.ui.requestEthereumAccounts({
              onCancel: cancel,
              onAccounts
            });
          } else {
            this.ui.requestEthereumAccounts({
              onCancel: cancel
            });
          }
          WalletLinkRelay.accountRequestCallbackIds.add(id);
          if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request);
          }
        });
        return { promise, cancel };
      }
      watchAsset(type, address, symbol, decimals, image) {
        const request = {
          method: Web3Method_1.Web3Method.watchAsset,
          params: {
            type,
            options: {
              address,
              symbol,
              decimals,
              image
            }
          }
        };
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = () => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineWatchAsset()) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = () => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.WatchAssetReponse)(false)
            }));
          };
          const approve = () => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.WatchAssetReponse)(true)
            }));
          };
          if (this.ui.inlineWatchAsset()) {
            this.ui.watchAsset({
              onApprove: approve,
              onCancel: _cancel,
              type,
              address,
              symbol,
              decimals,
              image
            });
          }
          if (!this.ui.inlineWatchAsset() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request);
          }
        });
        return { cancel, promise };
      }
      addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
        let request = {
          method: Web3Method_1.Web3Method.addEthereumChain,
          params: {
            chainId,
            rpcUrls,
            blockExplorerUrls,
            chainName,
            iconUrls,
            nativeCurrency
          }
        };
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = () => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineAddEthereumChain(chainId)) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = () => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.AddEthereumChainResponse)({
                isApproved: false,
                rpcUrl: ""
              })
            }));
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.AddEthereumChainResponse)({ isApproved: true, rpcUrl })
            }));
          };
          if (this.ui.inlineAddEthereumChain(chainId)) {
            this.ui.addEthereumChain({
              onCancel: _cancel,
              onApprove: approve,
              chainId: request.params.chainId,
              rpcUrls: request.params.rpcUrls,
              blockExplorerUrls: request.params.blockExplorerUrls,
              chainName: request.params.chainName,
              iconUrls: request.params.iconUrls,
              nativeCurrency: request.params.nativeCurrency
            });
          }
          if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request);
          }
        });
        return { promise, cancel };
      }
      switchEthereumChain(chainId) {
        let request = {
          method: Web3Method_1.Web3Method.switchEthereumChain,
          params: {
            chainId
          }
        };
        let hideSnackbarItem = null;
        const id = (0, util_1.randomBytesHex)(8);
        const cancel = () => {
          this.publishWeb3RequestCanceledEvent(id);
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineSwitchEthereumChain()) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage && response.errorCode) {
              return reject(eth_rpc_errors_1.ethErrors.provider.custom({
                code: response.errorCode,
                message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
              }));
            } else if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (errorCode) => {
            if (errorCode) {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id,
                response: (0, Web3Response_1.ErrorResponse)(Web3Method_1.Web3Method.switchEthereumChain, "unsupported chainId", errorCode)
              }));
            } else {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id,
                response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                  isApproved: false,
                  rpcUrl: ""
                })
              }));
            }
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id,
              response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                isApproved: true,
                rpcUrl
              })
            }));
          };
          this.ui.switchEthereumChain({
            onCancel: _cancel,
            onApprove: approve,
            chainId: request.params.chainId
          });
          if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id, request);
          }
        });
        return { promise, cancel };
      }
      getSessionIdHash() {
        return Session_1.Session.hash(this._session.id);
      }
      sendRequestStandalone(id, request) {
        const _cancel = () => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id,
            response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
          }));
        };
        const onSuccess = (response) => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id,
            response
          }));
        };
        switch (request.method) {
          case Web3Method_1.Web3Method.signEthereumMessage:
            this.ui.signEthereumMessage({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.signEthereumTransaction:
            this.ui.signEthereumTransaction({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.submitEthereumTransaction:
            this.ui.submitEthereumTransaction({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:
            this.ui.ethereumAddressFromSignedMessage({
              request,
              onSuccess
            });
            break;
          default:
            _cancel();
            break;
        }
      }
    };
    WalletLinkRelay.accountRequestCallbackIds = new Set();
    __decorate([
      bind_decorator_1.default
    ], WalletLinkRelay.prototype, "resetAndReload", null);
    __decorate([
      bind_decorator_1.default
    ], WalletLinkRelay.prototype, "handleIncomingEvent", null);
    exports.WalletLinkRelay = WalletLinkRelay;
  }
});

// node_modules/walletlink/dist/relay/WalletLinkRelayEventManager.js
var require_WalletLinkRelayEventManager = __commonJS({
  "node_modules/walletlink/dist/relay/WalletLinkRelayEventManager.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLinkRelayEventManager = void 0;
    var util_1 = require_util();
    var WalletLinkRelayEventManager = class {
      constructor() {
        this._nextRequestId = 0;
        this.callbacks = new Map();
      }
      makeRequestId() {
        this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
        const id = this._nextRequestId;
        const idStr = (0, util_1.prepend0x)(id.toString(16));
        const callback = this.callbacks.get(idStr);
        if (callback) {
          this.callbacks.delete(idStr);
        }
        return id;
      }
    };
    exports.WalletLinkRelayEventManager = WalletLinkRelayEventManager;
  }
});

// node_modules/walletlink/package.json
var require_package = __commonJS({
  "node_modules/walletlink/package.json"(exports, module) {
    module.exports = {
      name: "walletlink",
      version: "2.5.0",
      description: "WalletLink JavaScript SDK",
      keywords: [
        "cipher",
        "cipherbrowser",
        "coinbase",
        "coinbasewallet",
        "eth",
        "ether",
        "ethereum",
        "etherium",
        "injection",
        "toshi",
        "wallet",
        "walletlink",
        "web3"
      ],
      main: "dist/index.js",
      types: "dist/index.d.ts",
      repository: "https://github.com/walletlink/walletlink.git",
      author: "Coinbase, Inc.",
      license: "Apache-2.0",
      scripts: {
        tsc: "tsc --noEmit --pretty",
        test: "yarn build-npm && karma start",
        prebuild: `node -p "'export const LIB_VERSION = ' + JSON.stringify(require('./package.json').version) + ';'" > src/version.ts`,
        build: "node compile-assets.js && webpack --config webpack.config.js",
        "build-chrome": "webpack --config webpack.config.chrome.js",
        "build-npm": "tsc -p ./tsconfig.build.json",
        "build:dev": "export WALLETLINK_URL='http://localhost:3000'; yarn build && yarn build-chrome",
        "build:dev:watch": "nodemon -e 'ts,tsx,js,json,css,scss,svg' --ignore 'src/**/*-css.ts' --ignore 'src/**/*-svg.ts' --watch src/ --watch chrome/ --exec 'yarn build:dev'",
        "build:prod": `yarn prebuild && yarn build && yarn build-chrome && yarn build-npm && cp ./package.json ./README.md ./LICENSE build/npm && cp -a src/vendor-js build/npm/dist && sed -i.bak 's|  "private": true,||g' build/npm/package.json && rm -f build/npm/package.json.bak`,
        lint: "eslint ./src --ext .ts,.tsx",
        "lint:watch": "nodemon -e ts,tsx,js,json,css,scss,svg --watch src/ --exec 'yarn tsc && yarn lint'"
      },
      dependencies: {
        "@metamask/safe-event-emitter": "2.0.0",
        "bind-decorator": "^1.0.11",
        "bn.js": "^5.1.1",
        clsx: "^1.1.0",
        "eth-block-tracker": "4.4.3",
        "eth-json-rpc-filters": "4.2.2",
        "eth-rpc-errors": "4.0.2",
        "js-sha256": "0.9.0",
        "json-rpc-engine": "6.1.0",
        keccak: "^3.0.1",
        preact: "^10.5.9",
        rxjs: "^6.6.3",
        "stream-browserify": "^3.0.0"
      },
      devDependencies: {
        "@types/bn.js": "^4.11.6",
        "@types/node": "^14.14.20",
        "@typescript-eslint/eslint-plugin": "^5.7.0",
        "@typescript-eslint/eslint-plugin-tslint": "^5.7.0",
        "@typescript-eslint/parser": "^5.7.0",
        browserify: "17.0.0",
        "copy-webpack-plugin": "^6.4.1",
        "core-js": "^3.8.2",
        eslint: "^8.4.1",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-import": "^2.25.3",
        "eslint-plugin-preact": "^0.1.0",
        "eslint-plugin-prettier": "^4.0.0",
        "eslint-plugin-simple-import-sort": "^7.0.0",
        jasmine: "3.8.0",
        karma: "^6.3.15",
        "karma-browserify": "8.1.0",
        "karma-chrome-launcher": "^3.1.0",
        "karma-jasmine": "^4.0.1",
        nodemon: "^2.0.6",
        prettier: "^2.5.1",
        "raw-loader": "^4.0.2",
        "regenerator-runtime": "^0.13.7",
        sass: "^1.32.0",
        svgo: "^2.8.0",
        "ts-jest": "^26.4.4",
        "ts-loader": "^8.0.13",
        tslib: "^2.0.3",
        typescript: "^4.1.3",
        watchify: "4.0.0",
        webpack: "^5.49.0",
        "webpack-cli": "^3.3.12",
        "whatwg-fetch": "^3.5.0"
      },
      engines: {
        node: ">= 10.0.0"
      },
      jest: {
        transform: {
          "^.+\\.tsx?$": "ts-jest"
        },
        testEnvironment: "node",
        testPathIgnorePatterns: [
          "<rootDir>/dist/",
          "<rootDir>/node_modules/"
        ],
        testRegex: "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
        moduleFileExtensions: [
          "ts",
          "js",
          "json"
        ]
      }
    };
  }
});

// node_modules/walletlink/dist/WalletLink.js
var require_WalletLink = __commonJS({
  "node_modules/walletlink/dist/WalletLink.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLink = void 0;
    var WalletLinkAnalytics_1 = require_WalletLinkAnalytics();
    var ScopedLocalStorage_1 = require_ScopedLocalStorage();
    var WalletLinkProvider_1 = require_WalletLinkProvider();
    var WalletLinkSdkUI_1 = require_WalletLinkSdkUI();
    var WalletLinkRelay_1 = require_WalletLinkRelay();
    var WalletLinkRelayEventManager_1 = require_WalletLinkRelayEventManager();
    var util_1 = require_util();
    var WALLETLINK_URL = process.env.WALLETLINK_URL || "https://www.walletlink.org";
    var WALLETLINK_VERSION = process.env.WALLETLINK_VERSION || require_package().version || "unknown";
    var WalletLink = class {
      constructor(options) {
        var _a;
        this._appName = "";
        this._appLogoUrl = null;
        this._relay = null;
        this._relayEventManager = null;
        const walletLinkUrl = options.walletLinkUrl || WALLETLINK_URL;
        let walletLinkUIConstructor;
        if (!options.walletLinkUIConstructor) {
          walletLinkUIConstructor = (opts) => new WalletLinkSdkUI_1.WalletLinkSdkUI(opts);
        } else {
          walletLinkUIConstructor = options.walletLinkUIConstructor;
        }
        if (typeof options.overrideIsMetaMask === "undefined") {
          this._overrideIsMetaMask = false;
        } else {
          this._overrideIsMetaMask = options.overrideIsMetaMask;
        }
        this._overrideIsCoinbaseWallet = (_a = options.overrideIsCoinbaseWallet) !== null && _a !== void 0 ? _a : true;
        this._walletLinkAnalytics = options.walletLinkAnalytics ? options.walletLinkAnalytics : new WalletLinkAnalytics_1.WalletLinkAnalytics();
        const u3 = new URL(walletLinkUrl);
        const walletLinkOrigin = `${u3.protocol}//${u3.host}`;
        this._storage = new ScopedLocalStorage_1.ScopedLocalStorage(`-walletlink:${walletLinkOrigin}`);
        this._storage.setItem("version", WalletLink.VERSION);
        if (typeof window.walletLinkExtension !== "undefined") {
          return;
        }
        this._relayEventManager = new WalletLinkRelayEventManager_1.WalletLinkRelayEventManager();
        this._relay = new WalletLinkRelay_1.WalletLinkRelay({
          walletLinkUrl,
          version: WALLETLINK_VERSION,
          darkMode: !!options.darkMode,
          walletLinkUIConstructor,
          storage: this._storage,
          relayEventManager: this._relayEventManager,
          walletLinkAnalytics: this._walletLinkAnalytics
        });
        this.setAppInfo(options.appName, options.appLogoUrl);
        this._relay.attachUI();
      }
      makeWeb3Provider(jsonRpcUrl = "", chainId = 1) {
        if (typeof window.walletLinkExtension !== "undefined") {
          if (typeof window.walletLinkExtension.isCipher !== "boolean" || !window.walletLinkExtension.isCipher) {
            window.walletLinkExtension.setProviderInfo(jsonRpcUrl, chainId);
          }
          return window.walletLinkExtension;
        }
        const relay = this._relay;
        if (!relay || !this._relayEventManager || !this._storage) {
          throw new Error("Relay not initialized, should never happen");
        }
        if (!jsonRpcUrl)
          relay.setConnectDisabled(true);
        return new WalletLinkProvider_1.WalletLinkProvider({
          relayProvider: () => Promise.resolve(relay),
          relayEventManager: this._relayEventManager,
          storage: this._storage,
          jsonRpcUrl,
          chainId,
          walletLinkAnalytics: this._walletLinkAnalytics,
          overrideIsMetaMask: this._overrideIsMetaMask,
          overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet
        });
      }
      setAppInfo(appName, appLogoUrl) {
        var _a;
        this._appName = appName || "DApp";
        this._appLogoUrl = appLogoUrl || (0, util_1.getFavicon)();
        if (typeof window.walletLinkExtension !== "undefined") {
          if (typeof window.walletLinkExtension.isCipher !== "boolean" || !window.walletLinkExtension.isCipher) {
            window.walletLinkExtension.setAppInfo(this._appName, this._appLogoUrl);
          }
        } else {
          (_a = this._relay) === null || _a === void 0 ? void 0 : _a.setAppInfo(this._appName, this._appLogoUrl);
        }
      }
      disconnect() {
        var _a;
        if (typeof window.walletLinkExtension !== "undefined") {
          window.walletLinkExtension.close();
        } else {
          (_a = this._relay) === null || _a === void 0 ? void 0 : _a.resetAndReload();
        }
      }
    };
    exports.WalletLink = WalletLink;
    WalletLink.VERSION = WALLETLINK_VERSION;
  }
});

// node_modules/walletlink/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/walletlink/dist/index.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletLink = exports.WalletLinkProvider = void 0;
    var WalletLinkProvider_1 = require_WalletLinkProvider();
    var WalletLink_1 = require_WalletLink();
    var WalletLinkProvider_2 = require_WalletLinkProvider();
    Object.defineProperty(exports, "WalletLinkProvider", { enumerable: true, get: function() {
      return WalletLinkProvider_2.WalletLinkProvider;
    } });
    var WalletLink_2 = require_WalletLink();
    Object.defineProperty(exports, "WalletLink", { enumerable: true, get: function() {
      return WalletLink_2.WalletLink;
    } });
    exports.default = WalletLink_1.WalletLink;
    if (typeof window !== "undefined") {
      window.WalletLink = WalletLink_1.WalletLink;
      window.WalletLinkProvider = WalletLinkProvider_1.WalletLinkProvider;
    }
  }
});

export {
  require_dist2 as require_dist
};
//# sourceMappingURL=chunk-PFQLUTDE.js.map
