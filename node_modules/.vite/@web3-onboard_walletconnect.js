import {
  ProviderRpcError,
  ProviderRpcErrorCode
} from "./chunk-QMB77UJZ.js";
import "./chunk-AOTIW23S.js";
import {
  StaticJsonRpcProvider
} from "./chunk-NYT6S7VH.js";
import "./chunk-ZOYOG4LU.js";
import "./chunk-TRWCPFR4.js";
import "./chunk-7SH6SCUR.js";
import "./chunk-PDRUHE3M.js";
import "./chunk-WAO7O4Z6.js";
import {
  init_buffer,
  init_virtual_process_polyfill
} from "./chunk-QYANIK43.js";

// dep:@web3-onboard_walletconnect
init_virtual_process_polyfill();
init_buffer();

// node_modules/@web3-onboard/walletconnect/dist/index.js
init_virtual_process_polyfill();
init_buffer();
function walletConnect(options) {
  const { bridge = "https://bridge.walletconnect.org", qrcodeModalOptions } = options || {};
  return () => {
    return {
      label: "WalletConnect",
      getIcon: async () => (await import("./icon-73DITQQH.js")).default,
      getInterface: async ({ chains, EventEmitter }) => {
        const { default: WalletConnect } = await import("./esm-B7CLTZWK.js");
        const { default: QRCodeModal } = await import("./cjs-5A6BQZ77.js");
        const { Subject, fromEvent } = await import("./esm5-JIZLA4Q6.js");
        const { takeUntil, take } = await import("./operators-IKBMGGCC.js");
        const connector = new WalletConnect({
          bridge
        });
        const emitter = new EventEmitter();
        class EthProvider {
          constructor({ connector: connector2, chains: chains2 }) {
            this.emit = emitter.emit.bind(emitter);
            this.on = emitter.on.bind(emitter);
            this.removeListener = emitter.removeListener.bind(emitter);
            this.connector = connector2;
            this.chains = chains2;
            this.disconnected$ = new Subject();
            this.providers = {};
            fromEvent(this.connector, "session_update", (error, payload) => {
              if (error) {
                throw error;
              }
              return payload;
            }).pipe(takeUntil(this.disconnected$)).subscribe({
              next: ({ params }) => {
                const [{ accounts, chainId }] = params;
                this.emit("accountsChanged", accounts);
                this.emit("chainChanged", `0x${chainId.toString(16)}`);
              },
              error: console.warn
            });
            fromEvent(this.connector, "disconnect", (error, payload) => {
              if (error) {
                throw error;
              }
              return payload;
            }).pipe(takeUntil(this.disconnected$)).subscribe({
              next: () => {
                this.emit("accountsChanged", []);
                this.disconnected$.next(true);
                typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
              },
              error: console.warn
            });
            this.disconnect = () => this.connector.killSession();
            this.request = async ({ method, params }) => {
              if (method === "eth_chainId") {
                return `0x${this.connector.chainId.toString(16)}`;
              }
              if (method === "eth_requestAccounts") {
                return new Promise((resolve, reject) => {
                  if (!this.connector.connected) {
                    this.connector.createSession().then(() => {
                      QRCodeModal.open(this.connector.uri, () => reject(new ProviderRpcError({
                        code: 4001,
                        message: "User rejected the request."
                      })), qrcodeModalOptions);
                    });
                  } else {
                    const { accounts, chainId: chainId2 } = this.connector.session;
                    this.emit("chainChanged", `0x${chainId2.toString(16)}`);
                    return resolve(accounts);
                  }
                  fromEvent(this.connector, "connect", (error, payload) => {
                    if (error) {
                      throw error;
                    }
                    return payload;
                  }).pipe(take(1)).subscribe({
                    next: ({ params: params2 }) => {
                      const [{ accounts, chainId: chainId2 }] = params2;
                      this.emit("accountsChanged", accounts);
                      this.emit("chainChanged", `0x${chainId2.toString(16)}`);
                      QRCodeModal.close();
                      resolve(accounts);
                    },
                    error: reject
                  });
                });
              }
              if (method === "wallet_switchEthereumChain" || method === "eth_selectAccounts") {
                throw new ProviderRpcError({
                  code: ProviderRpcErrorCode.UNSUPPORTED_METHOD,
                  message: `The Provider does not support the requested method: ${method}`
                });
              }
              if (method === "eth_sendTransaction") {
                return this.connector.sendTransaction(params[0]);
              }
              if (method === "eth_signTransaction") {
                return this.connector.signTransaction(params[0]);
              }
              if (method === "personal_sign") {
                return this.connector.signPersonalMessage(params);
              }
              if (method === "eth_sign") {
                return this.connector.signMessage(params);
              }
              if (method === "eth_signTypedData") {
                return this.connector.signTypedData(params);
              }
              if (method === "eth_accounts") {
                return this.connector.sendCustomRequest({
                  id: 1337,
                  jsonrpc: "2.0",
                  method,
                  params
                });
              }
              const chainId = await this.request({ method: "eth_chainId" });
              if (!this.providers[chainId]) {
                const currentChain = chains2.find(({ id }) => id === chainId);
                if (!currentChain) {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.CHAIN_NOT_ADDED,
                    message: `The Provider does not have a rpcUrl to make a request for the requested method: ${method}`
                  });
                }
                this.providers[chainId] = new StaticJsonRpcProvider(currentChain.rpcUrl);
              }
              return this.providers[chainId].send(method, params);
            };
          }
        }
        return {
          provider: new EthProvider({ chains, connector })
        };
      }
    };
  };
}
var dist_default = walletConnect;

// dep:@web3-onboard_walletconnect
var web3_onboard_walletconnect_default = dist_default;
export {
  web3_onboard_walletconnect_default as default
};
//# sourceMappingURL=@web3-onboard_walletconnect.js.map
